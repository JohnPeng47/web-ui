{
  "reported_to": "WordPress",
  "reported_by": "simonscannell ",
  "title": "pre-auth Stored XSS in comments via javascript: url when administrator edits user supplied comment",
  "content": "\nWhen a comment is submitted, it is filtered via wp_rel_nofollow_callback(), which adds the rel attribute to <a> tags within the anchor:\nCode 879 Bytes\n1function wp_rel_nofollow_callback( $matches ) {\n2\t$text = $matches[1];\n3\t$atts = shortcode_parse_atts( $matches[1] );\n4\t$rel  = 'nofollow';\n5\n6\tif ( ! empty( $atts['href'] ) ) {\n7\t\tif ( in_array( strtolower( wp_parse_url( $atts['href'], PHP_URL_SCHEME ) ), array( 'http', 'https' ), true ) ) {\n8\t\t\tif ( strtolower( wp_parse_url( $atts['href'], PHP_URL_HOST ) ) === strtolower( wp_parse_url( home_url(), PHP_URL_HOST ) ) ) {\n9\t\t\t\treturn \"<a $text>\";\n10\t\t\t}\n11\t\t}\n12\t}\n13\n14\tif ( ! empty( $atts['rel'] ) ) {\n15\t\t$parts = array_map( 'trim', explode( ' ', $atts['rel'] ) );\n16\t\tif ( false === array_search( 'nofollow', $parts ) ) {\n17\t\t\t$parts[] = 'nofollow';\n18\t\t}\n19\t\t$rel = implode( ' ', $parts );\n20\t\tunset( $atts['rel'] );\n21\n22\t\t$html = '';\n23\t\tforeach ( $atts as $name => $value ) {\n24\t\t\t$html .= \"{$name}=\\\"\" .  $value . '\" ';\n25\t\t}\n26\t\t$text = trim( $html );\n27\t}\n28\treturn \"<a $text rel=\\\"\" . esc_attr( $rel ) . '\">';\n29}\nif the rel attribute is already set, the <a> tag is built back together with the values returned by shortcode_parse_atts(). This is problematic, since shortcode_parse_atts() calls stripcslashes() on the attribute values, which for example allows turning \\x3a into :.\nTherefor the esc_url() function can be bypassed by:\nusing a URL such as javascript\\x3aalert(1);\ngetting an admin to edit and update the comment containing the XSS payload\ndone\nI recommend moving away from shortcode_parse_atts() because of side effects like these. I also got close to a XSS without user interaction through the same mechanisms but it fails luckily.\nPoC:\nAs an unauthenticated user, create a comment with the following content:\nCode 197 Bytes\n1Hi!\n2I really enjoy your work. We've also written a blog post about it here: http://dummysite.com/awesome-blogpost. Feel free to check it out!\n3<a href=\"javascript\\x3aalert(1);\">Visit my web page</a>\ncreate a second comment with the content:\nCode 116 Bytes\n1I just noticed a typo in the URL! Could you please change it from dummysite.com to dummysite2.com? Thank you so much\nLog in as an admin, go to the comments section and edit the comment and click save\nView the comment on the post, click the \"Visit my web page\" URL and see the alert() box popping up.\nImpact\nThrough the XSS, RCE can be gained. Obviously a lot of user interaction is required but yeah, it is a super easy to copy & paste payload that could be used against non technical users. The XSS could then also be triggered via clickjacking.\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": null,
  "weaknesses": [
    "Cross-site Scripting (XSS) - Stored"
  ],
  "screenshots": {},
  "disclosed_date": 1597788060,
  "report_url": "https://hackerone.com/reports/633231",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "As an unauthenticated user, create a comment with the following content: 'Hi! I really enjoy your work. We've also written a blog post about it here: http://dummysite.com/awesome-blogpost. Feel free to check it out! <a href=\"javascript\\x3aalert(1);\">Visit my web page</a>'"
    ],
    [
      2,
      "Create a second comment requesting an admin to edit the first comment. Log in as an admin, edit the first comment, and save it. View the comment on the post and click the 'Visit my web page' URL to trigger the XSS."
    ]
  ],
  "vuln_description": "A pre-auth stored XSS vulnerability exists in the comments section when an administrator edits a user-supplied comment containing a malicious JavaScript URL. The vulnerability arises due to the improper handling of escaped characters in the URL by the `shortcode_parse_atts()` function, which allows bypassing the `esc_url()` function.",
  "reason": "The vulnerability requires understanding the interaction between the `wp_rel_nofollow_callback()` function, `shortcode_parse_atts()`, and the `esc_url()` function. The attacker must also know how to craft a payload that bypasses URL filtering by using escaped characters. Additionally, the attack requires an admin to edit the comment, adding a layer of complexity.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "injection_metadata": {
    "is_simple_payload": false
  },
  "authnz_metadata": {
    "reason": "The vulnerability involves a stored XSS that requires an admin to edit a user-supplied comment. The methodology described focuses on testing authorization boundaries by swapping user sessions and resource IDs, but does not specifically address the scenario where an admin's action (editing a comment) triggers the XSS. The XSS payload is stored and then executed when the admin interacts with it, which is not directly covered by the described AuthN/AuthZ testing methodologies.",
    "is_detectable": false
  }
}