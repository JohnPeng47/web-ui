{
  "reported_to": "X (Formerly Twitter)",
  "reported_by": "alesandroortiz ",
  "title": "Android WebViews in Twitter app are vulnerable to UXSS due to configuration and CVE-2020-6506",
  "content": "\nSummary:\nCVSS score: 8.1 / High / CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N\nEmbargo notice: Do Not Disclose publicly until https://crbug.com/1083819 is disclosed.\nTwitter for Android is affected by a UXSS vulnerability due to its configuration of Android WebView and CVE-2020-6506.\nVendor mitigation is recommended to protect unpatched WebView users, due to its impact and ease of exploitation. Mitigation options which minimize breaking changes are provided for various use cases.\nAndroid WebView is the system component which allows Android apps to display web pages. Apps typically use Android WebView directly or via frameworks/libraries.\nCVE-2020-6506 is a universal cross-site scripting (UXSS) vulnerability in Android WebView which allows cross-origin iframes to execute arbitrary JavaScript in the top-level document. This vulnerability affects vendors which use Android WebView with a default configuration setting, and run on systems with Android WebView version prior to 83.0.4103.106.\nAll relevant details to understand and mitigate the vulnerability should be in this report. As an affected vendor, you may request access to the restricted crbug for full details and discussion, subject to acceptance by the Chromium Security Team. To request access, send me an email.\nCVE-2020-6506 Details:\nEmbargo notice: Do Not Disclose publicly until https://crbug.com/1083819 is disclosed.\nAn Android WebView instance with WebSettings.setSupportMultipleWindows() kept at default or set to false allows an iframe on a different origin bypass same-origin policies and execute arbitrary JavaScript in the top document.\nTo perform the attack, an iframe can call window.open() with a javascript: URL. Other methods of opening a new window, such as a link with target=\u201d_blank\u201d and href=\u201djavascript:...\u201d, can also be used to perform the attack.\nPerforming the attack requires a single user interaction (a tap/click or a keypress). The malicious iframe does not need to be visible, and can obtain the keypress interaction while a user attempts to type in the top-level document (no direct iframe interaction required).\nThe patched version of Android WebView (83.0.4103.106) was released on Monday, June 15th, 2020: https://chromereleases.googleblog.com/2020/06/stable-channel-update-for-desktop_15.html\nVendors can and should mitigate CVE-2020-6506 to protect their users using unpatched Android WebView versions.\nVendor Details:\nTwitter for Android uses WebViews to render the URL in Video Website Cards. This type of Card uses the vulnerable WebView configuration, therefore there's two ways a user can reach the vulnerable WebView:\nAdvertiser creates legitimate Video Website Card pointing to the advertiser URL, then shares it via regular Tweets or paid advertising campaigns.\nAttacker creates Video Website Card with the user-trusted target URL, then shares it via regular Tweets or paid advertising campaigns.\nIf the advertiser/target URL has a malicious or compromised iframe, the iframe can perform the UXSS attack with minimal user interaction (tap/click or keypress). If there's sensitive data in the WebView, it is vulnerable to exfiltration. Page contents and data can also be altered to benefit the attacker, such as requesting sensitive info from the user while purporting to be the advertiser/target URL.\nBased on Twitter's use case, the suggested solution is option 1a or 1b. The final determination is left to the vendor. Reference implementations for each option is available by request.\nIf none of these options appear suitable, please provide feedback to address concerns. Other vendors could have the same concerns, so your input is appreciated to best mitigate for all affected vendors.\nPotential Solutions:\nVendors generally have two choices to mitigate for unpatched WebView users:\nEnable multiwindow support. If needed, implementation options exist to mimic single-window behavior and minimize breaking changes. Does not require multi-tab UI. Suitable for browsers and frameworks.\nKeep multiwindow support disabled, and strictly limit WebView rendering to trusted content only. Suitable for non-browser apps, and for frameworks when used in non-browser apps.\nDetailed choices:\nOption 1a: Enable multiwindow support, and create a new tab in UI or block window creation.\nSuitable and preferred choice for browsers.\nImplementation: Set WebSettings.setSupportMultipleWindows() to true, and handle onCreateWindow() callback to create new tab in UI or block window creation.\nPotential downsides: If all window creation is blocked, user experience may be negative.\nSuitable and preferred choice for browsers.\nImplementation: Set WebSettings.setSupportMultipleWindows() to true, and handle onCreateWindow() callback to create new tab in UI or block window creation.\nPotential downsides: If all window creation is blocked, user experience may be negative.\nOption 1b: Enable multiwindow support, and mimic single-window behavior via WebView instance replacement.\nSuitable for browsers and frameworks. Preferred choice for frameworks.\nPotential implementation: Set WebSettings.setSupportMultipleWindows() to true, and handle onCreateWindow() callback to create a new WebView on top of existing WebView. Rebind any event listeners, state info, and other logic to the new WebView. Finally, destroy the old WebView as soon as possible.\nPotential downsides: May cause breaking changes if existing code expects a single WebView instance for duration of use. To minimize breaking changes, vendor could add an abstraction layer to internally track WebView instances. The abstraction could perform necessary setup/cleanup for each instance to maintain current WebView behavior (such as JS injection on first page load or each page load, event listeners, state, etc.). The abstraction layer could then seamlessly provide existing interfaces to other layers.\nSuitable for browsers and frameworks. Preferred choice for frameworks.\nPotential implementation: Set WebSettings.setSupportMultipleWindows() to true, and handle onCreateWindow() callback to create a new WebView on top of existing WebView. Rebind any event listeners, state info, and other logic to the new WebView. Finally, destroy the old WebView as soon as possible.\nPotential downsides: May cause breaking changes if existing code expects a single WebView instance for duration of use. To minimize breaking changes, vendor could add an abstraction layer to internally track WebView instances. The abstraction could perform necessary setup/cleanup for each instance to maintain current WebView behavior (such as JS injection on first page load or each page load, event listeners, state, etc.). The abstraction layer could then seamlessly provide existing interfaces to other layers.\nOption 1c: Enable multiwindow support, and mimic single-window behavior via WebView instance reuse.\nSuitable for browsers and frameworks.\nOnly if Option 1b is not feasible, and existing code expects a single WebView instance for duration of use. Minimizes breaking changes at the cost of complexity and fragility.\nPotential implementation: Set WebSettings.setSupportMultipleWindows() to true, and handle onCreateWindow() callback. In the callback, create a temporary WebView with shouldOverrideUrlLoading() which returns true (prevents loading) and stores the attempted URL in a variable. Filter the attempted URL to ensure it is a safe HTTP(S) URL, then call loadUrl() on the initial WebView with the attempted URL. Finally, destroy the temporary WebView when convenient.\nPotential downsides: May still cause breaking changes. May break if Android WebView behavior changes in future. Adds complexity which may be difficult to maintain.\nSuitable for browsers and frameworks.\nOnly if Option 1b is not feasible, and existing code expects a single WebView instance for duration of use. Minimizes breaking changes at the cost of complexity and fragility.\nPotential implementation: Set WebSettings.setSupportMultipleWindows() to true, and handle onCreateWindow() callback. In the callback, create a temporary WebView with shouldOverrideUrlLoading() which returns true (prevents loading) and stores the attempted URL in a variable. Filter the attempted URL to ensure it is a safe HTTP(S) URL, then call loadUrl() on the initial WebView with the attempted URL. Finally, destroy the temporary WebView when convenient.\nPotential downsides: May still cause breaking changes. May break if Android WebView behavior changes in future. Adds complexity which may be difficult to maintain.\nOption 2: Keep multiwindow support disabled, and enforce strict origin allowlist.\nSuitable for non-browser apps, and for frameworks when used in non-browser apps.\nBecause the vulnerability is not mitigated with this option, WebViews must only render first-party trusted content in top-level window and iframes. If using cross-origin iframes, they must be properly sandboxed. Cross-origin iframes must avoid sandbox=\"allow-popups allow-top-navigation allow-scripts\" because this allows exploitation.\nPotential downsides: Any bypass of origin filtering allows exploitation of unpatched WebView users. For frameworks with configurable origin allowlists, developers can misconfigure allowlists and make their apps vulnerable.\nSuitable for non-browser apps, and for frameworks when used in non-browser apps.\nBecause the vulnerability is not mitigated with this option, WebViews must only render first-party trusted content in top-level window and iframes. If using cross-origin iframes, they must be properly sandboxed. Cross-origin iframes must avoid sandbox=\"allow-popups allow-top-navigation allow-scripts\" because this allows exploitation.\nPotential downsides: Any bypass of origin filtering allows exploitation of unpatched WebView users. For frameworks with configurable origin allowlists, developers can misconfigure allowlists and make their apps vulnerable.\nAdjacent phishing mitigation: If the current page URL is not guaranteed to be shown to the user, origin allowlists are recommended to mitigate phishing risks. This is an adjacent vulnerability, but it's a good opportunity to mitigate it because URL filtering is likely to be implemented as part of the UXSS mitigation.\nAdditional implementation details for options 1a and 1b: When using multiple WebView instances simultaneously, ensure to destroy the background WebView, unload the background page, or handle background page events safely. Otherwise, background pages can perform actions which should only be allowed by a foreground page, which often cause other security issues.\nEnvironment:\nDevice: Samsung Galaxy S10 + Emulated Android device\nOS version: Android 10 (on both devices)\nTwitter version: 8.50.0-release.02\nSteps To Reproduce:\nPrerequisites:\nSystem with unpatched Android WebView (prior to version 83.0.4103.106)\nTwitter Video Website Card with landing URL pointed to a PoC URL. (Provides WebView with WebSettings.setSupportMultipleWindows() kept at default or set to false.)\nPoC 1: https://twitter.com/AlesandroOrtizR/status/1275538453183238144\nPoC 2: https://twitter.com/AlesandroOrtizR/status/1275538647702548480\nPoC 1: https://twitter.com/AlesandroOrtizR/status/1275538453183238144\nPoC 2: https://twitter.com/AlesandroOrtizR/status/1275538647702548480\nSteps To Reproduce, tap/click interaction, visible iframe:\nUsing the PoC 1 Card, navigate to https://alesandroortiz.com/security/chromiumwebview/cve-2020-6506.html\nTap/click iframe.\nSteps To Reproduce, keypress interaction, hidden iframe:\nUsing the PoC 2 Card, navigate to https://alesandroortiz.com/security/chromiumwebview/cve-2020-6506-keypress-2.html\nTap the \"search this site\" input field to focus it. (This input field is in the parent page, not the iframe.)\nStart typing. Before/while you type, the focus will be stolen by the hidden iframe. After typing a character while the iframe input is focused, the attack is immediately performed. (This can be made more subtle by delaying the focus theft, see code comments.)\nExpected Behavior:\nJavaScript is not executed in top-level document. HTML is not written to top-level document and JS alert dialog is not shown (or a JS alert dialog is shown but with info from iframe document).\nObserved Behavior:\nJavaScript is executed in top-level document. HTML is written to top-level document, and if the WebView allows JS alert dialogs, a JS alert dialog is also shown with info from top-level document.\nSupporting Material/References:\ntwitter-cve-2020-6506.mp4: Screen recording of both reproduction cases.\nTwitter-CVE-2020-6506-Report.pdf: Original report in PDF, in case any formatting is missing or difficult to parse in HackerOne.\nEmbargo notice: Do Not Disclose publicly until https://crbug.com/1083819 is disclosed.\nImpact\nA malicious iframe on any page within the vulnerable WebView can perform a UXSS attack on the top-level document with minimal user interaction.\n\n",
  "severity": [
    8.1,
    null
  ],
  "bounty": 560,
  "weaknesses": [
    "Cross-site Scripting (XSS) - Generic"
  ],
  "screenshots": {},
  "disclosed_date": 1600989060,
  "report_url": "https://hackerone.com/reports/906433",
  "is_multi_component": false,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "MOBILE",
  "steps": [
    [
      1,
      "Using the PoC 1 Card, navigate to https://alesandroortiz.com/security/chromiumwebview/cve-2020-6506.html"
    ],
    [
      2,
      "Tap/click iframe."
    ]
  ],
  "vuln_description": "Twitter for Android is affected by a UXSS vulnerability due to its configuration of Android WebView and CVE-2020-6506. An Android WebView instance with WebSettings.setSupportMultipleWindows() kept at default or set to false allows an iframe on a different origin bypass same-origin policies and execute arbitrary JavaScript in the top document.",
  "reason": "This vulnerability involves understanding the configuration of Android WebView and the specific conditions under which CVE-2020-6506 can be exploited. The attack requires setting up a malicious iframe and understanding how user interactions can trigger the exploit, but the components and interactions are relatively straightforward once the vulnerability is known.",
  "new_complexity": "MEDIUM",
  "requires_code": false,
  "requires_CVE": true,
  "is_ctf": false,
  "other_report": null,
  "injection_metadata": {
    "is_simple_payload": true
  },
  "authnz_metadata": {
    "reason": "The vulnerability involves a UXSS issue in Android WebView configuration, which is not directly related to authentication or authorization boundaries being crossed between user sessions or resources within the same application. The methodology described focuses on testing AuthN/AuthZ boundaries by swapping user sessions and resource IDs, which does not apply to this WebView configuration vulnerability.",
    "is_detectable": false
  }
}