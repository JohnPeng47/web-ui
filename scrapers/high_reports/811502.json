{
  "reported_to": "Node.js",
  "reported_by": "fwilhelm ",
  "title": "Node.js: TLS session reuse can lead to hostname verification bypass",
  "content": "\nThe Node.js TLS library supports client side reuse of TLS sessions when multiple connections to the same server are opened.\nCode that wants to use this feature can listen for the 'session' event (https://nodejs.org/api/tls.html#tls_event_session) on a tls.TLSSocket to get notified of newly created TLS sessions. The documentation for this event explicitly mentions that the passed sessions \"can be used immediately or later\".\nThe problem with this design is that 'session' events are triggered even if verification of the server certificate hostname in onConnectSecure fails. (https://github.com/nodejs/node/blob/b1d4c13430c92e94920f0c8c9ba1295c075c9e89/lib/_tls_wrap.js#L1502):\nonConnectSecure is triggered by the OpenSSL info callback (with the flag SSL_CB_HANDSHAKE_DONE) after a TLS handshake. The 'session' event is triggered by OpenSSLs get_session_cb, which can happen before the info callback in TLS 1.2 and after in TLS 1.3 and which is triggered regardless of the result of onConnectSecure.\nThis means that sessions where the server presented an invalid certificate, or one with a wrong hostname, will trigger the session event and can end up being reused or stored in a cache.\nThat behavior is insecure, because resumed sessions will not be subjected to another hostname verification check as long as they are CA signed:\n// Verify that server's identity matches it's certificate's names\n// Unless server has resumed our existing session\nif (!verifyError && !this.isSessionReused()) {\nconst hostname = options.servername ||\noptions.host ||\n(options.socket && options.socket._host) ||\n'localhost';\nconst cert = this.getPeerCertificate(true);\nverifyError = options.checkServerIdentity(hostname, cert);\n}\nIn practice, this means that the immediate reuse described in the API documentation is always insecure and that session caches are at risk of storing insecure sessions. The most important implementation of a session cache is in the https library (https://github.com/nodejs/node/blob/b1d4c13430c92e94920f0c8c9ba1295c075c9e89/lib/https.js#L130): New sessions are stored in the cache when the \u2018session\u2019 event is triggered and are evicted once a tls socket is closed with an error.\nif (options._agentKey) {\n// Cache new session for reuse\nsocket.on('session', (session) => {\nthis._cacheSession(options._agentKey, session);\n});\n// Evict session on error\nsocket.once('close', (err) => {\nif (err)\nthis._evictSession(options._agentKey);\n});\n}\nThis opens a small race window where an invalid session can be used by other HTTPs requests to the same host. The attached proof-of-concept wins the race reliably against a local server using a setImmediate() callback, but there are probably other ways this could be exploited in real world applications. I also did not fully investigate if there is a way to trigger the socket \u2018close\u2019 event with no error which would skip the session eviction and turn this into a 100% reliable bypass.\nThe POC requires a target server with a valid CA signed certificate (for an arbitrary hostname) and support for TLS resumption. I\u2019ve attached a minimal golang https server that worked for me.\n[fwilhelm@fwilhelm node]$ ../node/node-v13.9.0-linux-x64/bin/node poc.js\n[!] First request failed:Host: nodejs.org. is not in the cert's altnames: DNS:loca.host\n[x] Starting second request\n[x] Dumping globalAgent._sessionCache.map:\n{\n'nodejs.org:8444:::::::::::::::::TLSv1_2_method:': <Buffer 30 82 06 2f 02 01 01 02 02 03 04 04 02 13 01 04 20 cd b7 17 84 ac 9f 31 6f 1c cc 73 de 31 05 eb dc 60 62 df c7 c5 d5 8c b4 75 cc a7 28 1f d9 c0 22 04 ... 1537 more bytes>\n}\n[!] Bypassed hostname verification. Server response: 200\n{\ndate: 'Thu, 05 Mar 2020 17:08:24 GMT',\n'content-length': '29',\n'content-type': 'text/plain; charset=utf-8',\nconnection: 'close'\n}\nThis bug is subject to a 90 day disclosure deadline. After 90 days elapse,\nthe bug report will become visible to the public. The scheduled disclosure\ndate is 2020-06-03. Disclosure at an earlier date is also possible if\nagreed upon by all parties.\nImpact\nMitM of TLS connections\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": null,
  "weaknesses": [
    "Man-in-the-Middle"
  ],
  "screenshots": {},
  "disclosed_date": 1591181700,
  "report_url": "https://hackerone.com/reports/811502",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Set up a server with a valid CA-signed certificate for an arbitrary hostname and support for TLS resumption."
    ],
    [
      2,
      "Use Node.js to make a TLS connection to the server, listen for the 'session' event, and store the session even if hostname verification fails."
    ],
    [
      3,
      "Reuse the stored session in subsequent connections to bypass hostname verification."
    ]
  ],
  "vuln_description": "The Node.js TLS library allows reuse of TLS sessions even when hostname verification fails. This can lead to a bypass of hostname verification checks in subsequent connections, potentially allowing MitM attacks.",
  "reason": "The vulnerability involves understanding the timing and interaction between TLS session events and hostname verification checks, which is non-obvious. It also requires knowledge of how TLS session reuse works in Node.js.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}