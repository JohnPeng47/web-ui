{
    "reported_to": "Node.js",
    "reported_by": "philippjeitner ",
    "title": "Improper handling of untypical characters in domain names",
    "content": "\nDescription\nMissing input validation of host names returned by Domain Name Servers in node's dns library can lead to output of wrong hostnames (leading to Domain Hijacking) and injection vulnerabilities in applications using the library (leading to Remote Code Execution, XSS, Applications crashes, etc.).\nDiscoverer(s)/Credits\nPhilipp Jeitner, Fraunhofer SIT\nReferences\nInjection Attacks Reloaded: Tunnelling Malicious Payloads over DNS\nhttps://www.usenix.org/conference/usenixsecurity21/presentation/jeitner\n(Available starting from August 11, 2021)\nSteps To Reproduce\nUsing the example application (main.js) which does dns lookups via node.\nCode 1.75 KiB\n1const dns = require('dns');\n2\n3if (process.argv[2] == \"-x\") {\n4\tvar host = process.argv[3];\n5\n6\tdns.reverse(host, (err, result) => {\n7\t\t\n8\t\tif (result){\n9\t\t\tfor (var i = 0; i < result.length; i++)\n10\t\t\t{\n11\t\t\t\tconsole.log(\"node\".padEnd(8), \"reverse\".padEnd(16), host.padEnd(30), \"-\".padEnd(80), \"-\".padEnd(10), \"IN\".padEnd(5), \"PTR\".padEnd(5), result[i]);\n12\t\t\t}\n13\t\t} else {\n14\t\t\tconsole.log(\"node\".padEnd(8), \"reverse\".padEnd(16), host.padEnd(30), \"-\".padEnd(80), \"-\".padEnd(10), \"-\".padEnd(5), \"ERROR\".padEnd(5), err.errno);\n15\t\t}\n16\t});\n17\t\n18} else {\n19\tvar host = process.argv[2];\n20\tdns.lookup(host, (err, result) => {\n21\t\tif (result) {\n22\t\t\tconsole.log(\"node\".padEnd(8), \"lookup\".padEnd(16), host.padEnd(30), \"-\".padEnd(80), \"-\".padEnd(10), \"IN\".padEnd(5), \"A\".padEnd(5), result);\n23\t\t} else {\n24\t\t\tconsole.log(\"node\".padEnd(8), \"lookup\".padEnd(16), host.padEnd(30), \"-\".padEnd(80), \"-\".padEnd(10), \"-\".padEnd(5), \"ERROR\".padEnd(5), err.errno);\n25\t\t}\n26\t});\n27\t\n28\tdns.resolve(host, (err, result) => {\n29\t\tif (result) {\n30\t\t\tfor (var i = 0; i < result.length; i++) {\n31\t\t\t\tconsole.log(\"node\".padEnd(8), \"resolve\".padEnd(16), host.padEnd(30), \"-\".padEnd(80), \"-\".padEnd(10), \"IN\".padEnd(5), \"A\".padEnd(5), result[i]);\n32\t\t\t}\n33\t\t} else {\n34\t\t\tconsole.log(\"node\".padEnd(8), \"resolve\".padEnd(16), host.padEnd(30), \"-\".padEnd(80), \"-\".padEnd(10), \"-\".padEnd(5), \"ERROR\".padEnd(5), err.errno);\n35\t\t}\n36\t});\n37\t\n38\tdns.resolveCname(host, (err, result) => {\n39\t\tif (result) {\n40\t\t\tfor (var i = 0; i < result.length; i++) {\n41\t\t\t\tconsole.log(\"node\".padEnd(8), \"resolveCname\".padEnd(16), host.padEnd(30), \"-\".padEnd(80), \"-\".padEnd(10), \"IN\".padEnd(5), \"CNAME\".padEnd(5), result[i]);\n42\t\t\t}\n43\t\t} else {\n44\t\t\tconsole.log(\"node\".padEnd(8), \"resolveCname\".padEnd(16), host.padEnd(30), \"-\".padEnd(80), \"-\".padEnd(10), \"-\".padEnd(5), \"ERROR\".padEnd(5), err.errno);\n45\t\t}\n46\t\t\n47\t});\n48\t\n49}\nRun the code with the example domains provided by us:\nCode 348 Bytes\n1$ node main.js cnamezeroweb.test.xdi-attack.net\n2\n3node     resolveCname     cnamezeroweb.test.xdi-attack.net - -  IN    CNAME zero.longtxtrecord.ml\n4\n5$ node main.js cnamexss.test.xdi-attack.net\n6\n7node     resolveCname     cnamexss.test.xdi-attack.net  - -  IN    CNAME <img/src=''/onerror='alert&#x28&#x22xss&#x22&#x29'>.a.cnamexss.test.xdi-attack.net\nCompare with the output of a well-behaving stub resolver library (glibc) and/or dig:\nCode 598 Bytes\n1$ dig dig cnamezeroweb.test.xdi-attack.net\n2\n3cnamezeroweb.test.xdi-attack.net. 284 IN CNAME  zero.longtxtrecord.ml\\000cnamezeroweb.test.xdi-attack.net.\n4zero.longtxtrecord.ml\\000cnamezeroweb.test.xdi-attack.net. 284 IN A 1.2.3.4\n5\n6$ dig cnamezeroweb.test.xdi-attack.net\n7\n8cnamezeroweb.test.xdi-attack.net. 300 IN CNAME  zero.longtxtrecord.ml\\000cnamezeroweb.test.xdi-attack.net.\n9zero.longtxtrecord.ml\\000cnamezeroweb.test.xdi-attack.net. 299 IN A 1.2.3.4\n10\n11$ getent hosts cnamezeroweb.test.xdi-attack.net\n12$ getent hosts cnamexss.test.xdi-attack.net\n13\n14(no output, return code = 2 because name is filtered)\nThe first issue (cnamezeroweb) is a clear error in zero-byte handling and can potentially lead to DNS-cache injections in case an application implements a cache based on the library.\nThe second (cnamexss) shows that this can be used to tunnel all kinds of injection payloads, and we argue that applications do not typically expect other characters than [a-z0-9-.] in hostnames. We are aware of applications which can be exploited via this second attack vector (stub dns resovlers which does not filter special characters from hostnames) and argue that stub-resolver libraries should only allow hostnames containing [a-z0-9-.], as it is implemented by glibc's gethostbyname, etc. functions. See the Section 'More information' below on standardization of stub resolver functionality.\nNote: One might argue that underscores (_) should also be allowed, since they are used for many application like DMARC, SRV, etc. Actually the underscore was chosen exactly because it is a character not allowed in \"hostnames\" and thus dmarc records (_dmarc.example.com) does not conflict with \"normal\" hostnames (See RFC8552, Section 1.1).\nThe same exploits also apply to reverse-dns records via node's dns.reverse function, and probably functions for other record types as well (not tested). You can test this by setting up a nameserver with the following records, in bind9 this requires disabling the check-names option in the configuration.\nCode 179 Bytes\n11.1.1.1.in-addr.arpa.   300     IN      PTR     t\\000.example.com.\n23.3.3.3.in-addr.arpa.   300     IN      PTR     <img/src=''/onerror='alert&#x28&#x22xss&#x22&#x29'>.example.com.\nThen run node main.js -x 1.1.1.1 and observe the misinterpreted/unfiltered result.\nNote: I selected CWE-170 \"Improper Null Termination\" as a weakness, however this only applies to the first issue. You might want to consider this two seperate issues (zero-byte handling and missing filtering).\nMore information\nThe POSIX Standard for Information Technology defines interfaces for DNS lookups in systems standard C libraries. This Standard includes functions for forward lookups (gethostbyname, getaddrinfo) as well as backward-lookups (gethostbyaddr, getnameinfo). These funtions cannot only return IP addresses but can also contain host names of aliases (CNAME) of the requested host name in case of forward-lookups, or the primary host name of that ip address in the case of backward-lookups (PTR). The POSIX Standard defines the data format of these host names as a null-terminated C-String containing a \"hostname\" or \"nodename\", which are typically expected by developers and defined by RFC952 [2] and RFC1123 [3] to only contain alphanumeric characters (a-z,A-Z,0-9), hyphens (\"-\") and periods (\".\") to split labels. This creates a mismatch of allowed characters between \"hostnames\" and \"domain names\" as defined by the DNS standard [4] which defines \"domain names\" as a series of \"text labels\" which are textually represented by concatenating all \"text labels\" and joining them together with period signs. However, \"text labels\" can contain any octet value, even zero-bytes (\"\\x00\") and period signs (\".\") and recursive DNS resolvers are required by the DNS standard to support any of these characters in DNS records, thus not implementing any sanitiy checks on domain names.\nWhen DNS responses are parsed by the stub DNS resolver implemented by stub resolver library as part of the gethostbyname(), getaddrinfo(), gethostbyaddr() and getnameinfo() functions, these functions must therefore ensure that the returned, null-terminated C-Strings must be valid domain names as defined by the POSIX standard, else applications which use these values might include that information in contexts where malicious data can included inside the domain name and used for command injection attacks like Cross-Site-Scripting, SQL-injections, etc. Furthermore, if domain names contain text labels with periods (\".\") or zero-bytes (\"\\x00\") and the stub resolver library does naively decode these domain names into strings, attackers can create malicious domain names which are misinterpreted by the naive decoding logic to look like different domain names than they actually are. When these misinterpreted domain names are than cached by applications using the stub resolver, this allows for domain hijacking by poisoning of the applications DNS cache which uses the vulnerable stub resolver library.\nNote: node does not implement a stub resolver as standardized by POSIX, so the rules about allowed vs. non-allowed characters do not directly apply. However, we argue that developers do not know about the specifics of the \"hostname\" vs. \"domain name\" consideration, so any library which implements dns lookups should ideally behave in the same way to reduce vulnerabilities caused by developers switching from another language/stub resolver library.\nImpact\nImpact depends on the application triggering the DNS lookup, see description.\n\n",
    "severity": [
        7.5,
        null
    ],
    "bounty": null,
    "weaknesses": [
        "Improper Null Termination"
    ],
    "screenshots": {},
    "disclosed_date": 1631310660,
    "report_url": "https://hackerone.com/reports/1178337",
    "is_multi_component": false,
    "complexity": "HIGH",
    "novelty": "MEDIUM",
    "vuln_category": "CODE",
    "steps": [
        [
            1,
            "Run the Node.js application with a malicious domain name that contains special characters or zero-byte injections (e.g., 'cnamexss.test.xdi-attack.net' or 'cnamezeroweb.test.xdi-attack.net')."
        ],
        [
            2,
            "Observe the output of the DNS lookup functions (dns.lookup, dns.resolve, dns.resolveCname, dns.reverse) to see if the library improperly handles or filters special characters in the returned hostnames."
        ]
    ],
    "vuln_description": "The vulnerability involves improper handling of untypical characters (such as zero-bytes or special characters used in XSS payloads) in domain names returned by DNS queries in Node.js's dns library. This can lead to misinterpretation of domain names, DNS cache poisoning, and injection vulnerabilities (e.g., XSS, RCE) in applications using the library.",
    "reason": "The vulnerability requires understanding of DNS protocol nuances, character encoding in domain names, and how applications might mishandle these inputs. However, the core issue (improper filtering of special characters) is a known class of vulnerability, and the steps to reproduce are straightforward once the malicious domain is identified.",
    "new_complexity": "MEDIUM",
    "requires_code": false,
    "requires_CVE": false,
    "is_ctf": false,
    "other_report": null
}