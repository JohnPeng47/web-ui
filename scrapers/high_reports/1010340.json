{
  "reported_to": "Internet Bug Bounty",
  "reported_by": "simonscannell ",
  "title": "[CVE-2020-27194] Linux kernel: eBPF verifier bug in `or` binary operation tracking function leads to LPE",
  "content": "\nCVE-2020-27194 is a eBPF verifier bug that allows an unprivileged attacker to create BPF socket filter programs that can read and write Out of Bounds, trough which an arbitrary kernel read write can be achieved.\nI'm taking the root cause explanation from the patch email:\nCode 2.19 KiB\n1Simon reported an issue with the current scalar32_min_max_or() implementation.\n2That is, compared to the other 32 bit subreg tracking functions, the code in\n3scalar32_min_max_or() stands out that it's using the 64 bit registers instead\n4of 32 bit ones. This leads to bounds tracking issues, for example:\n5  [...]\n6  8: R0=map_value(id=0,off=0,ks=4,vs=48,imm=0) R10=fp0 fp-8=mmmmmmmm\n7  8: (79) r1 = *(u64 *)(r0 +0)\n8   R0=map_value(id=0,off=0,ks=4,vs=48,imm=0) R10=fp0 fp-8=mmmmmmmm\n9  9: R0=map_value(id=0,off=0,ks=4,vs=48,imm=0) R1_w=inv(id=0) R10=fp0 fp-8=mmmmmmmm\n10  9: (b7) r0 = 1\n11  10: R0_w=inv1 R1_w=inv(id=0) R10=fp0 fp-8=mmmmmmmm\n12  10: (18) r2 = 0x600000002\n13  12: R0_w=inv1 R1_w=inv(id=0) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n14  12: (ad) if r1 < r2 goto pc+1\n15   R0_w=inv1 R1_w=inv(id=0,umin_value=25769803778) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n16  13: R0_w=inv1 R1_w=inv(id=0,umin_value=25769803778) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n17  13: (95) exit\n18  14: R0_w=inv1 R1_w=inv(id=0,umax_value=25769803777,var_off=(0x0; 0x7ffffffff)) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n19  14: (25) if r1 > 0x0 goto pc+1\n20   R0_w=inv1 R1_w=inv(id=0,umax_value=0,var_off=(0x0; 0x7fffffff),u32_max_value=2147483647) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n21  15: R0_w=inv1 R1_w=inv(id=0,umax_value=0,var_off=(0x0; 0x7fffffff),u32_max_value=2147483647) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n22  15: (95) exit\n23  16: R0_w=inv1 R1_w=inv(id=0,umin_value=1,umax_value=25769803777,var_off=(0x0; 0x77fffffff),u32_max_value=2147483647) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n24  16: (47) r1 |= 0\n25  17: R0_w=inv1 R1_w=inv(id=0,umin_value=1,umax_value=32212254719,var_off=(0x1; 0x700000000),s32_max_value=1,u32_max_value=1) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n26  [...]\n27\n28The bound tests on the map value force the upper unsigned bound to be 25769803777\n29in 64 bit (0b11000000000000000000000000000000001) and then lower one to be 1. By\n30using OR they are truncated and thus result in the range [1,1] for the 32 bit reg\n31tracker. This is incorrect given the only thing we know is that the value must be\n32positive and thus 2147483647 (0b1111111111111111111111111111111) at max for the\n33subregs. Fix it by using the {u,s}32_{min,max}_value vars instead\nThe issue was introduced with commit https://github.com/torvalds/linux/commit/3f50f132d8400e129fc9eb68b5020167ef80a244 and patched with commit https://github.com/torvalds/linux/commit/5b9fbeb75b6a98955f628e205ac26689bcb1383e\nThis means the kernel 5.8. stable branch was affected by the vulnerability. I wrote a highly reliable LPE exploit for Fedora 33, which used the 5.8. kernel. Next, week, on october 22nd Ubuntu 22.10 is released which would have been vulnerable as well if I had not reported the vulnerability. Effectively, all distributions could have become affected.\nI will publish the exploit after some time has passed.\nImpact\nThis vulnerability allows for an extremely reliable exploit leading to LPE on default configurations for many distros such as Ubuntu, Debian, Fedora and more.\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": 750,
  "weaknesses": [
    "Privilege Escalation"
  ],
  "screenshots": {},
  "disclosed_date": 1627041300,
  "report_url": "https://hackerone.com/reports/1010340",
  "vuln_category": "CODE",
  "is_multi_component": true,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "steps": [
    [
      1,
      "Create a BPF socket filter program that performs an OR operation on 32-bit registers with specific bounds to trigger the verifier bug."
    ],
    [
      2,
      "Execute the crafted BPF program to exploit the incorrect bounds tracking, leading to out-of-bounds kernel memory access."
    ]
  ],
  "vuln_description": "The vulnerability is a bug in the eBPF verifier's scalar32_min_max_or() function, which incorrectly uses 64-bit registers instead of 32-bit ones for bounds tracking. This flaw allows an attacker to craft BPF programs that can read and write out of bounds, potentially leading to arbitrary kernel memory access and local privilege escalation.",
  "reason": "The vulnerability requires deep understanding of eBPF verifier internals, register tracking mechanisms, and subtle interactions between 32-bit and 64-bit register operations. The attacker must carefully craft BPF instructions to trigger the incorrect bounds tracking while maintaining program validity.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": true,
  "is_ctf": false,
  "other_report": null,
  "idor_detectable": false,
  "authnz_byppass_detectable": false,
  "is_simple_payload": true,
  "injection_metadata": {
    "is_simple_payload": true
  },
  "authnz_metadata": {
    "idor_detectable": false,
    "authnz_byppass_detectable": false
  }
}