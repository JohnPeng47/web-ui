{
  "reported_to": "shopify-scripts",
  "reported_by": "dkasak ",
  "title": "Segfault and/or potential unwanted (byte)code execution with \"break\" and \"||=\" inside a loop",
  "content": "\nIntroduction\nCertain invalid inputs (invalid Ruby programs) crash mruby and mruby_engine (including the parent MRI VM). The programs always involve the ||= operator, loops and the break keyword.\nProof of Concept\ncrash.rb\nA ||= break while break\nSave the above code as crash.rb\nRun either: a) mruby crash.rb b) sandbox crash.rb\nBoth cause a segmentation fault.\nDiscussion\nEverything below assumes the latest master of the mruby repository as of Nov 18th, which is commit 0ff3ae1fbaed62010c54c43235e29cdc85da2f78.\nThe above crashing example isn't the only one that we've managed to produce but is the minimal one so far. An infinite family of programs is able to exploit this bug to crash the interpreter, execute spurious bytecode that wasn't generated for the current program or even set the machine instruction pointer to some junk value (making this a limited form of unwated code execution, even though the executed code isn't arbitrary).\nThe generated AST and bytecode for the crashing case is as follows:\nmruby 1.2.0 (2015-11-17)\n00001 NODE_SCOPE:\n00001 NODE_BEGIN:\n00001 NODE_WHILE:\n00001 cond:\n00001 NODE_BREAK:\n00001 body:\n00001 NODE_OP_ASGN:\n00001 lhs:\n00001 NODE_CONST A\n00001 op='||' (666)\n00001 NODE_BREAK:\nirep 0x16b2970 nregs=2 nlocals=1 pools=0 syms=1 reps=0\nfile: crash.rb\n1 000 OP_JMP 010\n1 001 OP_ONERR 005\n1 002 OP_GETCONST R1 :A\n1 003 OP_POPERR 1\n1 004 OP_JMP 007\n1 005 OP_RESCUE R1\n1 006 OP_LOADF R1\n1 007 OP_JMPIF R1 010\n1 008 OP_JMP 008\n1 009 OP_SETCONST :A R1\n1 010 OP_JMP 018\n1 011 OP_JMPIF R1 001\n1 012 OP_LOADNIL R1\n1 013 OP_STOP\nThe odd thing to notice here is that the OP_JMP at 010 jumps beyond the last instruction. This is what leads to a potential execution of spurious bytecode since there may be valid opcodes beyond the end of the iseq array of the current irep (and indeed, we've seen this happen).\nFurthermore, the index of the instruction onto which the invalid OP_JMP jumps to is equal I + A where I is the index of the instruction the OP_JMP at 000 jumps to (in this case 010) and A is the index of an OP_JMP instruction located prior to the invalid one (so in this case 010 + 008 = 018). Since each additional break inserted into the code inserts an additional OP_JMP instruction, this implies that the argument of the invalid OP_JMP can be increased almost without bounds (limited only by memory consumption and/or the maximum argument to OP_JMP instructions, which is 0xffff >> 1 = 32767).\nAs an example, the code:\nlarger.rb\nA ||= break break break break while break\nYields the following bytecode:\nfile: larger.rb\n1 000 OP_JMP 013\n1 001 OP_ONERR 005\n1 002 OP_GETCONST R1 :A\n1 003 OP_POPERR 1\n1 004 OP_JMP 007\n1 005 OP_RESCUE R1\n1 006 OP_LOADF R1\n1 007 OP_JMPIF R1 013\n1 008 OP_JMP 008\n1 009 OP_JMP 017\n1 010 OP_JMP 019\n1 011 OP_JMP 021\n1 012 OP_SETCONST :A R1\n1 013 OP_JMP 024\n1 014 OP_JMPIF R1 001\n1 015 OP_LOADNIL R1\n1 016 OP_STOP\nAfter the jump is made, the memory location might contain a valid mruby instruction or even something with an opcode larger than the number of opcodes contained in the optable in vm.c. Since the code in mrb_vm_exec jumps to addresses contained in the optable, indexed by the opcode number, this leads to a limited form of unwanted code execution, since memory locations after the optable may contain pointers to executable code by accident.\nIt is interesting to note that a very similar program doesn't cause a crash:\nnon-crash.rb\na ||= break while break\nThe only difference from the crashing case is the use of a lowercase variable name instead of an uppercase (so a non-constant, in Ruby terms).\nAnother non-crashing case is the following:\nnon-crash-other.rb\nA &&= break while break\nThe only difference here is the use of another assignment operator \u2014 &&, instead of ||.\nThis gives us a hint as to where the problem is. The invalid jump length is ultimately set during code generation for the NODE_WHILE node of the AST in codegen.c, line 1426. Specifically, the jump lengths are adjusted after the loop is generated, on line 1438 of the same file, during the call of the function loop_pop().\nWhen this function is executed in the debugger when run on the crash.rb case, it may be noticed that the s->loop variable, which contains the loop context, contains two loops inside one another instead of only one: a LOOP_NORMAL (which is generated by the while) and a LOOP_RESCUE. The latter is generated during code generation for NODE_OP_ASGN, starting at line 1724 of codegen.c. Here we encounter this interesting special case:\nif ((len == 2 && name[0] == '|' && name[1] == '|') &&\n((intptr_t)tree->car->car == NODE_CONST ||\n(intptr_t)tree->car->car == NODE_CVAR)) {\nThis explains why the problem only happens only when using the ||= operator on Ruby constants. It is here that an additional LOOP_RESCUE loop context is created, and it is using this context that is used later on by loop_pop/dispatch_linked to generate the final arguments to the jump instructions.\nSince this \"loop\" is generated simply to catch potential NameError exceptions generated when an unexisting constant is reference, it seems that this loop context shouldn't escape the generation of the code for the assignment operator.\nSolution\nTherefore, the solution we chose was to pop this loop context after the assignment code is generated. This makes the loop_pop/dispatch_linked function calls inside the while code generation operate on the loop context for the while loop instead and fixes the generated jump.\nundef-constant-or-assign.patch\ndiff --git a/mrbgems/mruby-compiler/core/codegen.c b/mrbgems/mruby-compiler/core/codegen.c\nindex 9b064b8..bbe0f51 100644\n--- a/mrbgems/mruby-compiler/core/codegen.c\n+++ b/mrbgems/mruby-compiler/core/codegen.c\n@@ -1746,6 +1746,7 @@ codegen(codegen_scope s, node tree, int val)\ngenop(s, MKOP_A(OP_RESCUE, exc));\ngenop(s, MKOP_A(OP_LOADF, exc));\ndispatch(s, noexc);\nloop_pop(s, val); } else if ((intptr_t)tree->car->car == NODE_CALL) { node *n = tree->car->cdr;\nWith the above patch, we were unable to crash the VM through this bug nor generated any more jumps with invalid jump lengths. Furthermore, all tests pass successfully.\n\n",
  "severity": [
    8.6,
    null
  ],
  "bounty": 10000,
  "weaknesses": [
    "Uncontrolled Resource Consumption"
  ],
  "screenshots": {},
  "disclosed_date": 1481942520,
  "report_url": "https://hackerone.com/reports/183356",
  "is_multi_component": true,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Create a Ruby file named 'crash.rb' with the content: 'A ||= break while break'"
    ],
    [
      2,
      "Execute the file using mruby or mruby_engine: 'mruby crash.rb'"
    ]
  ],
  "vuln_description": "The vulnerability involves a segmentation fault and potential unwanted bytecode execution in mruby when using the '||=' operator, loops, and the 'break' keyword in a specific combination. This leads to invalid jump instructions in the generated bytecode, potentially executing spurious bytecode or crashing the interpreter.",
  "reason": "The vulnerability requires understanding of Ruby's constant assignment operator (||=), loop constructs, and the break keyword's interaction with bytecode generation. The specific combination of these elements in a way that creates invalid jump targets is non-obvious and requires deep knowledge of mruby's internals.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}