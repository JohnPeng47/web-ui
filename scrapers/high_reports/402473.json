{
  "reported_to": "Automattic",
  "reported_by": "simonscannell ",
  "title": "Arbitrary File Download as Shopmanager",
  "content": "\nDue to a flaw in the way WooCommerce handles downloadable products, a shop manager can download arbitrary files on the server.\nThe video shows the exploit and how simple it is:\nhttps://www.youtube.com/watch?v=bkrHpqht5SM\nThe function responsible for validating the download file input is the following:\n(/woocommerce/includes/abstracts/abstract-wc-product.php)\nCode 1.70 KiB\n1\tpublic function set_downloads( $downloads_array ) {\n2\t\t$downloads = array();\n3\t\t$errors    = array();\n4\n5\t\tforeach ( $downloads_array as $download ) {\n6\t\t\tif ( is_a( $download, 'WC_Product_Download' ) ) {\n7\t\t\t\t$download_object = $download;\n8\t\t\t} else {\n9\t\t\t\t$download_object = new WC_Product_Download();\n10\n11\t\t\t\t// If we don't have a previous hash, generate UUID for download.\n12\t\t\t\tif ( empty( $download['download_id'] ) ) {\n13\t\t\t\t\t$download['download_id'] = wp_generate_uuid4();\n14\t\t\t\t}\n15\n16\t\t\t\t$download_object->set_id( $download['download_id'] );\n17\t\t\t\t$download_object->set_name( $download['name'] );\n18\t\t\t\t$download_object->set_file( $download['file'] );\n19\t\t\t}\n20\n21\t\t\t// Validate the file extension.\n22\t\t\tif ( ! $download_object->is_allowed_filetype() ) {\n23\t\t\t\tif ( $this->get_object_read() ) {\n24\t\t\t\t\t/* translators: %1$s: Downloadable file */\n25\t\t\t\t\t$errors[] = sprintf( __( 'The downloadable file %1$s cannot be used as it does not have an allowed file type. Allowed types include: %2$s', 'woocommerce' ), '<code>' . basename( $download_object->get_file() ) . '</code>', '<code>' . implode( ', ', array_keys( $download_object->get_allowed_mime_types() ) ) . '</code>' );\n26\t\t\t\t}\n27\t\t\t\tcontinue;\n28\t\t\t}\n29\n30\t\t\t// Validate the file exists.\n31\t\t\tif ( ! $download_object->file_exists() ) {\n32\t\t\t\tif ( $this->get_object_read() ) {\n33\t\t\t\t\t/* translators: %s: Downloadable file */\n34\t\t\t\t\t$errors[] = sprintf( __( 'The downloadable file %s cannot be used as it does not exist on the server.', 'woocommerce' ), '<code>' . $download_object->get_file() . '</code>' );\n35\t\t\t\t}\n36\t\t\t\tcontinue;\n37\t\t\t}\n38\n39\t\t\t$downloads[ $download_object->get_id() ] = $download_object;\n40\t\t}\n41\n42\t\tif ( $errors ) {\n43\t\t\t$this->error( 'product_invalid_download', $errors[0] );\n44\t\t}\n45\n46\t\t$this->set_prop( 'downloads', $downloads );\n47\t}\nWhen I took a look at the function I naturally wanted to see if there was a way to bypass is_allowed_filetype().\nThe function does the following:\nCode 237 Bytes\n1\tpublic function is_allowed_filetype() {\n2\t\tif ( 'relative' !== $this->get_type_of_file_path() ) {\n3\t\t\treturn true;\n4\t\t}\n5\t\treturn ! $this->get_file_extension() || in_array( $this->get_file_type(), $this->get_allowed_mime_types(), true );\n6\t}\nIt will see what type of file path it is (it could be a URL, it could be an absolute path etc.) and interestingly enough it will only validate the file extension if it is a relative path. So of course I wanted to see what would happen if we would enter an absolute path, since then I could bypass the extension check entirely.\nCode 374 Bytes\n1\tpublic function get_type_of_file_path( $file_path = '' ) {\n2\t\t$file_path = $file_path ? $file_path : $this->get_file();\n3\t\tif ( 0 === strpos( $file_path, 'http' ) || 0 === strpos( $file_path, '//' ) ) {\n4\t\t\treturn 'absolute';\n5\t\t} elseif ( '[' === substr( $file_path, 0, 1 ) && ']' === substr( $file_path, -1 ) ) {\n6\t\t\treturn 'shortcode';\n7\t\t} else {\n8\t\t\treturn 'relative';\n9\t\t}\n10\t}\nAnd I was right. Funny enough, input is only an absolute path if it starts with two slashes. So all I did was to set the download file to //home/simon/html/wordpress/wp-config.php and then just downloaded it.\nAs a patch recommendation: Also check the file types if it is an absolute path.\nBest regards,\nSimon\nImpact\nWhen an attacker can download the wp-config.php file, a privilege escalation is easily possible. He could either log into the database if the DB host is not localhost or if the WordPress installation is used with a shared hosting provider, he can simply get some hosting space on the same server and then access the database, which leads to a complete compromise of the installation.\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": null,
  "weaknesses": [
    "Path Traversal"
  ],
  "screenshots": {},
  "disclosed_date": 1576783380,
  "report_url": "https://hackerone.com/reports/402473",
  "is_multi_component": false,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "Log in as a shop manager in WooCommerce."
    ],
    [
      2,
      "Create or edit a downloadable product and set the file path to an absolute path starting with '//' (e.g., //home/simon/html/wordpress/wp-config.php)."
    ]
  ],
  "vuln_description": "Due to a flaw in WooCommerce's handling of downloadable products, a shop manager can download arbitrary files on the server by bypassing the file extension validation. This is possible because the validation only occurs for relative paths, not absolute paths starting with '//'.",
  "reason": "The vulnerability involves understanding the file path validation logic in WooCommerce and recognizing that absolute paths bypass the extension check. The interaction between the path type detection and the validation logic is subtle but not overly complex.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}