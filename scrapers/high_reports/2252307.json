{
  "reported_to": "curl",
  "reported_by": "cyberguardianrd ",
  "title": "Buffer overflow and affected url:-https://github.com/curl/curl/blob/master/docs/examples/hsts-preload.c",
  "content": "\nSummary:\nA buffer overflow, also known as a buffer overrun, occurs when a program or process attempts to write more data to a buffer than the buffer is allocated to hold. This can happen if the program does not properly check the length of the data before writing it to the buffer, or if the program allocates too little space for the buffer.\nSteps To Reproduce:\n[add details for how we can reproduce the issue]\nThe hstsread function in the provided code does not properly check the length of the host string before copying it into the e->name buffer. This could lead to a buffer overflow, allowing an attacker to inject arbitrary code into the application.this could exploited by a malicious domain or website whose url should be long enough to overflow buffer as it's using strcpy function Condition a malicious preload host is required to exploit this if it's meet government can use it for zero click attack\nRecommendation:\nThe hstsread function should be modified to check the length of the host string before copying it into the e->name buffer. If the string is too long, the function should return an error code\nSupporting Material/References:\n[list any additional material (e.g. screenshots, logs, etc.)]\n[attachment / reference]\nAffected url:-https://github.com/curl/curl/blob/master/docs/examples/hsts-preload.c\nHere is the vulnerable code if attacker or government manipulate developer to add a very long domain name in hsts_preload then this will result remote code execution\ninclude <stdio.h>\ninclude <string.h>\ninclude <curl/curl.h>\nstruct entry {\nconst char name;\nconst char exp;\n};\nstatic const struct entry preload_hosts[] = {\n{ \"example.com\", \"20370320 01:02:03\" },\n{ \"curl.se\", \"20370320 03:02:01\" },\n{ NULL, NULL } / end of list marker /\n};\nstruct state {\nint index;\n};\n/ \"read\" is from the point of the library, it wants data from us. One domain\nentry per invoke. /\nstatic CURLSTScode hstsread(CURL easy, struct curl_hstsentry e,\nvoid userp)\n{\nconst char host;\nconst char expire;\nstruct state s = (struct state *)userp;\n(void)easy;\nhost = preload_hosts[s->index].name;\nexpire = preload_hosts[s->index++].exp;\nif(host && (strlen(host) < e->namelen)) {\nstrcpy(e->name, host);\ne->includeSubDomains = 0;\nstrcpy(e->expire, expire);\nfprintf(stderr, \"HSTS preload '%s' until '%s'\\n\", host, expire);\n}\nelse\nreturn CURLSTS_DONE;\nreturn CURLSTS_OK;\n}\nstatic CURLSTScode hstswrite(CURL easy, struct curl_hstsentry e,\nstruct curl_index i, void userp)\n{\n(void)easy;\n(void)userp; / we have no custom input /\nprintf(\"[%u/%u] %s %s\\n\", (unsigned int)i->index, (unsigned int)i->total,\ne->name, e->expire);\nreturn CURLSTS_OK;\n}\nint main(void)\n{\nCURL *curl;\nCURLcode res;\ncurl = curl_easy_init();\nif(curl) {\nstruct state st = {0};\n/ enable HSTS for this handle /\ncurl_easy_setopt(curl, CURLOPT_HSTS_CTRL, (long)CURLHSTS_ENABLE);\n/ function to call at first to populate the cache before the transfer /\ncurl_easy_setopt(curl, CURLOPT_HSTSREADFUNCTION, hstsread);\ncurl_easy_setopt(curl, CURLOPT_HSTSREADDATA, &st);\n/ function to call after transfer to store the new state of the HSTS\ncache /\ncurl_easy_setopt(curl, CURLOPT_HSTSWRITEFUNCTION, hstswrite);\ncurl_easy_setopt(curl, CURLOPT_HSTSWRITEDATA, NULL);\n/ use the domain with HTTP but due to the preload, it should do the\ntransfer using HTTPS /\ncurl_easy_setopt(curl, CURLOPT_URL, \"http://curl.se\");\ncurl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);\n/ Perform the request, res will get the return code /\nres = curl_easy_perform(curl);\n/ Check for errors /\nif(res != CURLE_OK)\nfprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\ncurl_easy_strerror(res));\n/ always cleanup /\ncurl_easy_cleanup(curl);\n}\nreturn 0;\n}\nImpact\nAn attacker could exploit this vulnerability to inject arbitrary code into the application. This could allow the attacker to take control of the application and perform actions on behalf of the user.\n\n",
  "severity": [
    9.0,
    10.0
  ],
  "bounty": null,
  "weaknesses": [
    "Classic Buffer Overflow"
  ],
  "screenshots": {},
  "disclosed_date": 1700061000,
  "report_url": "https://hackerone.com/reports/2252307",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Identify or create a malicious domain name that is long enough to overflow the buffer in the hstsread function."
    ],
    [
      2,
      "Manipulate the developer or system to add this malicious domain name to the preload_hosts array in the hsts-preload.c file."
    ]
  ],
  "vuln_description": "A buffer overflow vulnerability exists in the hstsread function of the provided code, where the function does not properly check the length of the host string before copying it into the e->name buffer. This can be exploited by a malicious domain or website with a URL long enough to overflow the buffer, potentially leading to remote code execution.",
  "reason": "The vulnerability involves a straightforward buffer overflow due to improper bounds checking when copying a string. The attack requires manipulating the input (domain name) to exceed the buffer size, which is a common and well-understood vulnerability pattern. There are no complex interactions or states involved beyond the basic buffer overflow scenario.",
  "new_complexity": "LOW",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}