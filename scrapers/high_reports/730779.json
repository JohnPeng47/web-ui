{
  "reported_to": "Node.js",
  "reported_by": "alyssawilk ",
  "title": "HTTP header values do not have trailing OWS trimmed",
  "content": "\n[I suspect I may have tagged the wrong vulnerability type -I'm failing to find \"insufficient validation of user input\"]\nAccording to the HTTP-spec, http values are\nfield-value = *( field-content | LWS )\nhttp_parser does not appear to trim trailing LWS. This means if a user sends \"Host: foo\\r\\n\" the string literal \"foo\" is passed up, but if the user sends \"Host: foo \\r\\n\" the string literal \"foo \" is passed up, complete with trailing LWS.\nSteps To Reproduce:\n(Add details for how we can reproduce the issue)\nIf one hands \"GET / HTTP/1.1\\r\\nHost: foo.com \\r\\nHello: World\\r\\n\\r\\n\"\nto http_parser, http_parser sends on_header_value \"foo.com \" instead of \"foo.com\"\nImpact: [add why this issue matters]\nWe are trying to address an issue with Envoy, where if\n\"GET / HTTP/1.1\\r\\nHost: my-super-private-domain.com \\r\\nHello: World\\r\\n\\r\\n\"\nis passed to Envoy, and Envoy is configured to block any requests to \"my-super-private-domain.com\", the matcher fails due the trailing whitespace, and external users can tunnel requests that should be blocked.\nOriginally we were going to address this by doing whitespace trimming in Envoy, but this should probably be fixed upstream in http_parser in case other users are affected, so we're reaching out to see what folks on your end think.\nSupporting Material/References:\nMy Envoy regression test verifies this lack of LWS trimming, but this is current under envoy security embargo, so please don't share\nTEST_F(Http1ServerConnectionImplTest, LWS) {\n\ninitialize();\nInSequence sequence;\nHttp::MockStreamDecoder decoder;\n\nEXPECTCALL(callbacks, newStream(, )).WillOnce(ReturnRef(decoder));\nTestHeaderMapImpl expectedheaders{\n\n{\"Test\", \"value \"}, // note the LWS after value is passed up from http_parser to Envoy :-(\n\n{\"Hello\", \"World\"},\n\n{\":path\", \"/\"},\n\n{\":method\", \"GET\"},\n\n};\n\nEXPECT_CALL(decoder, decodeHeaders(HeaderMapEqual(&expected_headers), true)).Times(1);\nBuffer::OwnedImpl buffer(\"GET / HTTP/1.1\\r\\nTest: value \\r\\nHello: World\\r\\n\\r\\n\");\n\ncodec_->dispatch(buffer);\n\nEXPECT_EQ(0U, buffer.length());\n\n}\nImpact\nAs said above, this could allow privileged escalation, where if one uses an http_parser enabled server configured to block specific domains, those blocks can be trivially bypassed using white-space. It's possible there are other attacks bypassing http_parser header value checks with whitespace, but I haven't investigated beyond the most obvious exploit\n\n",
  "severity": [
    7.4,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Improper Input Validation"
  ],
  "screenshots": {},
  "disclosed_date": 1582584480,
  "report_url": "https://hackerone.com/reports/730779",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Send an HTTP request with a header containing trailing whitespace, e.g., 'Host: my-super-private-domain.com \\r\\n'"
    ],
    [
      2,
      "Observe that the server processes the header value with the trailing whitespace instead of trimming it, potentially bypassing security checks"
    ]
  ],
  "vuln_description": "The vulnerability involves HTTP header values not being trimmed of trailing optional whitespace (OWS) as specified in the HTTP protocol. This can lead to security bypasses, such as circumventing domain blocking mechanisms, by simply adding whitespace to the header value.",
  "reason": "The attack is straightforward, involving only the manipulation of HTTP headers with trailing whitespace. It does not require complex interactions between components or manipulation of application states. The issue is a direct result of insufficient input validation, a common vulnerability pattern.",
  "new_complexity": "LOW",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}