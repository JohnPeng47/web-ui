{
  "reported_to": "Node.js",
  "reported_by": "bart ",
  "title": "\"Assertion failed\" in node::http2::Http2Session::~Http2Session() leads to HTTP/2 server crash",
  "content": "\nSummary:\nI discovered a vulnerability in Node.js HTTP/2 stack (http2) package. An attacker can send a very small amount of TCP packets with a few HTTP/2 frames inside. After a few seconds a Node.js (latest: 21.5.0 and latest LTS: v20.11.0) server crash with the following stack:\nCode 1.48 KiB\n1  #  node[3253]: virtual node::http2::Http2Session::~Http2Session() at ../src/node_http2.cc:534\n2  #  Assertion failed: (current_nghttp2_memory_) == (0)\n3\n4----- Native stack trace -----\n5\n6 1: 0xca5430 node::Abort() [node]\n7 2: 0xca54b0 node::errors::SetPrepareStackTraceCallback(v8::FunctionCallbackInfo<v8::Value> const&) [node]\n8 3: 0xce7156 node::http2::Http2Session::~Http2Session() [node]\n9 4: 0xce7192 node::http2::Http2Session::~Http2Session() [node]\n10 5: 0x106f01d v8::internal::GlobalHandles::InvokeFirstPassWeakCallbacks() [node]\n11 6: 0x10f3215 v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::internal::GarbageCollectionReason, char const*) [node]\n12 7: 0x10f3d7c v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [node]\n13 8: 0x10ca081 v8::internal::HeapAllocator::AllocateRawWithLightRetrySlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [node]\n14 9: 0x10cb215 v8::internal::HeapAllocator::AllocateRawWithRetryOrFailSlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [node]\n1510: 0x10a8866 v8::internal::Factory::NewFillerObject(int, v8::internal::AllocationAlignment, v8::internal::AllocationType, v8::internal::AllocationOrigin) [node]\n1611: 0x15035f6 v8::internal::Runtime_AllocateInYoungGeneration(int, unsigned long*, v8::internal::Isolate*) [node]\n1712: 0x7f41df699ef6 \n18Aborted (core dumped)\nThe attack is easy to perform so a permanent Denial of Service is possible. It is also hard to debug from server admins (check Impact section).\nDescription:\nThe http2 package has an assertion in the Http2Session destructor which check if current memory usage of nghttp2 library (current_nghttp2_memory_) has been reset to 0.\nCode 252 Bytes\n1Http2Session::~Http2Session() {\n2  CHECK(!is_in_scope());\n3  Debug(this, \"freeing nghttp2 session\");\n4  // Explicitly reset session_ so the subsequent\n5  // current_nghttp2_memory_ check passes.\n6  session_.reset();\n7  CHECK_EQ(current_nghttp2_memory_, 0);\n8}\nHowever it is possible to leave some data in nghttp2 memory (or counter is improperly implemented) after reset when headers with HTTP/2 CONTINUATION frame are sent to the server and then a TCP connection is abruptly closed by the client triggering the Http2Session destructor while header frames are still being processed (and stored in memory).\nSteps To Reproduce:\nStart a http2 server.\nSend a HTTP/2 request:\nSend necessary init frames.\nSend HEADERS frame for a simple GET / request (with no END_HEADERS flag).\nSend CONTINUATION frame with a single header (also with no END_HEADERS flag).\nSend necessary init frames.\nSend HEADERS frame for a simple GET / request (with no END_HEADERS flag).\nSend CONTINUATION frame with a single header (also with no END_HEADERS flag).\nDisconnect TCP connection.\nI'm attaching an exploit in Golang that demonstrates the issue. It starts a loop and in each iteration it opens a TCP connection to the server. It sends necessary headers and then just leaves the connection open. After 10 seconds, another go routine simply exists the application which kills all opened TCP connections which triggers the bug. To run it simply run: go run ./exploit2.go -address [server]. For simplicity it works only for h2c (HTTP/2 without TLS) server but with extra code it should work against any Node.js server (with TLS).\nI was testing it against the simple Node.js server:\nCode 537 Bytes\n1const http2 = require('http2');\n2const fs = require('fs');\n3\n4const server = http2.createServer();\n5\n6server.on('error', (err) => console.error(err));\n7\n8server.on('stream', (stream, headers) => {\n9    // Respond to the request with a simple hello world message\n10    stream.respond({\n11        'content-type': 'text/plain; charset=utf-8',\n12        ':status': 200\n13    });\n14    stream.end('Hello World with HTTP/2!');\n15    console.log(\"Request handled\")\n16});\n17\n18server.listen(7777, () => {\n19    console.log('Server is running on http://localhost:7777');\n20});\nImpact\nAn attacker can make the Node.js HTTP/2 server completely unavailable. Because of the fact that send HTTP/2 frames never establish a full HTTP request, the server admins may have problems with debugging the issue or rate-limiting the attacker (requests not visible in the logs). The payload sent to exploit the issue is also very small.\nAdditionally, an attack can cause some problems with data integrity because GOAWAY frames will not be sent but they contain (often important): Last-Stream-ID parameter, from specification:\nThe last stream identifier in the GOAWAY frame contains the highest-numbered stream identifier for which the sender of the GOAWAY frame might have taken some action on or might yet take action on. All streams up to and including the identified stream might have been processed in some way.\nThis means that clients may submit duplicate request for request that have been already processed by a server.\n\n",
  "severity": [
    8.2,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Uncontrolled Resource Consumption"
  ],
  "screenshots": {},
  "disclosed_date": 1712629500,
  "report_url": "https://hackerone.com/reports/2319584",
  "is_multi_component": false,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Start a Node.js HTTP/2 server using the provided code snippet."
    ],
    [
      2,
      "Send a crafted HTTP/2 request with HEADERS and CONTINUATION frames (without END_HEADERS flag), then abruptly disconnect the TCP connection."
    ]
  ],
  "vuln_description": "The vulnerability is a denial-of-service issue in Node.js's HTTP/2 implementation where an assertion fails during the destruction of an Http2Session when the nghttp2 memory counter isn't properly reset. This occurs when processing incomplete header frames followed by an abrupt connection termination, causing the server to crash.",
  "reason": "While the vulnerability involves understanding HTTP/2 protocol details (frames, flags) and TCP connection handling, the attack sequence is relatively straightforward once these components are understood. The main complexity comes from knowing to leave headers incomplete and abruptly terminating the connection, but this follows predictable protocol behavior.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}