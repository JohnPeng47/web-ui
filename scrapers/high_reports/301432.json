{
    "reported_to": "GitLab",
    "reported_by": "jobert ",
    "title": "GitLab CI runner can read and poison cache of all other projects",
    "content": "\nThe GitLab CI runner allows users to cache files and directories in between runs. These files are stored in a ZIP file and uploaded to a shared cache instance. In my testing, the files were uploaded to runners-cache-4-internal.gitlab.com and runners-cache-3-internal.gitlab.com, even for dedicated runners. It seems odd that dedicated runners use the same shared cache, but perhaps that was an intentional design decision. It could also be a vulnerability. I tried reaching the cache servers from a Docker instance itself, but wasn't able to (I tried from a reverse shell spawned from a Docker instance). There are multiple vulnerabilities (same root cause though) that can be chained to successfully poison the CI runner cache of another project.\nReading the cache of other projects\nCreate a new project with a .gitlab-ci.yml file in it. The file should contain the following contents. By default, when a cache file is downloaded, it'll download the cache from http://runners-cache-4-internal.gitlab.com:444/runner/project/5024150/cache.\n.gitlab-ci.yml\nCode 93 Bytes\n1a:\n2  script:\n3  - ls -lashR\n4  cache:\n5    key: ../1/cache\n6    policy: pull\n7    paths:\n8      - .\nTo read the cache, the attacker needs to know two things: a project ID (auto incremental) and a cache key. By default, the project ID will be prepended to download the cache. But because it's an HTTP request and there's no additional checks on the key input, a path traversal vulnerability can be exploited to move up a directory and select the cache from a different project. In this case, when it downloads the cache, it'll request http://runners-cache-4-internal.gitlab.com:444/runner/gitlab/project/1/cache instead of the project ID of the build.\nBuild output\nCode 1.16 KiB\n1\u001b[0KRunning with gitlab-runner 10.3.0 (5cf5e19a)\n2  on docker-auto-scale (e11ae361)\n3\u001b[0;m\u001b[0KUsing Docker executor with image ruby:2.1 ...\n4\u001b[0;m\u001b[0KUsing docker image sha256:4eadb9b5cb46f487a71d05717762679404f7f6fdec1ba4fa96304de1db07dfef for predefined container...\n5\u001b[0;m\u001b[0KPulling docker image ruby:2.1 ...\n6\u001b[0;m\u001b[0KUsing docker image ruby:2.1 ID=sha256:223d1eaa9523fa64e78f5a92b701c9c11cbc507f0ff62246dbbacdae395ffea3 for build container...\n7\u001b[0;msection_start:1514659811:prepare_script\n8\u001b[0KRunning on runner-e11ae361-project-4989754-concurrent-0 via runner-e11ae361-srm-1514658950-a15d8859...\n9section_end:1514659812:prepare_script\n10\u001b[0Ksection_start:1514659813:get_sources\n11\u001b[0K\u001b[32;1mCloning repository...\u001b[0;m\n12Cloning into '/builds/jobertabma/build-test'...\n13\u001b[32;1mChecking out e01918e5 as master...\u001b[0;m\n14\u001b[32;1mSkipping Git submodules setup\u001b[0;m\n15section_end:1514659814:get_sources\n16\u001b[0Ksection_start:1514659814:restore_cache\n17\u001b[0K\u001b[32;1mChecking cache for ../13083/ruby-235-with-yarn...\u001b[0;m\n18Downloading cache.zip from http://runners-cache-5-internal.gitlab.com:444/runner/project/13083/ruby-235-with-yarn\u001b[0;m \n19\u001b[32;1mSuccessfully extracted cache\u001b[0;m\n20section_end:1514659844:restore_cache\nThe cache key seems to be guessable pretty easily or even unused when no key is specified, since most will correlate with the step they're executed in. When I started looking at this, I had to specify which paths to download from the cache. This made exploitation more difficult. However, it (conveniently) allowed me to use . as path, extracting all files from the cache into the working directory. Running ls -lashR after that reveals the cache contents in the build output. Files can be read using cat or to store them as build artifacts through the .gitlab-ci.yml.\nWriting the cache of other projects\nNow that the attacker knows what files are stored in the cache, it can poison the cache with its own file contents. Create another CI YAML file with the following contents:\n.gitlab-ci.yml\nCode 120 Bytes\n1a:\n2  script:\n3  - echo 1 > file-to-poison\n4  cache:\n5    key: ../1/cache\n6    policy: push\n7    paths:\n8      - file-to-poison\nThe attacker has to run a build, which will overwrite the file-to-poison file in the cache for project ID 1. Now, when the targeted project starts another CI run, the poisoned cache files will be downloaded and used in the CI run. For example, an attacker could poison 13083/ruby-235-with-yarn, which would overwrite the Ruby 2.3.5 executable that is being used for GitLab CE CI runs. As you can imagine, someone could enumerate over other projects that use cached executables and overwrite them with their own code.\nThis has been tested against the latest version of GitLab.\nImpact\nDepending on the files that are cached, this may allow an attacker to run arbitrary code on a victim's Docker instance running a CI run. This may expose confidential data, inject artifacts in a build pipeline to ship additional code, among other things.\n\n",
    "severity": [
        9.0,
        null
    ],
    "bounty": 2000,
    "weaknesses": [
        "Path Traversal"
    ],
    "screenshots": {},
    "disclosed_date": 1524810060,
    "report_url": "https://hackerone.com/reports/301432",
    "is_multi_component": true,
    "complexity": "HIGH",
    "novelty": "MEDIUM",
    "vuln_category": "API",
    "steps": [
        [
            1,
            "Create a new project with a .gitlab-ci.yml file containing a cache key with path traversal (e.g., '../1/cache') and set policy to 'pull'."
        ],
        [
            2,
            "Run the CI job to download and extract the cache from another project's directory, revealing its contents in the build output."
        ],
        [
            3,
            "Create another .gitlab-ci.yml file with a similar path traversal cache key but set policy to 'push', and include a malicious file to overwrite the target project's cache."
        ],
        [
            4,
            "Run the CI job to push the poisoned cache, which will be used in the target project's subsequent CI runs."
        ]
    ],
    "vuln_description": "The GitLab CI runner cache system is vulnerable to path traversal, allowing an attacker to read and poison the cache of any other project. By manipulating the cache key with '../', an attacker can access or overwrite cached files from unrelated projects, potentially leading to arbitrary code execution or data leakage.",
    "reason": "The vulnerability involves understanding the cache mechanism, identifying the path traversal opportunity in the cache key, and chaining read/write operations to exploit it. While the path traversal is straightforward, the need to chain multiple steps (discovery, read, write) and understand the cache infrastructure adds complexity.",
    "new_complexity": "MEDIUM",
    "requires_code": false,
    "requires_CVE": false,
    "is_ctf": false,
    "other_report": null
}