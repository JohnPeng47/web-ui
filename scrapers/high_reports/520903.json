{
  "reported_to": "Internet Bug Bounty",
  "reported_by": "real ",
  "title": "Apache HTTP [2.4.17-2.4.38] Local Root Privilege Escalation",
  "content": "\nHello,\nI reported a Local Root privilege escalation vulnerability on Apache HTTPd at the beginning of the year. Apache has now patched it, as you can see here.\nThe vulnerability affects mod_prefork, mod_event, and mod_worker, the most used mods on Linux.\nBasically, this is an arbitrary function call as root triggered whenever the server gracefully restarts, which is generally once a day.\nHere is the article I plan to publish soon, as MarkDown (careful, wall of text):\nIntroduction\nFrom version 2.4.17 (Oct 9, 2015) to version 2.4.38 (Apr 1, 2019), Apache HTTP suffers from a local root privilege escalation vulnerability due to an out-of-bounds array access leading to an arbitrary function call.\nThe vulnerability is triggered when Apache gracefully restarts (apache2ctl graceful).\nIn standard Linux configurations, the logrotate utility runs this command once a day, at 6:25AM, in order to reset log file handles.\nThe vulnerability affects mod_prefork, mod_worker and mod_event. The following bug description, code walkthrough and exploit target mod_prefork.\nBug description\nIn MPM prefork, the main server process, running as root, manages a pool of single-threaded, low-privilege (www-data) worker processes, meant to handle HTTP requests.\nIn order to get feedback from its workers, Apache maintains a shared-memory area (SHM), scoreboard, which contains various informations such as the workers PIDs and the last request they handled.\nEach worker is meant to maintain a process_score structure associated with its PID, and has full read/write access to the SHM.\nap_scoreboard_image: pointers to the shared memory block\nCode 198 Bytes\n1(gdb) p *ap_scoreboard_image \n2$3 = {\n3  global = 0x7f4a9323e008, \n4  parent = 0x7f4a9323e020, \n5  servers = 0x55835eddea78\n6}\n7(gdb) p ap_scoreboard_image->servers[0]\n8$5 = (worker_score *) 0x7f4a93240820\nExample of shared memory associated with worker PID 19447\nCode 641 Bytes\n1(gdb) p ap_scoreboard_image->parent[0]\n2$6 = {\n3  pid = 19447, \n4  generation = 0, \n5  quiescing = 0 '\\000', \n6  not_accepting = 0 '\\000', \n7  connections = 0, \n8  write_completion = 0, \n9  lingering_close = 0, \n10  keep_alive = 0, \n11  suspended = 0, \n12  bucket = 0 <- index for all_buckets\n13}\n14(gdb) ptype *ap_scoreboard_image->parent\n15type = struct process_score {\n16    pid_t pid;\n17    ap_generation_t generation;\n18    char quiescing;\n19    char not_accepting;\n20    apr_uint32_t connections;\n21    apr_uint32_t write_completion;\n22    apr_uint32_t lingering_close;\n23    apr_uint32_t keep_alive;\n24    apr_uint32_t suspended;\n25    int bucket; <- index for all_buckets\n26}\nWhen Apache gracefully restarts, its main process kills old workers and replaces them by new ones.\nAt this point, every old worker's bucket value will be used by the main process to access an array of his, all_buckets.\nall_buckets\nCode 687 Bytes\n1(gdb) p $index = ap_scoreboard_image->parent[0]->bucket\n2(gdb) p all_buckets[$index]\n3$7 = {\n4  pod = 0x7f19db2c7408, \n5  listeners = 0x7f19db35e9d0, \n6  mutex = 0x7f19db2c7550\n7}\n8(gdb) ptype all_buckets[$index]\n9type = struct prefork_child_bucket {\n10    ap_pod_t *pod;\n11    ap_listen_rec *listeners;\n12    apr_proc_mutex_t *mutex; <--\n13}\n14(gdb) ptype apr_proc_mutex_t\n15apr_proc_mutex_t {\n16    apr_pool_t *pool;\n17    const apr_proc_mutex_unix_lock_methods_t *meth; <--\n18    int curr_locked;\n19    char *fname;\n20    ...\n21}\n22(gdb) ptype apr_proc_mutex_unix_lock_methods_t\n23apr_proc_mutex_unix_lock_methods_t {\n24    ...\n25    apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *); <--\n26    ...\n27}\nNo bound checks happen. Therefore, a rogue worker can change its bucket index and make it point to the shared memory, in order to control the prefork_child_bucket structure upon restart. Eventually, and before privileges are dropped, mutex->meth->child_init() is called.\nThis results in an arbitrary function call as root.\nVulnerable code\nWe'll go through server/mpm/prefork/prefork.c to find out where and how the bug happens.\nA rogue worker changes its bucket index in shared memory to make it point to a structure of his, also in SHM.\nAt 06:25AM the next day, logrotate requests a graceful restart from Apache.\nUpon this, the main Apache process will first kill workers, and then spawn new ones.\nThe killing is done by sending SIGUSR1 to workers. They are expected to exit ASAP.\nThen, prefork_run() (L853) is called to spawn new workers. Since retained->mpm->was_graceful is true (L861), workers are not restarted straight away.\nInstead, we enter the main loop (L933) and monitor dead workers' PIDs. When an old worker dies, ap_wait_or_timeout() returns its PID (L940).\nThe index of the process_score structure associated with this PID is stored in child_slot (L948).\nIf the death of this worker was not fatal (L969), make_child() is called with ap_get_scoreboard_process(child_slot)->bucket as a third argument (L985). As previously said, bucket's value has been changed by a rogue worker.\nmake_child() creates a new child, fork()ing (L671) the main process.\nThe OOB read happens (L691), and my_bucket is therefore under the control of an attacker.\nchild_main() is called (L722), and the function call happens a bit further (L433).\nSAFE_ACCEPT(<code>) will only execute <code> if Apache listens on two ports or more, which is often the case since a server listens over HTTP (80) and HTTPS (443).\nAssuming <code> is executed, apr_proc_mutex_child_init() is called, which results in a call to (*mutex)->meth->child_init(mutex, pool, fname) with mutex under control.\nPrivileges are dropped a bit later in the execution (L446).\nExploitation\nThe exploitation is a four step process:\nObtain R/W access on a worker process\nWrite a fake prefork_child_bucket structure in the SHM\nMake all_buckets[bucket] point to the structure\nAwait 6:25AM to get an arbitrary function call\nAdvantages:\nThe main process never exits, so we know where everything is mapped by reading /proc/self/maps (ASLR/PIE useless)\nWhen a worker dies (or segfaults), it is automatically restarted by the main process, so there is no risk of DOSing Apache\nProblems:\nPHP does not allow to read/write /proc/self/mem, which blocks us from simply editing the SHM\nall_buckets is reallocated after a graceful restart (!)\n## 1. Obtain R/W access on a worker process\nPHP UAF 0-day\nSince mod_prefork\u00a0is often used in combination with mod_php, it seems natural to exploit the vulnerability through PHP. CVE-2019-6977 would be a perfect candidate, but it was not out when I started writing the exploit. I went with a 0day UAF in PHP 7.x (which seems to work in PHP5.x as well):\nPHP UAF\nCode 361 Bytes\n1<?php\n2\n3class X extends DateInterval implements JsonSerializable\n4{\n5  public function jsonSerialize()\n6  {\n7    global $y, $p;\n8    unset($y[0]);\n9    $p = $this->y;\n10    return $this;\n11  }\n12}\n13\n14function get_aslr()\n15{\n16  global $p, $y;\n17  $p = 0;\n18\n19  $y = [new X('PT1S')];\n20  json_encode([1234 => &$y]);\n21  print(\"ADDRESS: 0x\" . dechex($p) . \"\\n\");\n22\n23  return $p;\n24}\n25\n26get_aslr();\nThis is an UAF on a PHP object: we unset $y[0] (an instance of X), but it is still usable using $this.\nUAF to Read/Write\nWe want to achieve two things:\nRead memory to find all_buckets' address\nEdit the SHM to change bucket index and add our custom mutex structure\nLuckily for us, PHP's heap is located before those two in memory.\nMemory addresses of PHP's heap, `ap_scoreboard_image->andall_buckets`*\nCode 345 Bytes\n1root@apaubuntu:~# cat /proc/6318/maps | grep libphp | grep rw-p\n27f4a8f9f3000-7f4a8fa0a000 rw-p 00471000 08:02 542265 /usr/lib/apache2/modules/libphp7.2.so\n3\n4(gdb) p *ap_scoreboard_image \n5$14 = {\n6  global = 0x7f4a9323e008, \n7  parent = 0x7f4a9323e020, \n8  servers = 0x55835eddea78\n9}\n10(gdb) p all_buckets \n11$15 = (prefork_child_bucket *) 0x7f4a9336b3f0\nSince we're triggering the UAF on a PHP object, any property of this object will be UAF'd too; we can convert this zend_object UAF into a zend_string one.\nThis is useful because of zend_string's structure:\nCode 131 Bytes\n1(gdb) ptype zend_string\n2type = struct _zend_string {\n3    zend_refcounted_h gc;\n4    zend_ulong h;\n5    size_t len;\n6    char val[1];\n7}\nThe len property contains the length of the string. By incrementing it, we can read and write further in memory, and therefore access the two memory regions we're interested in: the SHM and Apache's all_buckets.\nLocating bucket indexes and all_buckets\nWe want to change ap_scoreboard_image->parent[worker_id]->bucket for a certain worker_id. Luckily, the structure always starts at the beginning of the shared memory block, so it is easy to locate.\nShared memory location and targeted process_score structures\nCode 301 Bytes\n1root@apaubuntu:~# cat /proc/6318/maps | grep rw-s\n27f4a9323e000-7f4a93252000 rw-s 00000000 00:05 57052                      /dev/zero (deleted)\n3\n4(gdb) p &ap_scoreboard_image->parent[0]\n5$18 = (process_score *) 0x7f4a9323e020\n6(gdb) p &ap_scoreboard_image->parent[1]\n7$19 = (process_score *) 0x7f4a9323e044\nTo locate all_buckets, we can make use of our knowledge of the prefork_child_bucket structure. We have:\nImportant structures of bucket items\nCode 788 Bytes\n1prefork_child_bucket {\n2    ap_pod_t *pod;\n3    ap_listen_rec *listeners;\n4    apr_proc_mutex_t *mutex; <--\n5}\n6\n7apr_proc_mutex_t {\n8    apr_pool_t *pool;\n9    const apr_proc_mutex_unix_lock_methods_t *meth; <--\n10    int curr_locked;\n11    char *fname;\n12\n13    ...\n14}\n15\n16apr_proc_mutex_unix_lock_methods_t {\n17    unsigned int flags;\n18    apr_status_t (*create)(apr_proc_mutex_t *, const char *);\n19    apr_status_t (*acquire)(apr_proc_mutex_t *);\n20    apr_status_t (*tryacquire)(apr_proc_mutex_t *);\n21    apr_status_t (*release)(apr_proc_mutex_t *);\n22    apr_status_t (*cleanup)(void *);\n23    apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *); <--\n24    apr_status_t (*perms_set)(apr_proc_mutex_t *, apr_fileperms_t, apr_uid_t, apr_gid_t);\n25    apr_lockmech_e mech;\n26    const char *name;\n27}\nall_buckets[0]->mutex will be located in the same memory region as all_buckets[0]. Since meth is a static structure, it will be located in libapr's .data. Since meth points to functions defined in libapr, each of the function pointers will be located in libapr's .text.\nSince we have knowledge of those region's addresses through /proc/self/maps, we can go through every pointer in Apache's memory and find one that matches the structure. It will be all_buckets[0].\nAs I mentioned, all_buckets's address changes at every graceful restart. This means that when our exploit triggers, all_buckets's address will be different than the one we found. This has to be taken into account; we'll talk about this later.\n## 2. Write a fake prefork_child_bucket structure in the SHM\nReaching the function call\nThe code path to the arbitrary function call is the following:\nCode 192 Bytes\n1bucket_id = ap_scoreboard_image->parent[id]->bucket\n2my_bucket = all_buckets[bucket_id]\n3mutex = &my_bucket->mutex\n4apr_proc_mutex_child_init(mutex)\n5(*mutex)->meth->child_init(mutex, pool, fname)\n\nCalling something proper\nTo exploit, we make (*mutex)->meth->child_init point to zend_object_std_dtor(zend_object *object), which yields the following chain:\nCode 187 Bytes\n1mutex = &my_bucket->mutex\n2[object = mutex]\n3zend_object_std_dtor(object)\n4ht = object->properties\n5zend_array_destroy(ht)\n6zend_hash_destroy(ht)\n7val = &ht->arData[0]->val\n8ht->pDestructor(val)\npDestructor is set to system, and &ht->arData[0]->val is a string.\n\nAs you can see, both leftmost structures are superimposed.\n## 3. Make all_buckets[bucket] point to the structure\nProblem and solution\nRight now, if all_buckets' address was unchanged in between restarts, our exploit would be over:\nGet R/W over all memory after PHP's heap\nFind all_buckets by matching its structure\nPut our structure in the SHM\nChange one of the process_score.bucket in the SHM so that all_bucket[bucket]->mutex points to our payload\nAs all_buckets' address changes, we can do two things to improve reliability: spray the SHM and use every process_score structure - one for each PID.\nSpraying the shared memory\nIf all_buckets' new address is not far from the old one, my_bucket will point close to our structure. Therefore, instead of having our prefork_child_bucket structure at a precise point in the SHM, we can spray it all over unused parts of the SHM. The problem is that the\nstructure is also used as a zend_object, and therefore it has a size of (5 * 8 =) 40 bytes to include zend_object.properties.\nSpraying a structure that big over a space this small won't help us much.\nTo solve this problem, we superimpose the two center structures, apr_proc_mutex_t and zend_array, and spray their address in the rest of the shared memory.\nThe impact will be that prefork_child_bucket.mutex and zend_object.properties point to the same address.\nNow, if all_bucket is relocated not too far from its original address, my_bucket will be in the sprayed area.\n\nUsing every process_score\nEach Apache worker has an associated process_score structure, and with it a bucket index.\nInstead of changing one process_score.bucket value, we can change every one of them, so that they cover another part of memory. For instance:\nCode 284 Bytes\n1ap_scoreboard_image->parent[0]->bucket = -10000 -> 0x7faabbcc00 <= all_buckets <= 0x7faabbdd00\n2ap_scoreboard_image->parent[1]->bucket = -20000 -> 0x7faabbdd00 <= all_buckets <= 0x7faabbff00\n3ap_scoreboard_image->parent[2]->bucket = -30000 -> 0x7faabbff00 <= all_buckets <= 0x7faabc0000\nThis multiplies our success rate by the number of apache workers. Upon respawn, only one worker have a valid bucket number, but this is not a problem because the others will crash, and immediately respawn.\nSuccess rate\nDifferent Apache servers have different number of workers. Having more workers mean we can spray the address of our mutex over less memory, but it also means we can specify more index for all_buckets. This means that having more workers improves our success rate. After a few tries on my test Apache server of 4 workers (default), I had ~80% success rate.\nAgain, if the exploit fails, it can be restarted the next day as Apache will still restart properly. Apache's error.log will nevertheless contain notifications about its workers segfaulting.\n## 4. Await 6:25AM for the exploit to trigger\nWell, that's the easy step.\nVulnerability timeline\n2019-02-22 Initial contact email to security[at]apache[dot]org, with description and POC\n2019-02-25 Acknowledgment of the vulnerability, working on a fix\n2019-03-07 Apache's security team sends a patch for I to review, CVE assigned\n2019-03-10 I approve the patch\n2019-04-01 Apache HTTP version 2.4.39 released\nApache's team has been prompt to respond and patch, and nice as hell. Really good experience. PHP never answered regarding the UAF.\nExploit\nI'm not releasing it just yet !\nImpact\nYou generally obtain root privileges from www-data privileges.\n\n",
  "severity": [
    7.8,
    null
  ],
  "bounty": 1500,
  "weaknesses": [
    "Privilege Escalation"
  ],
  "screenshots": {},
  "disclosed_date": 1568209560,
  "report_url": "https://hackerone.com/reports/520903",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "HIGH",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Obtain R/W access on a worker process using a PHP UAF vulnerability"
    ],
    [
      2,
      "Write a fake prefork_child_bucket structure in the shared memory (SHM)"
    ],
    [
      3,
      "Modify the bucket index in the process_score structure to point to the fake structure in SHM"
    ],
    [
      4,
      "Wait for Apache to gracefully restart (typically at 6:25AM via logrotate) to trigger the exploit"
    ]
  ],
  "vuln_description": "The vulnerability is a local root privilege escalation in Apache HTTP server (versions 2.4.17 to 2.4.38) affecting mod_prefork, mod_worker, and mod_event. It involves an out-of-bounds array access in the shared memory scoreboard during graceful restarts, leading to an arbitrary function call as root. An attacker can manipulate the worker's bucket index to control the prefork_child_bucket structure and execute arbitrary code when the server restarts.",
  "reason": "This vulnerability involves multiple complex components: understanding Apache's worker management, shared memory manipulation, and PHP UAF exploitation. It requires deep knowledge of Apache's internal structures and memory layout, as well as the ability to chain these components together in a non-obvious way to achieve code execution. The attack also requires manipulating complex application states across different processes and memory regions.",
  "new_complexity": "VERY_HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "idor_detectable": false,
  "authnz_byppass_detectable": false,
  "is_simple_payload": false,
  "injection_metadata": {
    "is_simple_payload": true
  },
  "authnz_metadata": {
    "idor_detectable": false,
    "authnz_byppass_detectable": false
  }
}