{
  "reported_to": "curl",
  "reported_by": "shobhit2401200 ",
  "title": "Use of Unsafe function || Strcpy",
  "content": "\nSummary:\nIt was observed that application is using strcpy() function which may cause buffer overflow attacks.\nAffected Code\nhttps://github.com/curl/curl\nAffected Lines\nLine 195 of curl-master\\tests\\libtest\\stub_gssapi.c\nLine 204,212,216 curl-master\\tests\\server\\socksd.c\nSteps To Reproduce:\nLets first discuss what is the issue with strcpy function. basically it takes 2 arguments 1 dst 2 source. the issue is if the dst size is small and the source size is more without a null terminating value so it will overwrite the memory. so in these case 1 got the several lines about strcpy function. but i'm discussing 1 with you rest with remain the same.\nelse if(!strcmp(key, \"backend\")) {\nstrcpy(config.addr, value);\nelse if(!strcmp(key, \"password\")) {\nstrcpy(config.password, value);\nchar addr[32]; / backend IPv4 numerical /\nchar user[256];\nchar password[256];\nhere it is copying the value into config.addr and the size of addr is 32 and same goes for password is 256. now let suppose the value of value is more than 32 in case of add and in case of password it is more than 256. than it can be buffer overflow attack here. so here it will be secure if you use the functions like snprintf , strlcpy. or dynamically assign the size to the array.\nSupporting Material/References:\nhttps://cwe.mitre.org/data/definitions/676.html\nhttps://www.geeksforgeeks.org/why-strcpy-and-strncpy-are-not-safe-to-use/\nRecommendation:\nIt is recommended to use below mentioned functions to avoid buffer overflow attacks\nsnprintf\nstrlcpy\n[attachment / reference] Please find the attached screenshots for your reference.\nImpact\nThe strcpy() function does not specify the size of the destination array, so buffer overrun is often a risk. Using strcpy() function to copy a large character array into a smaller one is dangerous, but if the string will fit, then it will not be worth the risk. If the destination string is not large enough to store the source string then the behavior of strcpy() is unspecified or undefined.\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": null,
  "weaknesses": [
    "Classic Buffer Overflow"
  ],
  "screenshots": {},
  "disclosed_date": 1646880480,
  "report_url": "https://hackerone.com/reports/1485379",
  "is_multi_component": true,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Identify the use of strcpy() function in the codebase, specifically in the files curl-master\\tests\\libtest\\stub_gssapi.c and curl-master\\tests\\server\\socksd.c."
    ],
    [
      2,
      "Analyze the buffer sizes (e.g., config.addr[32], config.password[256]) and verify if the input (value) exceeds these sizes, which could lead to a buffer overflow."
    ]
  ],
  "vuln_description": "The vulnerability involves the use of the unsafe strcpy() function in the codebase, which can lead to buffer overflow attacks if the destination buffer is smaller than the source string. This can result in memory corruption and potential exploitation.",
  "reason": "The vulnerability is straightforward to identify as it involves a well-known unsafe function (strcpy()) and basic buffer size analysis. No complex interactions or state manipulations are required.",
  "new_complexity": "LOW",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}