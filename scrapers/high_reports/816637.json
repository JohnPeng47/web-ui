{
  "reported_to": "Internet Bug Bounty",
  "reported_by": "nathaniellives ",
  "title": "CVE-2020-10938-buffer overflow/out-of-bounds write in compress.c:HuffmanDecodeImage()",
  "content": "\nHello,\nThere is an out-of-bounds write that is likely exploitable while performing Huffman decoding of Fax images.\nThe technical details are as follows.\nType: integer underflow produces out of bounds heap/etc write\nPlatform: 32-bit\nDetails:\nCode 569 Bytes\n1 390 MagickExport MagickPassFail HuffmanDecodeImage(Image *image)\n2 391 {\n3 392 const HuffmanTable\n4 393 *entry;\n5 394\n6 [...]\n7 412\n8 413 long\n9 414 count,\n10 415 y;\n11 416\n12 [...]\n13 420 register long\n14 421 i,\n15 422 x;\n16 423\n17 [...]\n18 462 InitializeHashTable(mw_hash,TWTable,MWHashA,MWHashB);\n19 463 InitializeHashTable(mw_hash,MWTable,MWHashA,MWHashB);\n20 464 InitializeHashTable(mw_hash,EXTable,MWHashA,MWHashB);\n21 465 InitializeHashTable(mb_hash,TBTable,MBHashA,MBHashB);\n22 466 InitializeHashTable(mb_hash,MBTable,MBHashA,MBHashB);\n23 467 InitializeHashTable(mb_hash,EXTable,MBHashA,MBHashB);\nBasic initialization; of specific note are that the variables 'x' and 'count' are signed. On a 64-bit\nplatform, assuming GCC or similar, it is 8 bytes in length and of course 4 bytes in length on 32-bit. There\nis nothing inherently restricting this to 32-bit other than practicalities of the file size as there is a\nneed to have backing data to trigger the vulnerability. On 64-bit platforms this equates to a file size that\nexceeds the default maximums, whereas on 32-bit the attached Proof-of-Concept out-of-bounds write trigger\nonly requires a file of a few megabytes-- which to my understanding can be reduced by wrapping the file in\ncompression.\nAdditionally, the Huffman hash tables have code lengths that range between 0 and 2560.\nCode 1.06 KiB\n1495 color=True;\n2496 code=0;\n3497 count=0;\n4498 length=0;\n5499 runlength=0;\n6500 x=0;\n7501 for ( ; ; )\n8502 {\n9503 if (byte == EOF)\n10504 break;\n11505 if (x >= (long) image->columns)\n12506 {\n13507 while (runlength < 11)\n14508 InputBit(bit);\n15509 do { InputBit(bit); } while (bit == 0);\n16510 break;\n17511 }\n18512 bail=False;\n19513 do\n20514 {\n21515 if (runlength < 11)\n22516 InputBit(bit)\n23517 else\n24518 {\n25519 InputBit(bit);\n26520 if (bit)\n27521 {\n28522 null_lines++;\n29523 if (x != 0)\n30524 null_lines=0;\n31525 bail=True;\n32526 break;\n33527 }\n34528 }\n35529 code=(code << 1)+bit;\n36530 length++;\n37531 } while (code <= 0);\n38532 if (bail)\n39533 break;\n40534 if (length > 13)\n41535 {\n42536 while (runlength < 11)\n43537 InputBit(bit);\n44538 do\n45539 {\n46540 InputBit(bit);\n47541 } while (bit == 0);\n48542 break;\n49543 }\n50544 if (color)\n51545 {\n52546 if (length < 4)\n53547 continue;\n54548 entry=mw_hash[((length+MWHashA)*(code+MWHashB)) % HashSize];\n55549 }\n56550 else\n57551 {\n58552 if (length < 2)\n59553 continue;\n60554 entry=mb_hash[((length+MBHashA)*(code+MBHashB)) % HashSize];\n61555 }\n62556 if (!entry)\n63557 continue;\n64558 if ((entry->length != length) || (entry->code != code))\n65559 continue;\nIn the above code, we enter an unbounded for() loop at line 501, which terminates upon file EOF or other\nabnormal condition. lines 513-531 unpack a huffman encoded pixel one bit at a time. Once the first binary 1\nis encountered, the loop will always terminate until the total length of the code exceeds 13 or a\ncorresponding entry in the huffman tables are found at lines 548 or 554.\nIn other words, we unpack the pixels and look them up in the huffman tables. Once we encounter a one, we\nterminate the loop and attempt to look up the symbol in the corresponding tables matching the symbol length\nand the symbol code. If we don't find a match, then we restart the loop and unpack another bit. This\ncontinues until a symbol is found or a sequence of 11 or more zeros or 13 or more bits is encountered.\nCode 471 Bytes\n1 560 switch (entry->id)\n2 561 {\n3 562 case TWId:\n4 563 case TBId:\n5 564 {\n6 565 count+=entry->count;\n7 566 if ((x+count) > (long) image->columns)\n8 567 count=(long) image->columns-x;\n9 568 if (count > 0)\n10 569 {\n11 570 if (color)\n12 571 {\n13 572 x+=count;\n14 573 count=0;\n15 574 }\n16 575 else\n17 576 for ( ; count > 0; count--)\n18 577 scanline[x++]=1;\n19 578 }\n20 579 color=!color;\n21 580 break;\n22 581 }\n23 582 case MWId:\n24 583 case MBId:\n25 584 case EXId:\n26 585 {\n27 586 count+=entry->count;\n28 587 break;\n29 588 }\nWhen a symbol is found, we enter a jump table dependant upon the symbol type. The crux of the problem exists\nin this section. The bounds check at line 566: \"if ((x+count) > (long) image->columns)\" is insufficient due\nto the variables being signed, thus it becomes possible to:\n1 Iterate across TWId or TBId symbols incrementing the value of x such that x is non-zero but less than\nimage->columns\n2 Provide repeated instance of MWid, MBId or EXId symbols to iteratively work the \"count\" variable into a\nvalue close to but not exceeding INT_MAX\n3 Provide another TWId or TBId symbol causing an additive overflow at line 566.\n4 Depending upon the state of the variable 'color', this will either result in:\n\u22c5\u22c54 The x variable becoming negative yielding an invalid offset at line 577; or\n\u22c5\u22c54 Resulting in an invalid value of count which exceeds the image->columns and thus bounding of scanline,\nresulting in an out-of-bounds write at lines 577 and 578\nCode 41 Bytes\n1 592 code=0;\n2 593 length=0;\n3 594 }\n4 [...]\nProof-of-Concept:\nAttached is a simple C++ program that when build (make; assuming g++ is in your path) and run will output a\nfile 'poc.fax' that can then be supplied to any code path that causes\nReadImage()->ReadFAXImage()->HuffmanDecodeImage() to be executed. It works the 'x' variable up to a value of\n64, then the count variable up to INT_MAX - 64, then provides one of the symbols with a count length of 0 to\nmake x negative and then fetches a symbol that results in the out-of-bounds write.\nVendor Response\nJustin,\nThis problem (and a number of other issues observed in compress.c) are\naddressed by Mercurial changeset 16131:95abc2b694ce.\nThank you very much for your detailed report.\nBob\nImpact\nExploitability:\nAt first blush, this appears to be a wild out-of-bounds write with relatively little control. However, the\ncheck at line 568 allows us a finer grained control over circumstances. Notably, it becomes possible to skip\nover uncontrolled writes and toggle the color variable, the user can then supply additional MWId, MBId or\nEXId symbols, causing the value of count to become non-negative, which in tandem with the color toggle\nallows arbitrary modification of the x variable which in turn allows for a finer controlled write. The only\nbounding is the maximum file size to be processed with each iteration taking approximately 1.3 megabytes of\nhuffman codes which can be compressed and should compress down nicely.\nIn other words, you can set the value of x, then increment count into a negative value and toggle the color\nvariable back then increment count until its value is sane/positive again, and then re-enter the TWId/TBId\nsection thereby modifying the x variable again, then increment count into a negative and toggle color again\nand overall repeat. This would ultimately allow writes as fine grained as a single byte immediately after or\nimmediately before the scanline buffer and within a certain range outside of that bounding. As this is heap\nmemory, it is thought to readily lend itself to exploitability.\nFinally, because this would allow for the modification of heap metadata, e.g. block sizes and similar,\nbecause both the encoded and decoded data is user controlled without any real constraints and because all\ncode paths will trigger a free condition, exploitibility seems more a matter of academic interest than a\nlegitimate question.\nThe specifics of this can be begrudingly worked out if required.\n\n",
  "severity": [
    9.8,
    null
  ],
  "bounty": 100,
  "weaknesses": [
    "Heap Overflow"
  ],
  "screenshots": {},
  "disclosed_date": 1629618840,
  "report_url": "https://hackerone.com/reports/816637",
  "is_multi_component": false,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Create a malicious fax image file that manipulates Huffman encoding to trigger an integer underflow"
    ],
    [
      2,
      "Feed the malicious file to a vulnerable version of the software that processes fax images through HuffmanDecodeImage()"
    ]
  ],
  "vuln_description": "An integer underflow vulnerability in HuffmanDecodeImage() allows for out-of-bounds heap writes when processing specially crafted fax images. The vulnerability stems from insufficient bounds checking of signed integer variables during Huffman table lookups, enabling an attacker to manipulate memory beyond allocated buffers.",
  "reason": "This vulnerability requires deep understanding of Huffman encoding/decoding algorithms, precise manipulation of signed integer arithmetic to trigger underflows, and careful construction of fax image data structures. The attacker must maintain context across multiple encoding passes and understand subtle interactions between color state toggling and count variable manipulation.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": true,
  "is_ctf": false,
  "other_report": null
}