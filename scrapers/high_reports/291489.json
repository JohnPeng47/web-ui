{
  "reported_to": "Monero",
  "reported_by": "aerodudrizzt ",
  "title": "Kovri: potential buffer over-read in garlic clove handling + I2NP message creation",
  "content": "\nBrief\nThere is a lack of sanitation checks when handling Garlic messages in the kovri I2P router. Sending a specially crafted Garlic message can cause the router to send onward an I2P message containing leaked RAM data, triggering a massive information leakage.\nTechnical Details:\nCode Version: Taken from Github on the 18th of November 2017 - commit 5aafe6608519d31e537c97b24ea7b23aa372dd5b\nVulnerable File: src\\core\\router\\garlic.h\nVulnerable Function: GarlicDestination::HandleGarlicPayload\nThe function is responsible to parse and handle Garlic Payloads: several independent Garlic Cloves.\nWhen handling a clove with a delivery type of \"DeliveryTypeTunnel\" there are insufficient checks on the message, before it is wrapped and sent onward:\nCode 2.32 KiB\n1    GarlicDeliveryType delivery_type = (GarlicDeliveryType)((flag >> 5) & 0x03);\n2    switch (delivery_type) {\n3      case eGarlicDeliveryTypeLocal:\n4        LOG(debug) << \"GarlicDestination: Garlic type local\";\n5        HandleI2NPMessage(buf, len, from);\n6      break;\n7      case eGarlicDeliveryTypeDestination:\n8        LOG(debug) << \"GarlicDestination: Garlic type destination\";\n9        buf += 32;  // destination. check it later or for multiple destinations\n10        HandleI2NPMessage(buf, len, from);\n11      break;\n12      case eGarlicDeliveryTypeTunnel: {\n13        LOG(debug) << \"GarlicDestination: Garlic type tunnel\";\n14        // gateway_hash and gateway_tunnel sequence is reverted\n15        std::uint8_t* gateway_hash = buf;\n16        buf += 32;\n17        std::uint32_t gateway_tunnel = bufbe32toh(buf);\n18        buf += 4;\n19        std::shared_ptr<kovri::core::OutboundTunnel> tunnel;\n20        if (from && from->GetTunnelPool())\n21          tunnel = from->GetTunnelPool()->GetNextOutboundTunnel();\n22        // EI [BUG-TRACE] : The payload length is based on an unchecked length field\n23        // EI             : from the just found I2NP message contained in the clove.\n24        // EI\t          : When creating and sending this message onward we may leak\n25        // EI             : heap memory data to the destination node [18/11/2017]\n26        if (tunnel) {  // we have send it through an outbound tunnel\n27          auto msg = CreateI2NPMessage(buf, kovri::core::GetI2NPMessageLength(buf), from);\n28          tunnel->SendTunnelDataMsg(gateway_hash, gateway_tunnel, msg);\n29        } else {\n30          LOG(debug)\n31            << \"GarlicDestination: no outbound tunnels available for garlic clove\";\n32        }\n33        break;\n34      }\n35      case eGarlicDeliveryTypeRouter:\n36        LOG(warning) << \"GarlicDestination: Garlic type router not supported\";\n37        buf += 32;\n38      break;\n39      default:\n40        LOG(error)\n41          << \"GarlicDestination: unknown garlic delivery type \"\n42          << static_cast<int>(delivery_type);\n43    }\n44    buf += kovri::core::GetI2NPMessageLength(buf);  // I2NP\n45    buf += 4;  // CloveID\n46    buf += 8;  // Date\n47    buf += 3;  // Certificate\n48    // EI [BUG_TRACE] : This check is too late since the I2NP message was already sent. [18/11/2017]\n49    if (buf - buf1  > static_cast<int>(len)) {\n50      LOG(error) << \"GarlicDestination: clove is too long\";\n51      break;\n52    }\nProposed Fix\nThe inner I2NP message is parsed and forwarded using it's own length field BEFORE this field is checked for consistency. There is a good sanitation check in the bottom of the function, but the check is preformed only AFTER the message is sent.\nThe proposed fix is to copy the current code check to the vulnerable case, and to preform it before the new message is created:\nCode 1.07 KiB\n1    case eGarlicDeliveryTypeTunnel: {\n2        LOG(debug) << \"GarlicDestination: Garlic type tunnel\";\n3        // gateway_hash and gateway_tunnel sequence is reverted\n4        std::uint8_t* gateway_hash = buf;\n5        buf += 32;\n6        std::uint32_t gateway_tunnel = bufbe32toh(buf);\n7        buf += 4;\n8        std::shared_ptr<kovri::core::OutboundTunnel> tunnel;\n9        if (from && from->GetTunnelPool())\n10          tunnel = from->GetTunnelPool()->GetNextOutboundTunnel();\n11        // EI [BUG-FIX] : added this new check\n12        if (buf + kovri::core::GetI2NPMessageLength(buf) + 4 + 8 + 3 - buf1  > static_cast<int>(len)) {\n13          LOG(error) << \"GarlicDestination: clove is too long\";\n14          break;\n15        }\n16        if (tunnel) {  // we have send it through an outbound tunnel\n17          auto msg = CreateI2NPMessage(buf, kovri::core::GetI2NPMessageLength(buf), from);\n18          tunnel->SendTunnelDataMsg(gateway_hash, gateway_tunnel, msg);\n19        } else {\n20          LOG(debug)\n21            << \"GarlicDestination: no outbound tunnels available for garlic clove\";\n22        }\n23        break;\n24      }\nImplications\nSince the original message is allocated on the heap, this message can leak massive amounts of heap data to the receiving node (message lengths can be even 32KB). This data contains previous messages, currently treated messages, and many other sensitive data-structures of the I2P router.\nIn case there are any questions regarding my findings I will be more than happy to help.\n\n",
  "severity": [
    7.7,
    null
  ],
  "bounty": 1,
  "weaknesses": [
    "Information Disclosure"
  ],
  "screenshots": {},
  "disclosed_date": 1512472140,
  "report_url": "https://hackerone.com/reports/291489",
  "is_multi_component": true,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Send a specially crafted Garlic message to the Kovri I2P router with a delivery type of 'DeliveryTypeTunnel'."
    ],
    [
      2,
      "Observe that the router processes the message without proper length checks, potentially leaking heap memory data in the forwarded I2NP message."
    ]
  ],
  "vuln_description": "The vulnerability involves a lack of sanitation checks when handling Garlic messages in the Kovri I2P router. A specially crafted message can cause the router to forward an I2NP message containing leaked RAM data, leading to significant information disclosure.",
  "reason": "The vulnerability requires understanding the Garlic message handling process and the specific lack of checks in the 'DeliveryTypeTunnel' case. While the issue is straightforward once identified, discovering it involves analyzing the message parsing logic and recognizing the missing validation step before message forwarding.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}