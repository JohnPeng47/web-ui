{
  "reported_to": "Rootstock Labs",
  "reported_by": "z3t ",
  "title": "DoS through PeerExplorer",
  "content": "\nSummary: The peer discovery implementation is vulnerable to a Denial of Service attack due to improper management of connections.\nDescription: The two main files of interest in detailing this vulnerability are PeerExplorer.java and NodeChallengeManager.java. To explain the flow of execution I'll be mentioning two theoretical nodes: an attacker, \"N1\" and a target, \"N2\".\nWhen N1 sends an initial \"ping\" message to N2, N2 will reply with a \"pong\" message and a subsequent ping message to continue the handshake. After this, when N1 replies with a pong message, N2 will attempt to add N1 to its structure holding established connections. The relevant code snippets from PeerExplorer.java are below:\nCode 1.03 KiB\n1public void handlePong(String ip, PongPeerMessage message) {\n2\tPeerDiscoveryRequest request = this.pendingPingRequests.get(message.getMessageId());\n3\n4\tif (request != null && request.validateMessageResponse(message)) {\n5\t\tthis.pendingPingRequests.remove(message.getMessageId());\n6\t\tNodeChallenge challenge = this.challengeManager.removeChallenge(message.getMessageId());\n7\t\tif (challenge == null) {\n8\t\t\tthis.addConnection(message, ip, message.getPort());\n9\t\t}\n10\t}\n11}\n12...\n13private void addConnection(PongPeerMessage message, String ip, int port) {\n14\tNode senderNode = new Node(message.getNodeId().getID(), ip, port);\n15\tif (!StringUtils.equals(senderNode.getHexId(), this.localNode.getHexId())) {\n16\t\tOperationResult result = this.distanceTable.addNode(senderNode);\n17\n18\t\tif (result.isSuccess()) {\n19\t\t\tNodeID senderId = senderNode.getId();\n20\t\t\tthis.establishedConnections.put(senderId, senderNode);\n21\t\t\tlogger.debug(\"New Peer found ip:[{}] port[{}]\", ip, port);\n22\t\t} else {\n23\t\t\tthis.challengeManager.startChallenge(result.getAffectedEntry().getNode(), senderNode, this);\n24\t\t}\n25\t}\n26}\nThe addConnection method first attempts to add N1 to the NodeDistanceTable - a structure designed to hold a limited number of nodes (by default, 4096). If this insertion fails due to the target NodeDistanceTable bucket already being full, the attempted connection is instead added to NodeChallengeManager. The relevant code snippets from NodeChallengeManager.java are below:\nCode 503 Bytes\n1public NodeChallenge startChallenge(Node challengedNode, Node challenger, PeerExplorer explorer) {\n2\tPingPeerMessage pingMessage = explorer.sendPing(challengedNode.getAddress(), 1, challengedNode);\n3\tString messageId = pingMessage.getMessageId();\n4\tNodeChallenge challenge = new NodeChallenge(challengedNode, challenger, messageId);\n5\tactiveChallenges.put(messageId, challenge);\n6\treturn challenge;\n7}\n8\n9public NodeChallenge removeChallenge(String challengeId) {\n10\treturn activeChallenges.remove(challengeId);\n11}\nThrough the startChallenge method N2 will send N1 another ping message, adding a \"challenge\" to activeChallenges with that new ping message's messageId. The issue here is that the entry is only ever removed from activeChallenges if N1 replies with a pong that has the same messageId as the new ping message - as seen in PeerExplorer.handlePong. Thus, N1 is able to create an arbitrary number of entries in activeChallenges by never sending N2 a pong with the challenge ping's messageId.\nIt should be noted that there is a slight limitation as to how this could be exploited by a single host. The relevant code snippets from PeerExplorer.java are below:\nCode 487 Bytes\n1public PingPeerMessage sendPing(InetSocketAddress nodeAddress, int attempt, Node node) {\n2\tPingPeerMessage nodeMessage = checkPendingPeerToAddress(nodeAddress);\n3\n4\tif (nodeMessage != null) {\n5\t\treturn nodeMessage;\n6\t}\n7\t....\n8}\n9...\n10private PingPeerMessage checkPendingPeerToAddress(InetSocketAddress address) {\n11\tfor (PeerDiscoveryRequest req : this.pendingPingRequests.values()) {\n12\t\tif (req.getAddress().equals(address)) {\n13\t\t\treturn (PingPeerMessage) req.getMessage();\n14\t\t}\n15\t}\n16\n17\treturn null;\n18}\n19\nThe sendPing method will only ever actually send a new ping to N1 if there are no pending pings to its InetSocketAddress (which is deemed equal if the host and port match) - as seen in checkPendingPeerToAddress. However, pending pings have a set expiry time (by default, 30 seconds) and those that have expired are cleared by PeerExplorerCleaner at a fixed rate (by default, every 60 seconds). So due to this limitation, with the default configuration settings a single host can only complete 65,535 handshakes (one per port) every minute - imposing a (perhaps unreachable) limit on the time it takes to exhaust the target node's memory. Though this can obviously be circumvented by using multiple hosts to attack a target node.\nBecause most peer discovery functionality identifies nodes by their NodeID and not by host/port, it's trivial to send a flood of requests with unique NodeIDs to fill NodeDistanceTable and subsequently make an unrestricted amount of in-memory insertions into NodeChallengeManager.activeChallenges. This is further aided by the fact that NodeChallengeManager is never purged, so the request flood does not have to occur within a short period of time. Memory exhaustion will eventually occur as the NodeChallenge objects begin taking up a significant amount of memory and are not eligible for garbage collection. This is expected to eventually disable node functionality as individual threads die when they throw OutOfMemoryErrors, but in my testing it ended up crashing the whole JVM after reaching ~200,000 insertions.\nSteps To Reproduce:\nI've attached a PoC program that interfaces with the RSKj library for the sake of simplicity. Due to the PoC program being somewhat inefficient and unreliable, I ended up accelerating the testing process by modifying my testing node's NodeChallengeManager to make 10 insertions per valid startChallenge call. If you're interested in running the PoC despite those issues, follow these steps:\nDownload a copy of the RSKj code\nMove the PoC files into the co.rsk.net.discovery package (overwrite PeerExplorer.java with my modified version)\nLaunch a node for testing - ensure peer discovery is enabled\nCompile and run the PoC from PeerFlood - arguments format: <local_address> <target_address> <target_port> <num_threads>\nMonitor testing node's logs and stability\nIf you're developing your own PoC, you need to simply flood a testing node with connections that use random NodeIDs, completing a single ping<->pong handshake then immediately disconnecting.\nMitigation\nThis could be mitigated by implementing expiring challenges that are cleared by PeerExplorerCleaner.\nImpact\nAn attacker could crash any RSKj node with peer discovery enabled (which it is by default).\n\n",
  "severity": [
    7.7,
    null
  ],
  "bounty": 4000,
  "weaknesses": [
    "Uncontrolled Resource Consumption"
  ],
  "screenshots": {},
  "disclosed_date": 1568826960,
  "report_url": "https://hackerone.com/reports/363636",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Send an initial 'ping' message from attacker node N1 to target node N2."
    ],
    [
      2,
      "N2 replies with a 'pong' and a subsequent 'ping' message to continue the handshake."
    ],
    [
      3,
      "N1 replies with a 'pong' message, causing N2 to attempt to add N1 to its established connections."
    ],
    [
      4,
      "If N2's NodeDistanceTable is full, it adds the connection to NodeChallengeManager.activeChallenges."
    ],
    [
      5,
      "N1 does not respond to the challenge 'ping' message, leaving the entry in activeChallenges indefinitely."
    ],
    [
      6,
      "Repeat steps 1-5 with unique NodeIDs to exhaust N2's memory."
    ]
  ],
  "vuln_description": "The peer discovery implementation is vulnerable to a Denial of Service attack due to improper management of connections. An attacker can flood a target node with connections using random NodeIDs, causing the target to accumulate entries in NodeChallengeManager.activeChallenges indefinitely, leading to memory exhaustion and eventual node crash.",
  "reason": "This vulnerability involves understanding the peer discovery handshake process, the NodeDistanceTable and NodeChallengeManager structures, and the subtle interaction where unresponded challenges are not purged. The attacker must also manipulate the application state by filling the NodeDistanceTable to trigger the challenge mechanism.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}