{
  "reported_to": "shopify-scripts",
  "reported_by": "h72 ",
  "title": "Range#initialize_copy null pointer dereference",
  "content": "\nHeya!\nIt's possible to segfault mruby through mruby-engine with the following snippet of code:\nRange.remove_method(:initialize_copy)\n(1..2).dup.to_s\nThis can be triggered through mruby-engine like this:\nMRubyEngine.new(512*1024, 1000, 1000).sandbox_eval(\"/tmp\", %{\nRange.remove_method(:initialize_copy)\n(1..2).dup.to_s\n})\nThe dup and clone methods allocate a new object and then call initialize_copy on the new object with the old object as an argument to copy over internal state.\nRemoving Range#initialize_copy makes it possible to construct an uninitialized Range object. Calling (pretty much) any instance method on the uninitialized Range object afterwards causes mruby to dereference a null pointer, leading to a segfault.\nI've attached a patch that fixes the bug by copying internal range state before calling initialize_copy, similar to what mruby already does for classes and modules.\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": 10000,
  "weaknesses": [
    "Uncontrolled Resource Consumption"
  ],
  "screenshots": {},
  "disclosed_date": 1481954580,
  "report_url": "https://hackerone.com/reports/181685",
  "is_multi_component": false,
  "complexity": "LOW",
  "novelty": "LOW",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Remove the initialize_copy method from the Range class: Range.remove_method(:initialize_copy)"
    ],
    [
      2,
      "Duplicate a Range object and call to_s on it: (1..2).dup.to_s"
    ]
  ],
  "vuln_description": "The vulnerability allows for a null pointer dereference in mruby when the initialize_copy method is removed from the Range class. This leads to an uninitialized Range object being created, and any subsequent method call on this object causes a segfault due to dereferencing a null pointer.",
  "reason": "The attack involves understanding the internal behavior of object duplication in mruby and the role of initialize_copy in initializing object state. While the steps to reproduce are straightforward, the underlying issue requires knowledge of how mruby handles object initialization and duplication internally.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}