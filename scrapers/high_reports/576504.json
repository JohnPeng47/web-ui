{
  "reported_to": "Revive Adserver",
  "reported_by": "paulos__ ",
  "title": "Authentication Bypass by abusing Insecure crypto tokens in /lib/OA/Dal/PasswordRecovery.php:",
  "content": "\nHi,\nThis is a fun bug I came across while doing a pentest for a client, after going through Revive Advserver's code for a few hours, I found this authentication bypass. This vulnerability seem to affect all versions, including the latest one, I was sent by one of your developers to report it here.\nIt goes like this:\nIn /lib/OA/Dal/PasswordRecovery.php:\nCode 385 Bytes\n150: function generateRecoveryId($userId)\n2{\n3$doPwdRecovery = OA_Dal::factoryDO('password_recovery');\n4\n5    // Make sure that recoveryId is unique in password_recovery table\n6    do {\n7        $recoveryId = strtoupper(md5(uniqid('', true)));\n8        $recoveryId = substr(chunk_split($recoveryId, 8, '-'), -23, 22);\n9        $doPwdRecovery->recovery_id = $recoveryId;\n10        ....\n11 .....\n12....\nThat function is used to generate the password reset token used to create new password for admins. The token generated for changing password is insecure because it soley just relies on uniqid() which, according to PHP manual states:\n\"This function does not create random nor unpredictable string. This function must not be used for security purposes. Use cryptographically secure random function/generator and cryptographically secure hash functions to create unpredictable secure ID.\"\nThe reason being that the function does not generate cryptographically secure tokens, in fact without being passed any additional parameters the return value is little different from microtime(). If you need to generate cryptographically secure tokens use openssl_random_pseudo_bytes()\nuniqid() is worse than the manual makes it out to be. An example return value is 58fc30c53db63 . Already, this is only <7 bytes of entropy. But it becomes worse, because without the more_entropy flag set, PHP only uses the current time to generate the return value, PHP code says:\nCode 234 Bytes\n1sec = (int) tv.tv_sec;\n2usec = (int) (tv.tv_usec % 0x100000);\n3if (more_entropy) {\n4uniqid = strpprintf(0, \"%s%08x%05x%.8F\", prefix, sec, usec, php_combined_lcg() * 10);\n5} else {\n6uniqid = strpprintf(0, \"%s%08x%05x\", prefix, sec, usec);\n7}\nThe first four bytes are the current UNIX timestamp, and the last 20 bits are derived from the current time in microseconds.\nThis gives a bit less than 2\u00b2\u2070, or one million, possible results per given second. If you are able to predict when a new session key is generated for a user, you can guess their key with a decent number of requests, depending on how accurate your guess is. On a popular forum, you may not even need to target a specific user, as the number of users logging in at one time may be large enough.\nAnd lucky for us, we can easily predict what Revive Adserver uses:\nIdeally an attacker will look up the host IP of their target, locate the server's geoip and set their timezone similar to the server's timezone to make a more accurate prediction.\nMaking it more practical\nWhen looking more closely I noticed, most servers that host Revive respond with the following headers:\nCode 243 Bytes\n1HTTP/1.1 200 OK\n2Server: nginx\n3Date: Thu, 09 May 2019 21:26:20 GMT\n4Content-Type: application/x-javascript\n5Connection: close\n6Vary: Accept-Encoding\n7X-Cacheable: NO:Not Cacheable\n8Age: 0\n9X-Cache: MISS\n10X-Frame-Options: SAMEORIGIN\n11Content-Length: ...\nDo you see it? It says Date: Thu, 09 May 2019 21:26:20 GMT -- so we can easily know what timezone the server syncs and uses (in this case GMT+0 as timezone) , all an attacker have to do is change their timezone to GMT, request a password reset token simultaneously as they they generate uniqid() from their side as well. All an attacker needs is the email address of the account they reset (which can be enumurated in numerous ways, including by abusing admin/password-recovery.php by sending some email addresses until it says Email Password Reset sent)\nA PoC one would use can look like the following (except weaponized to request a password and generate the tokens simultaneously):\nCode 186 Bytes\n1for($i=0;$i<=10000;$i++){\n2\n3     $recoveryId = strtoupper(md5(uniqid('', true)));\n4     $recoveryId = substr(chunk_split($recoveryId, 8, '-'), -23, 22);\n5\n6     print $recoveryId.\"</br>\";\n7\n8}\nThis generates 10,000 tokens we can try as a token to login as the admin by automating this with process with Burp Intruder.\nYou get the idea! :)\nSuggested Fix\nRelaying on more cryptographically secure functions like openssl_random_pseudo_bytes() is better for such sensitive tokens.\nImpact\nAuthentication Bypass\nThanks,\n\n",
  "severity": "[",
  "bounty": null,
  "weaknesses": "[",
  "screenshots": {},
  "disclosed_date": 1558466100,
  "report_url": "https://hackerone.com/reports/576504",
  "is_multi_component": false,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "WEB_APP",
  "steps": "[",
  "vuln_description": "The vulnerability is an authentication bypass in Revive Adserver due to the insecure generation of password reset tokens. The tokens are generated using uniqid(), which relies on predictable time-based values, making them susceptible to brute-force attacks if an attacker can synchronize with the server's timezone.",
  "reason": "The attack involves understanding the predictable nature of uniqid() and synchronizing with the server's timezone, but does not require complex interactions or state manipulations. The vulnerability is straightforward once the predictable token generation is identified.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "idor_detectable": false,
  "authnz_byppass_detectable": true,
  "injection_classification": "}}}"
}