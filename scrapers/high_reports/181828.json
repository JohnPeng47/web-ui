{
  "reported_to": "shopify-scripts",
  "reported_by": "dkasak ",
  "title": "Segfault in mruby, mruby_engine and the parent MRI Ruby due to null pointer dereference",
  "content": "\nIntroduction\nCertain valid Ruby programs are able to cause a segmentation fault in mruby through a null pointer derefence, which in turn leads to a crash in mruby_engine and the parent MRI Ruby process.\nProof of concept\ncrash.rb:\ndef method\nyield\nend\nmethod(&a &&= 0)\nSave the above code as crash.rb\nRun either: a) mruby crash.rb b) sandbox crash.rb\nBoth cause a segmentation fault.\nDiscussion\nEverything below assumes the latest master of the mruby repository as of Nov 12th, which is commit 88604e39ac9c25ffdad2e3f03be26516fe866038.\nThe null pointer dereference itself for the above POC happens in ext/mruby_engine/mruby/src/vm.c, line 1266:\nregs[0] = m->env->stack[0];\nThe env member of is a null pointer since m refers to a RProc * of a non-closure lambda.\nThe underlying cause of the bug is an unsafe peephole optimization during code generation which isn't a valid transformation in certain contexts. Let's examine the debug information generated by running mruby -v crash.rb:\n00001 NODE_SCOPE:\n00005 local variables:\n00005 a\n00001 NODE_BEGIN:\n00001 NODE_DEF:\n00003 method\n00002 NODE_BEGIN:\n00002 NODE_YIELD:\n00005 NODE_CALL:\n00005 NODE_SELF\n00005 method='method' (665)\n00005 args:\n00005 block:\n00005 NODE_BLOCK_ARG:\n00005 NODE_OP_ASGN:\n00005 lhs:\n00005 NODE_LVAR a\n00005 op='&&' (666)\n00005 NODE_INT 0 base 10\nirep 0x10d5920 nregs=4 nlocals=2 pools=0 syms=1 reps=1\nfile: crash.rb\n1 000 OP_TCLASS R2\n1 001 OP_LAMBDA R3 I(+1) 1\n1 002 OP_METHOD R2 :method\n5 003 OP_LOADSELF R2\n5 004 OP_JMPNOT R1 007\n5 005 OP_LOADI R3 0\n5 006 OP_MOVE R1 R3 ; R1:a\n5 007 OP_SENDB R2 :method 0\n5 008 OP_STOP\nirep 0x10db740 nregs=3 nlocals=2 pools=0 syms=1 reps=0\nfile: crash.rb\n1 000 OP_ENTER 0:0:0:0:0:0:0\n2 001 OP_BLKPUSH R2 0:0:0:0\n2 002 OP_SEND R2 :call 0\n2 003 OP_RETURN R2 return\nFrom the above, it can be seen that R3 is set to a lambda representing the method method but then never re-set again in the true branch of the JMPNOT. Furthermore, the condition of JMPNOT will always be true in this particular case since a was never defined so the use of the &&= assignment operator causes it to be set to nil.\nSince a method called through SENDB A B C expects the passed block to be located in the register A+C+1, which is R3 in the caller's context, it is obvious the method will instead receive the lambda representing method instead. Since lambdas are represented as (RProc *), just as blocks are, this won't cause a type error. However, this particular lambda is not a closure so its (RProc *) doesn't contain an env member and it is a null pointer.\nNote that the problem isn't limited to methods with blocks, as can be seen from this slightly modified example which also causes a segfault:\nmodified_crash.rb:\ndef method(x)\nx.call\nend\nmethod(a &&= 0)\nWe then investigated further to check why the code generator was producing faulty bytecode, only to find that it in fact emits a correct MOVE R3 R1 instruction immediately after the LOADSELF. However, since it is then followed by an appropriately \"shaped\" JMPNOT, it triggers the following peephole reduction rule which elides the MOVE:\nMOVE R3 R1\nJMPNOT R3 0\n\nJMPNOT R1 0\nThe rule in question is located in ext/mruby_engine/mruby/mrbgems/mruby-compiler/core/codegen.c, line 350. In another related example where the operation a &&= 0 is done outside the argument list, the bytecode is almost exactly the same, just shuffled around. However, this shuffling prevents the MOVE and JMPNOT in being adjacent, which prevents the peephole rule from triggering and results in an ordinary mruby exception:\nnon_crash.rb:\ndef method\nyield\nend\na &&= 0\nmethod(&a)\nThis yields the following AST and bytecode:\n00001 NODE_SCOPE:\n00005 local variables:\n00005 a\n00001 NODE_BEGIN:\n00001 NODE_DEF:\n00003 method\n00002 NODE_BEGIN:\n00002 NODE_YIELD:\n00005 NODE_OP_ASGN:\n00005 lhs:\n00005 NODE_LVAR a\n00005 op='&&' (666)\n00005 NODE_INT 0 base 10\n00007 NODE_CALL:\n00007 NODE_SELF\n00007 method='method' (665)\n00007 args:\n00007 block:\n00007 NODE_BLOCK_ARG:\n00007 NODE_LVAR a\nirep 0x2468920 nregs=4 nlocals=2 pools=0 syms=1 reps=1\nfile: a-new-kind-of-crash.7\n1 000 OP_TCLASS R2\n1 001 OP_LAMBDA R3 I(+1) 1\n1 002 OP_METHOD R2 :method\n5 003 OP_JMPNOT R1 005\n5 004 OP_LOADI R1 0 ; R1:a\n7 005 OP_LOADSELF R2\n7 006 OP_MOVE R3 R1 ; R1:a <<<the MOVE isn't elided>>>\n7 007 OP_SENDB R2 :method 0\n7 008 OP_STOP\nirep 0x246e740 nregs=3 nlocals=2 pools=0 syms=1 reps=0\nfile: a-new-kind-of-crash.7\n1 000 OP_ENTER 0:0:0:0:0:0:0\n2 001 OP_BLKPUSH R2 0:0:0:0\n2 002 OP_SEND R2 :call 0\n2 003 OP_RETURN R2 return\ntrace:\n[1] a-new-kind-of-crash.7:2:in Object.method\n[0] a-new-kind-of-crash.7:7\nLocalJumpError: unexpected yield\nSolution\nWe investigated several possible solutions, but ultimately the peephole optimization in question seems very precarious. As best as we could tell, the triggering factor seems to be an AST with a NODE_OP_ASGN nested inside a NODE_CALL (not necessarily as an immediate child). Since most of the work is done in the function codegen which is called recursively, there is no simple way to detect this special case without examining the AST. Therefore, presumably a flag should be set when the code generator enters a NODE_CALL so the peepholer knows not to make this optimization if inside it.\nSince with our limited knowledge of the codebase it's not obvious that this is the right solution, we decided to simply disable the optimization for now since it is relatively low impact. We supply the following patch:\ndiff --git a/mrbgems/mruby-compiler/core/codegen.c b/mrbgems/mruby-compiler/core/codegen.c\nindex 9b064b8..6539ed4 100644\n--- a/mrbgems/mruby-compiler/core/codegen.c\n+++ b/mrbgems/mruby-compiler/core/codegen.c\n@@ -346,13 +346,6 @@ genop_peep(codegen_scope *s, mrb_code i, int val)\n}\n}\nbreak;\ncase OP_JMPIF:\ncase OP_JMPNOT:\nif (c0 == OP_MOVE && GETARG_A(i) == GETARG_A(i0)) {\ns->iseq[s->pc-1] = MKOP_AsBx(c1, GETARG_B(i0), GETARG_sBx(i));\nreturn s->pc-1;\n}\nbreak; default: break; }\nWith the optimization disabled, the segfault no longer happens and the code passes all tests. If the mruby developers insist that this optimization should remain, we are willing to work with them to develop a fix.\n--\nDenis Kasak\nDamir Jeli\u0107\n\n",
  "severity": [
    8.6,
    null
  ],
  "bounty": 10000,
  "weaknesses": [
    "Uncontrolled Resource Consumption"
  ],
  "screenshots": {},
  "disclosed_date": 1481942520,
  "report_url": "https://hackerone.com/reports/181828",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Create a Ruby file named 'crash.rb' with the following content:\n\ndef method\n  yield\nend\nmethod(&a &&= 0)"
    ],
    [
      2,
      "Run either 'mruby crash.rb' or 'sandbox crash.rb' to trigger the segmentation fault."
    ]
  ],
  "vuln_description": "A null pointer dereference in mruby, mruby_engine, and the parent MRI Ruby process can be triggered by certain valid Ruby programs, leading to a segmentation fault. This occurs due to an unsafe peephole optimization during code generation that results in faulty bytecode when processing specific Ruby constructs involving method calls and block arguments.",
  "reason": "The vulnerability requires deep understanding of mruby's bytecode generation and peephole optimization mechanisms, as well as the ability to recognize how specific Ruby language constructs interact with these internals. The researcher needed to analyze the generated bytecode and identify the problematic optimization rule that causes the null pointer dereference.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}