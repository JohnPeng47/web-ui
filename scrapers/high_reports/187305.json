{
  "reported_to": "shopify-scripts",
  "reported_by": "dkasak ",
  "title": "Invalid handling of zero-length heredoc identifiers leads to infinite loop in the sandbox",
  "content": "\nIntroduction\nCertain invalid Ruby programs (which should normally raise a syntax error) are able to cause an infinite loop in MRuby's parser which makes the mruby-engine sandbox (and consequently the MRI process it is running in) unresponsive to SIGTERM. The process begins looping forever and has to be terminated using SIGABRT or SIGKILL. The bug is caused by an improper handling of heredocs with a zero-length identifier.\nProof of concept\ninfinite_heredoc.rb:\n<<''.a begin\nSave the above code as infinite_heredoc.rb.\nRun either: a) mruby infinite_heredoc.rb b) sandbox infinite_heredoc.rb\nBoth cause an infinite loop, but b) also leaves the process unresponsive to SIGTERM.\nDiscussion\nEverything below assumes the latest master of the mruby repository as of Dec 01th, which is commit 2cca9d368815e9c83a7489c40d69937d68cb43a2.\nThe <<''\u02d9in the above POC code is parsed as a heredoc with an empty identifier. The rest of the POC is needed to bring the parser in a state where it is:\nContinually searching for the identifier.\nErroneously thinking it found it, thereby signalling an end of the heredoc by pushing a tHEREDOC_END token.\nThis token is then invalid for the current parser state, which makes it push an error token.\nFinally, while processing the error, the parser eventually calls parse_string again, which brings the process back to step 1, resulting in an infinite loop.\nA variation of the bug, using do instead of begin:\ninfinite_heredoc_variation.rb:\n<<''.a do\nAn excerpt from the parser's debug output, demonstrating the above:\nReading a token: Next token is token tHEREDOC_END ()\nError: discarding token tHEREDOC_END ()\nError: popping token error ()\nStack now 0 2 81 370 586 257 8 199\nShifting token error ()\nEntering state 271\nReading a token: Next token is token tHEREDOC_END ()\nError: discarding token tHEREDOC_END ()\n[...]\nIt is interesting to study what output MRI's parser gives for the same input:\ninfinite_heredoc.rb:1: can't find string \"\" anywhere before EOF\ninfinite_heredoc.rb:1: syntax error, unexpected end-of-input, expecting tSTRING_CONTENT or tSTRING_DBEG or tSTRING_DVAR or tSTRING_END\n<<''.a begin\n^\nFor a heredoc with a non-zero name, both MRuby and MRI produce similar outputs:\nheredoc_valid_name.rb\n<<'h'.a begin\nMRuby output\nheredoc_valid_name.rb:3:0: can't find heredoc delimiter \"h\" anywhere before EOF\nheredoc_valid_name.rb:3:0: syntax error, unexpected $end\nMRI output\nheredoc_valid_name.rb:1: can't find string \"h\" anywhere before EOF\nheredoc_valid_name.rb:1: syntax error, unexpected end-of-input, expecting tSTRING_CONTENT or tSTRING_DBEG or tSTRING_DVAR or tSTRING_END\n<<'h'.a begin\n^\nSolution\nThe problematic code is located parse.y, function parse_string, starting at line 3956:\nif ((len-1 == hinf->term_len) && (strncmp(s, hinf->term, len-1) == 0)) {\nreturn tHEREDOC_END;\n}\nThe above code checks whether the current heredoc identifier can be matched and, if so, signals the end of the heredoc by returning a tHEREDOC_END token. The code is incorrect in the case when the length parameter is 0 due to the use of strncmp since it will return 0 even when the input strings are different (as is the case here, where s is \"\\n\" and hinf->term is \"\"). Therefore, the check incorrectly succeeds when it shouldn't.\nA possible fix is to check whether hinf->term_len != 0 in addition to the present checks so zero-length heredoc identifiers are invalidated.\nempty_heredoc_identifier.patch\ndiff --git a/mrbgems/mruby-compiler/core/parse.y b/mrbgems/mruby-compiler/core/parse.y\nindex bf893fb..85150fc 100644\n--- a/mrbgems/mruby-compiler/core/parse.y\n+++ b/mrbgems/mruby-compiler/core/parse.y\n@@ -3953,7 +3953,7 @@ parse_string(parser_state *p)\n--len;\n}\n}\nif ((len-1 == hinf->term_len) && (strncmp(s, hinf->term, len-1) == 0)) {\nif ((len-1 == hinf->term_len) && (strncmp(s, hinf->term, len-1) == 0) && (hinf->term_len != 0)) { return tHEREDOC_END; } }\nWith the provided patch, MRuby correctly terminates with the POC and issues an error message very similar to the one in MRI:\ninfinite_heredoc.rb:3:0: can't find heredoc delimiter \"\" anywhere before EOF\ninfinite_heredoc.rb:3:0: syntax error, unexpected $end\nIn addition, all the tests pass.\n--\nDenis Kasak\nDamir Jeli\u0107\n\n",
  "severity": [
    8.6,
    null
  ],
  "bounty": 10000,
  "weaknesses": [
    "Uncontrolled Resource Consumption"
  ],
  "screenshots": {},
  "disclosed_date": 1484199420,
  "report_url": "https://hackerone.com/reports/187305",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Create a Ruby file named 'infinite_heredoc.rb' with the following content: <<''.a begin"
    ],
    [
      2,
      "Run the file using either 'mruby infinite_heredoc.rb' or 'sandbox infinite_heredoc.rb'"
    ]
  ],
  "vuln_description": "The vulnerability involves an infinite loop in MRuby's parser when handling heredocs with zero-length identifiers. This causes the process to become unresponsive to SIGTERM and requires termination via SIGABRT or SIGKILL. The issue stems from improper handling of heredoc identifiers in the parser, leading to an infinite loop when encountering an empty identifier.",
  "reason": "The vulnerability requires understanding of Ruby's heredoc syntax and parser behavior, but the attack itself is straightforward once the syntax quirk is known. The interaction between the heredoc identifier and parser state is subtle but not deeply complex.",
  "new_complexity": "MEDIUM",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null
}