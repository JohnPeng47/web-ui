{
  "reported_to": "Node.js third-party modules",
  "reported_by": "bayotop ",
  "title": "[html-janitor] Passing user-controlled data to clean() leads to XSS",
  "content": "\nModule:\nName: html-janitor\nVersion: 2.0.2\nSummary:\nPassing user-controlled data to the module's clean() function can result in arbitrary JS execution, because of unsafe DOM operations.\nThe description \"Cleans up your markup and allows you to take control of your HTML. HTMLJanitor uses a defined whitelist to limit HTML it is given to a defined subset.\" implies that \"dirty\" HTML is expected and therefore I would assume the clean method should never result in arbitrary JS being executed.\nDescription:\nThe following will result in JS execution:\nCode 114 Bytes\n1var myJanitor = new HTMLJanitor({tags:{p:{}}});\n2var cleanHtml = myJanitor.clean(\"<p><img src onerror=alert()><p>\")\nbecause of this code:\nCode 228 Bytes\n1HTMLJanitor.prototype.clean = function (html) {\n2    var sandbox = document.createElement('div'); // This is not a safe way to create a sandbox.\n3    sandbox.innerHTML = html; // At this point, the onerror in the img is triggered.\nRecommendation:\nThe \"sandbox\" should be created using safe browser APIs such as document.implementation.createHTMLDocument();.\nNote that I previously reported this issue at https://github.com/guardian/html-janitor/issues/34\nImpact\nGiven the module's description I would assume it should be used to prevent XSS vulnerabilities. This is currently a very dangerous assumption given that the module itself has a XSS vulnerability.\nNote that the author might have never intended to feed untrusted data into the clean() function. However, in that case this should be at least mentioned in the documentation, because other developers most certainly will use the package in such scenarios.\n\n",
  "severity": [
    9.8,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "Cross-site Scripting (XSS) - DOM"
  ],
  "screenshots": {},
  "disclosed_date": 1518206400,
  "report_url": "https://hackerone.com/reports/308155",
  "is_multi_component": true,
  "complexity": "HIGH",
  "novelty": "HIGH",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Create a new HTMLJanitor instance with a whitelist configuration: `var myJanitor = new HTMLJanitor({tags:{p:{}}});`"
    ],
    [
      2,
      "Call the clean() method with user-controlled HTML containing an XSS payload: `var cleanHtml = myJanitor.clean(\"<p><img src onerror=alert()><p>\");`"
    ]
  ],
  "vuln_description": "The html-janitor module's clean() function is vulnerable to XSS when processing user-controlled input because it uses an unsafe method (document.createElement) to create a DOM sandbox, allowing arbitrary JavaScript execution via attributes like onerror.",
  "reason": "The vulnerability is straightforward to discover as it involves a common XSS pattern (onerror handler) and the unsafe DOM operation is clearly visible in the source code. No complex interactions or state manipulations are required.",
  "new_complexity": "LOW",
  "requires_code": false,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "authnz_metadata": {
    "reason": "The vulnerability involves passing user-controlled data to the clean() function in the html-janitor module, which leads to XSS. This is a client-side issue and does not involve authentication or authorization checks between different user sessions or resources within the same application. The methodology described focuses on server-side AuthN/AuthZ issues by testing different user sessions and resource IDs, which is not applicable here.",
    "is_detectable": false
  },
  "injection_metadata": {
    "reasoning": "The vulnerability occurs when user-controlled data containing a simple XSS payload (e.g., `<img src onerror=alert()>`) is processed by html-janitor's `clean()` function. Since the payload is straightforward and requires no filter bypass, it would be included in a 'simple payload' list. The unsafe DOM operation in the library would execute the payload immediately upon parsing the HTML, making it detectable via same-channel analysis (e.g., observing script execution in the HTTP response or during regular navigation). The methodology would identify the parameter passing untrusted data to `clean()` as injectable and trigger the XSS during testing.",
    "is_simple_injection": true
  }
}