{
  "reported_to": "MTN Group",
  "reported_by": "rpbeast33 ",
  "title": "Java Debug Console Provides Command Injection Without Privellage Esclation",
  "content": "\nSummary:\nI intially found the debug console as a tool to insert arbitrary html/xss bugs, however after further probing the debug console it has some serious security flaws to allow arbitrary java code to be executed. My intial report of a seperate bug using this console, https://hackerone.com/reports/767077, uses the out.print functionality to write html code into the jsp page to perform a XSS attack. This intself is a dangerous bug for compromising users of the webapp. However, what is even more dangerous is allowing any abritratry java code to be executed on the server that an attacker controls. This is exactly what the debug console allows. The console spawns calls the execute.jsp page and then spawns a new .jsp page to give back to the user. Within this scope, the java code that the user/attacker writes is excuted on the server with the privellages given to the new .jsp file under the auspcies of the execute.jsp file. What does this mean? Well, an attacker can write custom .jsp files with native java code to do all sorts of malicous things, which includes Local File Inclusion and overwriting/changing source code - among other attacks.\nSteps To Reproduce:\nVisit: http://ptldynamicgame.mtn.sd/portal-api/tools/debug_console/index.jsp\nWrite any java code you want to be excuted:\nPoC Java Code:\nout.print(\"LOCAL FILE DATA\");\nout.print(\":\");%>\n<%@ page import=\"java.util.Random\"%>\n<%@ page import=\"java.io.*\"%>\n<%\nout.println(\"\\n\");\nFile file = new File(\"/etc/mime.types\");\nBufferedReader br = new BufferedReader(new FileReader(file));\nString st;\nwhile ((st = br.readLine()) != null)\n\n{ out.println(st); };%>\n<% out.println(\"Exit\");\nHere please note the custom import of java.io.* for file reading purposes.\nAs you can see, you can directly import native java code into the .jsp file by closing your opening tag %> and then using\nyour own custom <% %> tags afterwords. At the end also note the <% to ensure the floating tag from the template jsp is closed\nSupporting Material/References:\nAs stated in my intro, this is similar to my other reported bug found here https://hackerone.com/reports/767077 , but is actually quite different in its attack vector and impact. This represents a uniquely different bug due to the fact you are able to execute java code on the server and thus you are attacking the server rather than performing an XSS attack to target clients of the webapp. Overall, in my opinion these are two distinct bugs that just use the same console as its source. Also what is key to note is you do not have to get the current runtime enviroment of java to execute malicous commands, which in itself would be another crtical bug.\nImpact\nOverall the impact for this is critical. In my PoC I demonstrated how you can run attacker controlled java code to read local files, which in itself is a huge bug. However, the power of this bug comes from the ability to really craft the payload to do whatever an attacker desires on your site. Overall, this bug leads to Remote Code Execution which is critical to compromising a server.\n\n",
  "severity": [
    9.0,
    10.0
  ],
  "bounty": null,
  "weaknesses": [
    "Code Injection"
  ],
  "screenshots": {},
  "disclosed_date": 1595538180,
  "report_url": "https://hackerone.com/reports/767482",
  "is_multi_component": false,
  "complexity": "HIGH",
  "novelty": "MEDIUM",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "Visit: http://ptldynamicgame.mtn.sd/portal-api/tools/debug_console/index.jsp"
    ],
    [
      2,
      "Write any java code you want to be executed, for example: out.print(\"LOCAL FILE DATA\"); out.print(\":\");%> <%@ page import=\"java.util.Random\"%> <%@ page import=\"java.io.*\"%> <% out.println(\"\\n\"); File file = new File(\"/etc/mime.types\"); BufferedReader br = new BufferedReader(new FileReader(file)); String st; while ((st = br.readLine()) != null) { out.println(st); };%> <% out.println(\"Exit\");"
    ]
  ],
  "vuln_description": "The vulnerability allows an attacker to execute arbitrary Java code on the server through a debug console, leading to Remote Code Execution (RCE). This can be exploited to perform actions like reading local files, modifying source code, or other malicious activities without privilege escalation.",
  "reason": "The attack involves understanding how the debug console processes Java code and how to craft a payload that leverages JSP tags to execute arbitrary code. While the steps are straightforward, the discovery requires knowledge of Java and JSP execution contexts.",
  "new_complexity": "MEDIUM",
  "requires_code": false,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": "767077",
  "authnz_metadata": {
    "reason": "The vulnerability involves executing arbitrary Java code on the server through the debug console, which is not related to authentication or authorization bypass. The methodology described focuses on testing authorization boundaries by swapping user sessions and resource IDs, which does not apply to this server-side code execution vulnerability.",
    "is_detectable": false
  },
  "injection_metadata": {
    "reasoning": "The vulnerability involves injecting Java code directly into a debug console endpoint. The methodology's 'simple payload' approach would detect this because:\n1. The debug console endpoint (index.jsp) would be logged during HTTP request/response analysis.\n2. The parameter for code input is explicitly exposed, making it an injectable parameter.\n3. The payload (Java code) does not require filter bypasses or privilege escalation, aligning with 'simple payload' criteria.\n4. Execution results (e.g., file reads) are directly reflected in HTTP responses, satisfying 'same channel' detection.\nThe attack surface is explicitly exposed, and the payload is straightforward, making it detectable via basic parameter testing.",
    "is_simple_injection": true
  }
}