{
    "reported_to": "Node.js",
    "reported_by": "shogunpanda ",
    "title": "Denial of Service by resource exhaustion CWE-400 due to unfinished HTTP/1.1 requests",
    "content": "\nSummary: Node.js is vulnerable to HTTP denial of service (DOS) attacks based on delayed requests submission which can make the server unable to accept new connections.\nDescription:\nAn attacker can open an arbitrary number of HTTP connections and keep the server busy by never completing the request phase.\nNode.js only has two requests timeouts:\nserver.timeout that controls the maximum number of milliseconds the socket can be idle. This also includes the server processing time.\nserver.headersTimeout (Added in Node 11.3.0), that controls the maximum number of milliseconds allowed to receive the full request headers before timing out.\nHandling of request bodies is specific to the application code and core Node.js never consumes or parses the request bodies.\nCurrently, the body parsing and handling is performed by the following modules:\nfastify\nrestify\nbusboy, used by fastify-multpart and multer\nraw-body, used by body-parser\nAll of the modules above are vulnerable to the attack.\nIf part of the body is already sent, the body parsing modules above can be patched to impose a request body sending timeout and therefore mitigate the attack.\nThe application unfortunately can not completely handle this attack. If the attacker never starts sending the body after completing the submission of the headers, the application code is never invoked.\nPrior to Node.js 13.0.0, the default timeout for a request was 2 minutes, which is a countermeasure against this attack.\nStarting with Node.js 13.0.0 instead, the default timeout has been changed to be 0 (which means no timeout) in order to address serverless deployments where long running requests are needed. Since the socket is never considered idle, the application is completely vulnerable to the attack.\nWhile server.headersTimeout is able to detect a slow request, it is only effective if the delay happens during the headers phase (like in Slowloris attacks). If the attacker delays the start of the headers, the start of body sending or sends the body very slow without resulting in an idle socket, the attack is not detected.\nIn the long run an unprotected server will have a lot of pending requests to handle. At some point it will reach the open connections limit and therefore will not be able to serve additional requests, resulting in a Denial of Service.\nSteps To Reproduce:\nFrom one or more attacking sources, open one or more HTTP connections to the target server\nFor each of the connection in step 1 2.1. (Optional) Wait a certain amount of time before sending the first request header. 2.2 Send all request headers with regular pausing. 2.3 (Optional) Wait a certain amount of time before sending the body data. 2.4. Send the request body with regular pausing.\nAll the substeps must be performed by sending periodically the smallest amount of data with the highest delay such that the server does not detect an idle socket. For Node 13.0.0 and above there is no idle timeout by default, so the attacker can wait an arbitrary time. For Node.js prior to 13.0.0, at least one byte each 2 minutes must be sent.\nWe have tested the following test cases:\nConnection established, none or partial headers sent then sending is paused: If server.timeout is not 0, then idle detection is triggered and closes the connection with no response. With the default timeout of 0 in Node.js 13.0.0 and above, the server is completely vulnerable to the attack.\nConnection established, headers sent with long delays: server.headersTimeout is triggered and closes the connection with no response.\nConnection established, headers sent and sending is paused before starting the body: If server.timeout is not 0, then idle detection is triggered and closes the connection with no response. With the default timeout of 0 in Node.js 13.0.0 and above, the server is completely vulnerable to the attack.\nConnection established, headers sent, body sent with long delays: server.timeout is not able to detect the attack and the server is completely vulnerable to the attack.\nWhat follows is a sample code which reproduces the problem.\nCode 1.06 KiB\n1const { createConnection } = require('net')\n2\n3let start\n4let response = ''\n5let body = ''.padEnd(4096, '123')\n6\n7const client = createConnection({ port: parseInt(process.argv[2], 10) }, () => {\n8  start = process.hrtime.bigint()\n9\n10  // Send all the headers quickly so that server.headersTimeout is not triggered\n11  client.write('POST / HTTP/1.1\\r\\n')\n12  client.write('Content-Type: text/plain\\r\\n')\n13  client.write(`Content-Length: ${Buffer.byteLength(body)}\\r\\n`)\n14  client.write(`\\r\\n`)\n15\n16  // Send the body very slower but in away that the server.timeout is not triggered\n17  let i = 0\n18  let interval = setInterval(() => {\n19    client.write(body[i])\n20    i++\n21\n22    // Done sending, end the request\n23    if (i === body.length) {\n24      clearInterval(interval)\n25      client.write(`\\r\\n\\r\\n`)\n26    }\n27  }, 60000)\n28})\n29\n30client.on('data', data => {\n31  response += data\n32  client.end()\n33})\n34\n35client.on('close', () => {\n36  const duration = Number(process.hrtime.bigint() - start) / 1e9\n37\n38  console.log(`Receive the following response (${response.length} bytes) in ${duration.toFixed(3)} s:\\n\\n`)\n39  console.log(response)\n40})\nOnce executed, the client will not receive a response before 4096 minutes. If multiple parallel execution of the code above targets the same server, it will result in service denial.\nImpact\nThis attack has very low complexity and can easily trigger a DDOS on an unprotected server.\nSupporting Material/References:\nWe have written a patch for Node.js (PR 33304) which introduces a new http.Server option called requestTimeout with a default value in milliseconds of 120000 (2 minutes).\nWhen requestTimeout is a positive value, the server will start a new timer set to expire in requestTimeout milliseconds when a new connection is established. The timer is also set again if new requests after the first are received on the socket (this handles pipelining and keep-alive cases).\nThe timer is cancelled in the following case:\nWhen the request body is completely received by the server.\nWhen the response is completed. This handles the case where the application responds to the client without consuming the request body.\nWhen the connection is upgraded, like in the WebSocket case.\nIf the timer expires, then the server responds with status code 408 and closes the connection. This prevents the DOS attack.\nAcknowledgement\nThis research was conducted and co-authored by me and matteo.collina@nearform.com and has been sponsored by NearForm\nImpact\nIf an attacker execute a significative amount of requests on a target server without completing any, the server at some point will reach the allowed number of open connections and will not be able to serve any further request, resulting in a Denial of Service.\n\n",
    "severity": [
        9.3,
        null
    ],
    "bounty": 250,
    "weaknesses": [
        "Uncontrolled Resource Consumption"
    ],
    "screenshots": {},
    "disclosed_date": 1602977040,
    "report_url": "https://hackerone.com/reports/868834",
    "is_multi_component": true,
    "complexity": "LOW",
    "novelty": "LOW",
    "vuln_category": "CODE",
    "steps": [
        [
            1,
            "From one or more attacking sources, open one or more HTTP connections to the target server"
        ],
        [
            2,
            "For each connection, perform the following steps: 2.1. (Optional) Wait before sending headers; 2.2 Send headers with pauses; 2.3 (Optional) Wait before sending body; 2.4. Send body with pauses, ensuring the server does not detect an idle socket"
        ]
    ],
    "vuln_description": "Node.js is vulnerable to HTTP denial of service (DOS) attacks where an attacker can open multiple connections and keep them open by never completing the request phase, exhausting server resources and preventing new connections.",
    "reason": "The attack involves understanding HTTP protocol timing, Node.js server configurations (timeouts), and subtle interactions between request phases and server timeouts. While the concept of slow requests is known, the specific exploitation in Node.js versions (especially post-13.0.0) requires awareness of default timeout changes and their impact.",
    "new_complexity": "MEDIUM",
    "requires_code": false,
    "requires_CVE": false,
    "is_ctf": false,
    "other_report": null
}