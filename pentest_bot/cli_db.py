#!/usr/bin/env python
"""PentestBot SQLite CLI

A light‑weight, zero‑dependency command‑line utility for exploring the
`pentest_bot.sqlite` database.  It provides a Windows‑friendly ASCII
interface that also works unmodified on Linux/OS X terminals.

Usage examples
--------------
List the most recent 10 runs (default)::

    python pentest_cli.py list-runs

List ALL runs::

    python pentest_cli.py list-runs --all

Display a specific run together with its child ``PentestResult`` rows::

    python pentest_cli.py show-run 42

Point to a custom database file::

    python pentest_cli.py list-runs --db path/to/alt.sqlite

This module assumes that the schema definitions (``Run``/``PentestResult``)
reside in a sibling module named ``pentest_db.py``.  Adjust
``DB_MODULE`` below if your file is named differently.
"""
from __future__ import annotations

from argparse import ArgumentParser, Namespace
from contextlib import contextmanager
from datetime import datetime
from importlib import import_module
from pathlib import Path
from typing import Iterable, List, Sequence

# ---------------------------------------------------------------------------
# Configuration – tweak these to match local layout
# ---------------------------------------------------------------------------
DB_MODULE = "pentest_bot.db"  # file that defines `engine`, `SessionLocal`, `Run`, …
DEFAULT_DB_FILE = Path(__file__).with_name("pentest_bot.sqlite")

# ---------------------------------------------------------------------------
# Helper: lazy‑import the application DB module
# ---------------------------------------------------------------------------
_db_cache = {}


def _load_db(db_path: Path):
    """Return (SessionLocal, Run, PentestResult) from the target database.

    The function monkey‑patches the underlying SQLAlchemy ``engine`` so that
    we can reuse the ORM models with **any** SQLite file chosen at runtime.
    """
    if db_path in _db_cache:
        return _db_cache[db_path]

    db_mod = import_module(DB_MODULE)

    # Monkey‑patch the engine used by the ORM.  This avoids having to fork the
    # schema definitions for each database file.
    from sqlalchemy import create_engine

    db_mod.engine.dispose()  # close previous connections, if any
    db_mod.engine = create_engine(f"sqlite:///{db_path}", connect_args={"check_same_thread": False})
    db_mod.SessionLocal.configure(bind=db_mod.engine)  # type: ignore[attr-defined]

    _db_cache[db_path] = (db_mod.SessionLocal, db_mod.Run, db_mod.PentestResult)
    return _db_cache[db_path]


@contextmanager
def _session_ctx(db_path: Path):
    SessionLocal, _, _ = _load_db(db_path)
    session = SessionLocal()
    try:
        yield session
    finally:
        session.close()


# ---------------------------------------------------------------------------
# Plain‑ASCII table formatter (Windows‑friendly, no fancy Unicode)
# ---------------------------------------------------------------------------

def _build_table(rows: Sequence[Sequence[str]], headers: Sequence[str] | None = None) -> str:
    """Return an ASCII table as a single string.

    The function calculates column widths from the *longest* cell in each
    column and then draws the grid using ``+``/``-``/``|`` glyphs which render
    correctly even in the Windows 10/11 default console font.
    """
    if not rows and not headers:
        return "<empty>"

    # Ensure we have at least one row to compute widths
    sample = rows[0] if rows else ["" for _ in headers]  # type: ignore[arg-type]
    col_count = len(headers or sample)

    widths: List[int] = [0] * col_count
    for col_idx in range(col_count):
        header_len = len(headers[col_idx]) if headers else 0  # type: ignore[index]
        max_cell = max((len(r[col_idx]) for r in rows), default=0)
        widths[col_idx] = max(header_len, max_cell)

    def _separator(char: str = "-") -> str:
        return "+" + "+".join(char * (w + 2) for w in widths) + "+"

    def _format_row(row: Sequence[str]) -> str:
        return "| " + " | ".join(cell.ljust(widths[i]) for i, cell in enumerate(row)) + " |"

    parts: List[str] = [
        _separator(),
    ]
    if headers:
        parts.append(_format_row(headers))
        parts.append(_separator("="))
    for r in rows:
        parts.append(_format_row(r))
        parts.append(_separator())
    return "\n".join(parts)


# ---------------------------------------------------------------------------
# CLI commands
# ---------------------------------------------------------------------------

def _human_ts(ts: datetime | None) -> str:
    return ts.strftime("%Y-%m-%d %H:%M:%S") if ts else "—"


def list_runs_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    limit = None if args.all else args.limit

    with _session_ctx(db_path) as session:
        SessionLocal, Run, _ = _load_db(db_path)  # noqa: N806  (PascalCase from ORM)
        qry = session.query(Run).order_by(Run.created_at.desc())
        if limit is not None:
            qry = qry.limit(limit)
        rows = [
            [
                str(run.id),
                _human_ts(run.created_at),
                run.comment or "",
                run.parent_logdir,
                Path(run.log_filepath).name,
                str(len(run.results)),
            ]
            for run in qry.all()
        ]

    headers = ["ID", "Created", "Comment", "LogDir", "LogFile", "#Results"]
    print(_build_table(rows, headers))


def show_run_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    run_id = args.run_id

    with _session_ctx(db_path) as session:
        _, Run, PentestResult = _load_db(db_path)  # noqa: N806
        run = session.query(Run).filter(Run.id == run_id).first()
        if run is None:
            print(f"[!] Run ID {run_id} not found in {db_path}")
            return

        # Render parent Run row as a key/value table
        run_rows = [
            ["ID", str(run.id)],
            ["Created", _human_ts(run.created_at)],
            ["Comment", run.comment or ""],
            ["Parent LogDir", run.parent_logdir],
            ["Log File", run.log_filepath],
            ["# Results", str(len(run.results))],
        ]
        print("RUN SUMMARY")
        print(_build_table(run_rows))
        print()

        # Child PentestResults table
        res_rows = [
            [
                str(r.id),
                r.eval_name,
                "✔" if r.success else "✘",
                f"{r.steps}/{r.max_steps}",
                r.model_name,
                f"{r.model_costs:.4f}",
                _human_ts(r.created_at),
            ]
            for r in run.results
        ]
        if res_rows:
            print("RESULTS")
            headers = [
                "ID",
                "Eval Name",
                "Ok?",
                "Steps",
                "Model",
                "Cost ($)",
                "Created",
            ]
            print(_build_table(res_rows, headers))
        else:
            print("<no child PentestResult rows>")


# ---------------------------------------------------------------------------
# Argument parsing & main entry‑point
# ---------------------------------------------------------------------------

def _build_parser() -> ArgumentParser:
    p = ArgumentParser(description="ASCII CLI for PentestBot SQLite database")
    p.add_argument("--db", help="Path to alternate pentest_bot.sqlite file")

    sub = p.add_subparsers(dest="cmd", required=True)

    # list‑runs ------------------------------------------------------------- #
    list_p = sub.add_parser("list-runs", help="List recent runs")
    list_p.set_defaults(func=list_runs_cmd)
    list_p.add_argument("--all", action="store_true", help="Show *all* runs (ignore --limit)")
    list_p.add_argument("--limit", type=int, default=10, help="Max rows (default: 10)")

    # show‑run -------------------------------------------------------------- #
    show_p = sub.add_parser("show-run", help="Show a single run in detail")
    show_p.set_defaults(func=show_run_cmd)
    show_p.add_argument("run_id", type=int, help="ID of the Run to display")

    return p


def main(argv: Sequence[str] | None = None) -> None:  # pragma: no‑cover
    parser = _build_parser()
    args = parser.parse_args(argv)
    args.func(args)  # type: ignore[attr-defined]


if __name__ == "__main__":  # pragma: no‑cover
    main()
