from pathlib import Path
import threading

from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.engine import Engine
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from contextlib import contextmanager
from typing import Iterator

from sqlalchemy.orm import Session


Base = declarative_base()

# ---------------------------------------------------------------------------
_DB_FILE = Path(__file__).parent.parent / "pentest_bot.sqlite"
# SQLite is included with CPython so we do not need an external runtime
_SQLITE_URL = f"sqlite:///{_DB_FILE}"

_LOCK = threading.Lock()
_ENGINE: Engine | None = None
SessionLocal: sessionmaker[Session] | None = None


def get_engine() -> Engine:
    """Return a process‑wide Engine instance (thread‑safe lazy singleton)."""
    global _ENGINE, SessionLocal
    if _ENGINE is None:
        with _LOCK:            # double‑checked locking
            if _ENGINE is None:
                _ENGINE = create_engine(
                    _SQLITE_URL,
                    connect_args={"check_same_thread": False},
                    pool_pre_ping=True,          # good default
                    echo=False,
                )
                # build Session maker once
                SessionLocal = sessionmaker(bind=_ENGINE, autoflush=False, expire_on_commit=False)
    return _ENGINE


@contextmanager
def get_session() -> Iterator[Session]:
    """Yield a scoped session and guarantee close/rollback."""
    if SessionLocal is None:          # first call triggers engine creation
        get_engine()
    assert SessionLocal is not None
    db: Session = SessionLocal()      # type: ignore
    try:
        yield db
        db.commit()
    except Exception:                 # rollback on error
        db.rollback()
        raise
    finally:
        db.close()
