import json
from contextlib import contextmanager
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, Generator, Iterator

from sqlalchemy import func, case, Boolean, Column, DateTime, Float, Integer, String, ForeignKey, create_engine
from sqlalchemy.engine import Engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import Session, sessionmaker, relationship

from pentest_bot.web_exploit.agent_step import AgentContext
from pentest_bot.db import Base
from pentest_bot.db.utils import current_date

class PentestResultORM(Base):
    """ORM model that stores the outcome of a single PentestBot run."""

    __tablename__ = "pentest_results"

    id = Column(Integer, primary_key=True, autoincrement=True)
    run_id = Column(Integer, ForeignKey("runs.id", ondelete="CASCADE"), nullable=False)
    eval_name = Column(String, index=True, nullable=False)
    success = Column(Boolean, default=False, nullable=False)
    steps = Column(Integer, nullable=False)
    max_steps = Column(Integer, nullable=False)
    model_name = Column(String, nullable=False)
    model_costs = Column(Float, nullable=False)
    log_filepath = Column(String, nullable=False)
    created_at = Column(DateTime, default=current_date, nullable=False)

    # relationship back-reference
    run = relationship("RunORM", back_populates="results")
    # relationship to agent steps
    agent_steps = relationship("AgentStepORM", back_populates="pentest_result", cascade="all, delete-orphan")

class AgentStepORM(Base):
    """ORM model that stores individual agent steps within a PentestResult."""

    __tablename__ = "agent_steps"

    id = Column(Integer, primary_key=True, autoincrement=True)
    pentest_result_id = Column(Integer, ForeignKey("pentest_results.id", ondelete="CASCADE"), nullable=False)
    step_number = Column(Integer, nullable=False)
    reflection = Column(String, nullable=False)
    script = Column(String, nullable=False)
    execution_output = Column(String, nullable=False)
    step_type = Column(String, nullable=True)
    add_to_scratchpad = Column(String, nullable=True)
    created_at = Column(DateTime, default=current_date, nullable=False)

    # relationship back-reference
    pentest_result = relationship("PentestResultORM", back_populates="agent_steps")


class RunORM(Base):
    """Represents a logical run containing 1-N `PentestResult`."""

    __tablename__ = "runs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    created_at = Column(DateTime, default=current_date, nullable=False)
    comment = Column(String, nullable=True)
    parent_logdir = Column(String, nullable=False)
    is_eval = Column(Boolean, default=False, nullable=False)

    # collection of associated results
    results = relationship("PentestResultORM", back_populates="run", cascade="all, delete-orphan")


# ---------------------------------------------------------------------
# Query helpers (all accept an active SQLAlchemy Session)
# ---------------------------------------------------------------------
def get_runs_summary(
    session,
    *,
    limit: int | None = None,
    eval_only: bool = True,
):
    """
    Return one row per Run with aggregate success / step counts.

    Each row is a SimpleNamespace with attributes:
        id, created_at, comment, parent_logdir,
        total_results, successes, total_steps
    """
    qry = (
        session.query(
            RunORM.id.label("id"),
            RunORM.created_at.label("created_at"),
            RunORM.comment.label("comment"),
            RunORM.parent_logdir.label("parent_logdir"),
            func.count(PentestResultORM.id).label("total_results"),
            func.sum(
                case((PentestResultORM.success.is_(True), 1), else_=0)
            ).label("successes"),
            func.sum(PentestResultORM.steps).label("total_steps"),
        )
        .outerjoin(PentestResultORM)
        .group_by(RunORM.id)
        .order_by(RunORM.created_at.desc())
    )
    if eval_only:
        qry = qry.filter(RunORM.is_eval.is_(True))
    if limit is not None:
        qry = qry.limit(limit)
    return qry.all()


def get_run(session, run_id: int):
    """Return the Run ORM object (or None if not found)."""
    return session.query(RunORM).filter(RunORM.id == run_id).first()


def get_agent_ctxt(session, result_id: int) -> AgentContext | None:
    """Return a list of AgentStep objects (sorted) or None if missing."""
    res = session.query(PentestResultORM).filter(
        PentestResultORM.id == result_id
    ).first()
    if res is None:
        return None
    
    return AgentContext.from_db(sorted(res.agent_steps, key=lambda s: s.step_number))

def get_cost_summary(session):
    """
    Compute usageâ€‘cost statistics.

    Returns:
        today_cost, week_cost, per_model_rows
    where per_model_rows is a list of
        (model_name, total_cost, total_steps, avg_per_step)
    """
    now = datetime.utcnow()
    today_start = datetime(now.year, now.month, now.day)
    tomorrow_start = today_start + timedelta(days=1)

    monday_start = today_start - timedelta(days=today_start.weekday())
    next_monday = monday_start + timedelta(days=7)

    today_cost = session.query(
        func.coalesce(func.sum(PentestResultORM.model_costs), 0.0)
    ).filter(
        PentestResultORM.created_at >= today_start,
        PentestResultORM.created_at < tomorrow_start,
    ).scalar()

    week_cost = session.query(
        func.coalesce(func.sum(PentestResultORM.model_costs), 0.0)
    ).filter(
        PentestResultORM.created_at >= monday_start,
        PentestResultORM.created_at < next_monday,
    ).scalar()

    per_model_raw = (
        session.query(
            PentestResultORM.model_name.label("model"),
            func.sum(PentestResultORM.model_costs).label("total_cost"),
            func.sum(PentestResultORM.steps).label("total_steps"),
        )
        .group_by(PentestResultORM.model_name)
        .all()
    )

    per_model_rows = []
    for row in per_model_raw:
        total_cost = float(row.total_cost or 0.0)
        total_steps = int(row.total_steps or 0)
        avg = total_cost / total_steps if total_steps else 0.0
        per_model_rows.append((row.model, total_cost, total_steps, avg))

    return today_cost, week_cost, per_model_rows


def delete_run(session, run_id: int):
    """Delete a Run and all associated PentestResults and AgentSteps.
    
    Returns:
        True if the run was found and deleted, False if not found.
    """
    run = session.query(RunORM).filter(RunORM.id == run_id).first()
    if run is None:
        return False
    
    session.delete(run)
    session.commit()
    return True
