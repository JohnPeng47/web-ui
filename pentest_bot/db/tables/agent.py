from datetime import datetime, timedelta
from typing import List, Optional, Tuple

from sqlalchemy import (
    Boolean,
    Column,
    DateTime,
    Float,
    ForeignKey,
    Integer,
    String,
    case,
    func,
)
from sqlalchemy.orm import Session, relationship, joinedload

from pentest_bot.db import Base
from pentest_bot.db.utils import current_date
from pentest_bot.models.steps import AgentContext

class PentestResultORM(Base):
    __tablename__ = "pentest_results"

    id = Column(Integer, primary_key=True, autoincrement=True)
    run_id = Column(Integer, ForeignKey("runs.id", ondelete="CASCADE"), nullable=False)
    eval_name = Column(String, index=True, nullable=False)
    success = Column(Boolean, default=False, nullable=False)
    steps = Column(Integer, nullable=False)
    max_steps = Column(Integer, nullable=False)
    model_name = Column(String, nullable=False)
    model_costs = Column(Float, nullable=False)
    log_filepath = Column(String, nullable=False)
    created_at = Column(DateTime, default=current_date, nullable=False)

    run = relationship("RunORM", back_populates="results")
    agent_steps = relationship(
        "AgentStepORM", back_populates="pentest_result", cascade="all, delete-orphan"
    )

    result_groups = relationship(
        "ResultsGroupId",
        back_populates="pentest_result",
        cascade="all, delete-orphan",
    )

    opik_prompt_name = Column(String, nullable=True)
    opik_prompt_commit = Column(String, nullable=True)


class ResultsGroupId(Base):
    """
    One row per logical (pentest_result_id, group_id) “step group”.
    The Opik prompt metadata now lives here, instead of on each AgentStep.
    """

    __tablename__ = "results_group_ids"

    id = Column(Integer, primary_key=True, autoincrement=True)
    pentest_result_id = Column(
        Integer, ForeignKey("pentest_results.id", ondelete="CASCADE"), nullable=False
    )
    group_id = Column(Integer, nullable=False, index=True)
    created_at = Column(DateTime, default=current_date, nullable=False)

    # moved from AgentStepORM:
    opik_prompt_name = Column(String, nullable=True)
    opik_prompt_commit = Column(String, nullable=True)

    pentest_result = relationship("PentestResultORM", back_populates="result_groups")
    steps = relationship(
        "AgentStepORM", back_populates="group", cascade="all, delete-orphan"
    )


class AgentStepORM(Base):
    __tablename__ = "agent_steps"

    id = Column(Integer, primary_key=True, autoincrement=True)
    pentest_result_id = Column(
        Integer, ForeignKey("pentest_results.id", ondelete="CASCADE"), nullable=False
    )

    # keep the simple integer group_id for now (back-compat / fast filters)
    group_id = Column(Integer, default=0, nullable=False, index=True)

    # NEW: FK to the new group table
    results_group_id = Column(
        Integer,
        ForeignKey("results_group_ids.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )

    step_number = Column(Integer, nullable=False)
    reflection = Column(String, nullable=False)
    script = Column(String, nullable=False)
    execution_output = Column(String, nullable=False)
    step_type = Column(String, nullable=True)
    add_to_scratchpad = Column(String, nullable=True)
    created_at = Column(DateTime, default=current_date, nullable=False)

    pentest_result = relationship("PentestResultORM", back_populates="agent_steps")
    group = relationship("ResultsGroupId", back_populates="steps")

class RunORM(Base):
    __tablename__ = "runs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    created_at = Column(DateTime, default=current_date, nullable=False)
    comment = Column(String, nullable=True)
    parent_logdir = Column(String, nullable=False)
    is_eval = Column(Boolean, default=False, nullable=False)

    results = relationship(
        "PentestResultORM", back_populates="run", cascade="all, delete-orphan"
    )


# ---------------------------------------------------------------------
# Create/modify helpers
# ---------------------------------------------------------------------


def create_run(
    session: Session,
    *,
    comment: str | None,
    parent_logdir: str,
    is_eval: bool = False,
) -> int:
    """Insert a new ``Run`` record and return its primary-key ID.

    The caller is responsible for managing the surrounding SQLAlchemy
    transaction (i.e. committing/rolling back).  We therefore *only*
    ``flush`` here to guarantee that the autoincremented primary key is
    populated before returning.
    """
    run_rec = RunORM(
        comment=comment,
        parent_logdir=parent_logdir,
        is_eval=is_eval,
    )
    session.add(run_rec)
    session.flush()  # assign PK without committing
    session.refresh(run_rec)
    return run_rec.id


def create_pentest_result(
    session: Session,
    *,
    run_id: int,
    eval_name: str,
    success: bool,
    steps: int,
    max_steps: int,
    model_name: str,
    model_costs: float,
    log_filepath: str,
    opik_prompt_name: str,
    opik_prompt_commit: str,
) -> int:
    """Insert a ``PentestResult`` row and return its ID."""
    pentest_result = PentestResultORM(
        run_id=run_id,
        eval_name=eval_name,
        success=success,
        steps=steps,
        max_steps=max_steps,
        model_name=model_name,
        model_costs=model_costs,
        log_filepath=log_filepath,
        opik_prompt_name=opik_prompt_name,
        opik_prompt_commit=opik_prompt_commit,
    )
    session.add(pentest_result)
    session.flush()
    session.refresh(pentest_result)
    return pentest_result.id


def create_agent_steps(
    session: Session,
    agent_steps: List,
    step_types: Optional[List] | None,
    result_id: int,
    opik_prompt_name: str,
    opik_prompt_commit: str,
    *,
    group_id: int = 0,
) -> None:
    """
    Bulk-insert the individual AgentStep records for a result.
    Now stores Opik prompt info on ResultsGroupId instead of AgentStepORM.
    """
    if not step_types:
        step_types = [None] * len(agent_steps)

    # get or create the group row
    group_row = (
        session.query(ResultsGroupId)
        .filter(
            ResultsGroupId.pentest_result_id == result_id,
            ResultsGroupId.group_id == group_id,
        )
        .one_or_none()
    )
    if group_row is None:
        group_row = ResultsGroupId(
            pentest_result_id=result_id,
            group_id=group_id,
            opik_prompt_name=opik_prompt_name,
            opik_prompt_commit=opik_prompt_commit,
        )
        session.add(group_row)
        session.flush()
        session.refresh(group_row)
    else:
        # keep group-row metadata in sync if provided
        if (
            group_row.opik_prompt_name != opik_prompt_name
            or group_row.opik_prompt_commit != opik_prompt_commit
        ):
            group_row.opik_prompt_name = opik_prompt_name
            group_row.opik_prompt_commit = opik_prompt_commit

    for idx, (step, step_type) in enumerate(zip(agent_steps, step_types), start=1):
        session.add(
            AgentStepORM(
                pentest_result_id=result_id,
                results_group_id=group_row.id,
                step_number=idx,
                reflection=step.reflection,
                script=step.script,
                add_to_scratchpad=getattr(step, "add_to_scratchpad", None),
                step_type=getattr(step_type, "type", None).value if step_type else None,
                execution_output=step.execution_output,
                group_id=group_id,
            )
        )


def run_has_results(session: Session, run_id: int) -> bool:
    """Return ``True`` if the specified run already has any results."""
    return (
        session.query(PentestResultORM)
        .filter(PentestResultORM.run_id == run_id)
        .first()
        is not None
    )


# ---------------------------------------------------------------------
# Query helpers (all accept an active SQLAlchemy Session)
# ---------------------------------------------------------------------
def get_runs_summary(
    session,
    *,
    limit: int | None = None,
    eval_only: bool = True,
):
    """
    Return one row per Run with aggregate success / step counts.

    Each row is a SimpleNamespace with attributes:
        id, created_at, comment, parent_logdir,
        total_results, successes, total_steps
    """
    qry = (
        session.query(
            RunORM.id.label("id"),
            RunORM.created_at.label("created_at"),
            RunORM.comment.label("comment"),
            RunORM.parent_logdir.label("parent_logdir"),
            func.count(PentestResultORM.id).label("total_results"),
            func.sum(case((PentestResultORM.success.is_(True), 1), else_=0)).label(
                "successes"
            ),
            func.sum(PentestResultORM.steps).label("total_steps"),
        )
        .outerjoin(PentestResultORM)
        .group_by(RunORM.id)
        .order_by(RunORM.created_at.desc())
    )
    if eval_only:
        qry = qry.filter(RunORM.is_eval.is_(True))
    if limit is not None:
        qry = qry.limit(limit)
    return qry.all()


def get_run(session, run_id: int):
    """Return the Run ORM object (or None if not found)."""
    return session.query(RunORM).filter(RunORM.id == run_id).first()


def get_agent_ctxt(
    session: Session,
    result_id: int,
    *,
    group_id: int = 0,
) -> AgentContext | None:
    """
    Build an AgentContext from the agent steps that belong to a given group
    (defaults to group 0). Returns None if the result or the group is missing.
    """
    res = (
        session.query(PentestResultORM).filter(PentestResultORM.id == result_id).first()
    )
    if res is None:
        return None

    steps = [s for s in res.agent_steps if s.group_id == group_id]
    if not steps:
        return None

    steps.sort(key=lambda s: s.step_number)
    return AgentContext.from_db(steps)


def get_cost_summary(session):
    """
    Compute usage‑cost statistics.

    Returns:
        today_cost, week_cost, per_model_rows
    where per_model_rows is a list of
        (model_name, total_cost, total_steps, avg_per_step)
    """
    now = datetime.utcnow()
    today_start = datetime(now.year, now.month, now.day)
    tomorrow_start = today_start + timedelta(days=1)

    monday_start = today_start - timedelta(days=today_start.weekday())
    next_monday = monday_start + timedelta(days=7)

    today_cost = (
        session.query(func.coalesce(func.sum(PentestResultORM.model_costs), 0.0))
        .filter(
            PentestResultORM.created_at >= today_start,
            PentestResultORM.created_at < tomorrow_start,
        )
        .scalar()
    )

    week_cost = (
        session.query(func.coalesce(func.sum(PentestResultORM.model_costs), 0.0))
        .filter(
            PentestResultORM.created_at >= monday_start,
            PentestResultORM.created_at < next_monday,
        )
        .scalar()
    )

    per_model_raw = (
        session.query(
            PentestResultORM.model_name.label("model"),
            func.sum(PentestResultORM.model_costs).label("total_cost"),
            func.sum(PentestResultORM.steps).label("total_steps"),
        )
        .group_by(PentestResultORM.model_name)
        .all()
    )

    per_model_rows = []
    for row in per_model_raw:
        total_cost = float(row.total_cost or 0.0)
        total_steps = int(row.total_steps or 0)
        avg = total_cost / total_steps if total_steps else 0.0
        per_model_rows.append((row.model, total_cost, total_steps, avg))

    return today_cost, week_cost, per_model_rows


def delete_run(session, run_id: int):
    """Delete a Run and all associated PentestResults and AgentSteps.

    Returns:
        True if the run was found and deleted, False if not found.
    """
    run = session.query(RunORM).filter(RunORM.id == run_id).first()
    if run is None:
        return False

    session.delete(run)
    session.commit()
    return True


def get_agent_steps(session: Session, result_id: int):
    """Return **all** step-groups for the given ``PentestResult``.

    The function loads *every* ``ResultsGroupId`` that belongs to
    ``result_id`` (ordered by ``group_id``) and eagerly fetches their
    ``AgentStep`` rows.  Each list of steps is returned **together with**
    the group-level Opik prompt metadata so that callers can display /
    compare label information.

    Returns
    -------
    List[Tuple[ResultsGroupId, List[AgentStepORM]]]
        For each group a 2-tuple containing the ``ResultsGroupId`` ORM
        instance (so the caller has direct access to ``group_id``,
        ``opik_prompt_name`` and ``opik_prompt_commit``) **and** an
        *ordered* list of ``AgentStepORM`` objects for that group.

    Notes
    -----
    • If the ``result_id`` does not exist an empty list is returned.
    • The steps in the inner lists are ordered by ``step_number`` to make
      rendering predictable.
    """

    # Validate parent result first – short-circuit if it does not exist
    pentest_result = (
        session.query(PentestResultORM).filter(PentestResultORM.id == result_id).first()
    )
    if pentest_result is None:
        return []  # type: ignore[return-value]

    # Collect all step-groups for the result (could be 0-n groups)
    groups: List[ResultsGroupId] = (
        session.query(ResultsGroupId)
        .filter(ResultsGroupId.pentest_result_id == result_id)
        .order_by(ResultsGroupId.group_id.asc())
        .all()
    )

    out = []
    for grp in groups:
        # Eagerly load steps for the group and sort by step_number
        steps: List[AgentStepORM] = (
            session.query(AgentStepORM)
            .filter(AgentStepORM.results_group_id == grp.id)
            .order_by(AgentStepORM.step_number.asc())
            .all()
        )
        out.append((grp, steps))

    return out

def get_agent_results_by_evalname(
    session: Session,
    eval_name: str,
    n: int = 5,
    *,
    eager: bool = False,
) -> List[PentestResultORM]:
    """
    Return the n most recent PentestResult rows for a given eval_name.

    Parameters
    ----------
    session : Session
        Active SQLAlchemy session.
    eval_name : str
        The eval_name to filter on.
    n : int, default 5
        Max number of rows to return.
    eager : bool, default False
        If True, eagerly loads agent_steps and result_groups (and their steps)
        to avoid N+1 queries when you immediately traverse them.

    Returns
    -------
    List[PentestResultORM]
    """
    qry = (
        session.query(PentestResultORM)
        .filter(PentestResultORM.eval_name == eval_name)
        .order_by(PentestResultORM.created_at.desc(), PentestResultORM.id.desc())
        .limit(n)
    )

    if eager:
        qry = (
            qry.options(
                joinedload(PentestResultORM.agent_steps),
                joinedload(PentestResultORM.result_groups)
                .joinedload(ResultsGroupId.steps)
            )
        )

    return qry.all()


def _recompute_steps_for_result(session: Session, result_id: int) -> int:
    """
    Recompute and persist PentestResultORM.steps from the remaining AgentStep rows.
    Returns the new steps count.
    """
    new_steps = (
        session.query(func.count(AgentStepORM.id))
        .filter(AgentStepORM.pentest_result_id == result_id)
        .scalar()
        or 0
    )
    pr = session.query(PentestResultORM).filter(PentestResultORM.id == result_id).one_or_none()
    if pr is not None:
        pr.steps = new_steps
    return new_steps


def delete_result_group(
    session: Session,
    result_id: int,
    group_id: int,
    *,
    recompute_steps: bool = True,
    delete_empty_result: bool = False,
) -> bool:
    """
    Delete *all* ResultsGroupId rows (and their AgentStep rows via ON DELETE CASCADE)
    for the given (result_id, group_id).

    Returns
    -------
    bool
        True if at least one group was deleted, False otherwise.

    Parameters
    ----------
    recompute_steps:
        If True, recompute PentestResultORM.steps after deletion.
    delete_empty_result:
        If True, and the PentestResult no longer has any steps afterwards,
        delete the PentestResult as well (mirrors delete_run semantics).
    """
    groups = (
        session.query(ResultsGroupId)
        .filter(
            ResultsGroupId.pentest_result_id == result_id,
            ResultsGroupId.group_id == group_id,
        )
        .all()
    )
    if not groups:
        return False

    # Delete groups (AgentStep rows will be removed via FK cascade)
    for grp in groups:
        session.delete(grp)

    # Optionally recompute steps and/or delete empty parent
    if recompute_steps or delete_empty_result:
        new_steps = _recompute_steps_for_result(session, result_id) if recompute_steps else None

        if delete_empty_result:
            remaining = (
                session.query(func.count(AgentStepORM.id))
                .filter(AgentStepORM.pentest_result_id == result_id)
                .scalar()
                or 0
            )
            if remaining == 0:
                pr = (
                    session.query(PentestResultORM)
                    .filter(PentestResultORM.id == result_id)
                    .one_or_none()
                )
                if pr is not None:
                    session.delete(pr)

    session.commit()
    return True

