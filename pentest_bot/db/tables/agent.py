import json
from contextlib import contextmanager
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, Generator, Iterator, List, Optional

from sqlalchemy import func, case, Boolean, Column, DateTime, Float, Integer, String, ForeignKey, create_engine
from sqlalchemy.engine import Engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import Session, sessionmaker, relationship

from pentest_bot.web_exploit.agent_step import AgentContext
from pentest_bot.db import Base
from pentest_bot.db.utils import current_date

class PentestResultORM(Base):
    """ORM model that stores the outcome of a single PentestBot run."""

    __tablename__ = "pentest_results"

    id = Column(Integer, primary_key=True, autoincrement=True)
    run_id = Column(Integer, ForeignKey("runs.id", ondelete="CASCADE"), nullable=False)
    eval_name = Column(String, index=True, nullable=False)
    success = Column(Boolean, default=False, nullable=False)
    steps = Column(Integer, nullable=False)
    max_steps = Column(Integer, nullable=False)
    model_name = Column(String, nullable=False)
    model_costs = Column(Float, nullable=False)
    log_filepath = Column(String, nullable=False)
    created_at = Column(DateTime, default=current_date, nullable=False)

    run = relationship("RunORM", back_populates="results")
    agent_steps = relationship("AgentStepORM", back_populates="pentest_result", cascade="all, delete-orphan")

    # opik prompt info
    opik_prompt_name = Column(String, nullable=True)
    opik_prompt_commit = Column(String, nullable=True)

class AgentStepORM(Base):
    """ORM model that stores individual agent steps within a PentestResult."""

    __tablename__ = "agent_steps"

    id = Column(Integer, primary_key=True, autoincrement=True)
    pentest_result_id = Column(
        Integer,
        ForeignKey("pentest_results.id", ondelete="CASCADE"),
        nullable=False,
    )
    # NOTE: used to differentiate different step_type classifications
    group_id = Column(Integer, default=0, nullable=False, index=True)
    step_number = Column(Integer, nullable=False)
    reflection = Column(String, nullable=False)
    script = Column(String, nullable=False)
    execution_output = Column(String, nullable=False)
    step_type = Column(String, nullable=True)
    add_to_scratchpad = Column(String, nullable=True)
    created_at = Column(DateTime, default=current_date, nullable=False)

    pentest_result = relationship("PentestResultORM", back_populates="agent_steps")

    # opik prompt info
    opik_prompt_name = Column(String, nullable=True)
    opik_prompt_commit = Column(String, nullable=True)

class RunORM(Base):
    """Represents a logical run containing 1-N `PentestResult`."""

    __tablename__ = "runs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    created_at = Column(DateTime, default=current_date, nullable=False)
    comment = Column(String, nullable=True)
    parent_logdir = Column(String, nullable=False)
    is_eval = Column(Boolean, default=False, nullable=False)

    # collection of associated results
    results = relationship("PentestResultORM", back_populates="run", cascade="all, delete-orphan")


# ---------------------------------------------------------------------
# Create/modify helpers
# ---------------------------------------------------------------------


def create_run(
    session: Session,
    *,
    comment: str | None,
    parent_logdir: str,
    is_eval: bool = False,
) -> int:
    """Insert a new ``Run`` record and return its primary-key ID.

    The caller is responsible for managing the surrounding SQLAlchemy
    transaction (i.e. committing/rolling back).  We therefore *only*
    ``flush`` here to guarantee that the autoincremented primary key is
    populated before returning.
    """
    run_rec = RunORM(
        comment=comment,
        parent_logdir=parent_logdir,
        is_eval=is_eval,
    )
    session.add(run_rec)
    session.flush()  # assign PK without committing
    session.refresh(run_rec)
    return run_rec.id


def create_pentest_result(
    session: Session,
    *,
    run_id: int,
    eval_name: str,
    success: bool,
    steps: int,
    max_steps: int,
    model_name: str,
    model_costs: float,
    log_filepath: str,
    opik_prompt_name: str,
    opik_prompt_commit: str,
) -> int:
    """Insert a ``PentestResult`` row and return its ID."""
    pentest_result = PentestResultORM(
        run_id=run_id,
        eval_name=eval_name,
        success=success,
        steps=steps,
        max_steps=max_steps,
        model_name=model_name,
        model_costs=model_costs,
        log_filepath=log_filepath,
        opik_prompt_name=opik_prompt_name,
        opik_prompt_commit=opik_prompt_commit,
    )
    session.add(pentest_result)
    session.flush()
    session.refresh(pentest_result)
    return pentest_result.id


def create_agent_steps(
    session: Session,
    agent_steps: List,  # ``AgentStep`` objects or any obj with the accessed attributes
    step_types: Optional[List] | None,
    result_id: int,
    opik_prompt_name: str,
    opik_prompt_commit: str,
    *,
    group_id: int = 0,
) -> None:
    """Bulk-insert the individual ``AgentStep`` records for a result.

    ``agent_steps`` is expected to be an ordered list where each element
    exposes at least the attributes ``reflection``, ``script``,
    ``add_to_scratchpad`` and ``execution_output``.
    """
    if not step_types:
        step_types = [None] * len(agent_steps)

    for idx, (step, step_type) in enumerate(zip(agent_steps, step_types), start=1):
        session.add(
            AgentStepORM(
                pentest_result_id=result_id,
                step_number=idx,
                reflection=step.reflection,
                script=step.script,
                add_to_scratchpad=getattr(step, "add_to_scratchpad", None),
                step_type=getattr(step_type, "type", None).value if step_type else None,
                execution_output=step.execution_output,
                group_id=group_id,
                opik_prompt_name=opik_prompt_name,
                opik_prompt_commit=opik_prompt_commit,
            )
        )


def run_has_results(session: Session, run_id: int) -> bool:
    """Return ``True`` if the specified run already has any results."""
    return (
        session.query(PentestResultORM)
        .filter(PentestResultORM.run_id == run_id)
        .first()
        is not None
    )


# ---------------------------------------------------------------------
# Query helpers (all accept an active SQLAlchemy Session)
# ---------------------------------------------------------------------
def get_runs_summary(
    session,
    *,
    limit: int | None = None,
    eval_only: bool = True,
):
    """
    Return one row per Run with aggregate success / step counts.

    Each row is a SimpleNamespace with attributes:
        id, created_at, comment, parent_logdir,
        total_results, successes, total_steps
    """
    qry = (
        session.query(
            RunORM.id.label("id"),
            RunORM.created_at.label("created_at"),
            RunORM.comment.label("comment"),
            RunORM.parent_logdir.label("parent_logdir"),
            func.count(PentestResultORM.id).label("total_results"),
            func.sum(
                case((PentestResultORM.success.is_(True), 1), else_=0)
            ).label("successes"),
            func.sum(PentestResultORM.steps).label("total_steps"),
        )
        .outerjoin(PentestResultORM)
        .group_by(RunORM.id)
        .order_by(RunORM.created_at.desc())
    )
    if eval_only:
        qry = qry.filter(RunORM.is_eval.is_(True))
    if limit is not None:
        qry = qry.limit(limit)
    return qry.all()

def get_run(session, run_id: int):
    """Return the Run ORM object (or None if not found)."""
    return session.query(RunORM).filter(RunORM.id == run_id).first()

def get_agent_ctxt(
    session: Session,
    result_id: int,
    *,
    group_id: int = 0,
) -> AgentContext | None:
    """
    Build an AgentContext from the agent steps that belong to a given group
    (defaults to group 0). Returns None if the result or the group is missing.
    """
    res = (
        session.query(PentestResultORM)
        .filter(PentestResultORM.id == result_id)
        .first()
    )
    if res is None:
        return None

    steps = [s for s in res.agent_steps if s.group_id == group_id]
    if not steps:
        return None

    steps.sort(key=lambda s: s.step_number)
    return AgentContext.from_db(steps)

def get_cost_summary(session):
    """
    Compute usageâ€‘cost statistics.

    Returns:
        today_cost, week_cost, per_model_rows
    where per_model_rows is a list of
        (model_name, total_cost, total_steps, avg_per_step)
    """
    now = datetime.utcnow()
    today_start = datetime(now.year, now.month, now.day)
    tomorrow_start = today_start + timedelta(days=1)

    monday_start = today_start - timedelta(days=today_start.weekday())
    next_monday = monday_start + timedelta(days=7)

    today_cost = session.query(
        func.coalesce(func.sum(PentestResultORM.model_costs), 0.0)
    ).filter(
        PentestResultORM.created_at >= today_start,
        PentestResultORM.created_at < tomorrow_start,
    ).scalar()

    week_cost = session.query(
        func.coalesce(func.sum(PentestResultORM.model_costs), 0.0)
    ).filter(
        PentestResultORM.created_at >= monday_start,
        PentestResultORM.created_at < next_monday,
    ).scalar()

    per_model_raw = (
        session.query(
            PentestResultORM.model_name.label("model"),
            func.sum(PentestResultORM.model_costs).label("total_cost"),
            func.sum(PentestResultORM.steps).label("total_steps"),
        )
        .group_by(PentestResultORM.model_name)
        .all()
    )

    per_model_rows = []
    for row in per_model_raw:
        total_cost = float(row.total_cost or 0.0)
        total_steps = int(row.total_steps or 0)
        avg = total_cost / total_steps if total_steps else 0.0
        per_model_rows.append((row.model, total_cost, total_steps, avg))

    return today_cost, week_cost, per_model_rows


def delete_run(session, run_id: int):
    """Delete a Run and all associated PentestResults and AgentSteps.
    
    Returns:
        True if the run was found and deleted, False if not found.
    """
    run = session.query(RunORM).filter(RunORM.id == run_id).first()
    if run is None:
        return False
    
    session.delete(run)
    session.commit()
    return True
