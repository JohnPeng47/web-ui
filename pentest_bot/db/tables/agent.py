from datetime import datetime, timedelta
from typing import List, Optional

from sqlalchemy import (
    Boolean,
    Column,
    DateTime,
    Float,
    ForeignKey,
    Integer,
    String,
    case,
    func,
)
from sqlalchemy.orm import Session, relationship

from pentest_bot.db import Base
from pentest_bot.db.utils import current_date
from pentest_bot.web_exploit.agent_step import AgentContext


class PentestResultORM(Base):
    __tablename__ = "pentest_results"

    id = Column(Integer, primary_key=True, autoincrement=True)
    run_id = Column(Integer, ForeignKey("runs.id", ondelete="CASCADE"), nullable=False)
    eval_name = Column(String, index=True, nullable=False)
    success = Column(Boolean, default=False, nullable=False)
    steps = Column(Integer, nullable=False)
    max_steps = Column(Integer, nullable=False)
    model_name = Column(String, nullable=False)
    model_costs = Column(Float, nullable=False)
    log_filepath = Column(String, nullable=False)
    created_at = Column(DateTime, default=current_date, nullable=False)

    run = relationship("RunORM", back_populates="results")
    agent_steps = relationship(
        "AgentStepORM", back_populates="pentest_result", cascade="all, delete-orphan"
    )

    result_groups = relationship(
        "ResultsGroupId",
        back_populates="pentest_result",
        cascade="all, delete-orphan",
    )

    opik_prompt_name = Column(String, nullable=True)
    opik_prompt_commit = Column(String, nullable=True)


class ResultsGroupId(Base):
    """
    One row per logical (pentest_result_id, group_id) “step group”.
    The Opik prompt metadata now lives here, instead of on each AgentStep.
    """

    __tablename__ = "results_group_ids"

    id = Column(Integer, primary_key=True, autoincrement=True)
    pentest_result_id = Column(
        Integer, ForeignKey("pentest_results.id", ondelete="CASCADE"), nullable=False
    )
    group_id = Column(Integer, nullable=False, index=True)
    created_at = Column(DateTime, default=current_date, nullable=False)

    # moved from AgentStepORM:
    opik_prompt_name = Column(String, nullable=True)
    opik_prompt_commit = Column(String, nullable=True)

    pentest_result = relationship("PentestResultORM", back_populates="result_groups")
    steps = relationship(
        "AgentStepORM", back_populates="group", cascade="all, delete-orphan"
    )


class AgentStepORM(Base):
    __tablename__ = "agent_steps"

    id = Column(Integer, primary_key=True, autoincrement=True)
    pentest_result_id = Column(
        Integer, ForeignKey("pentest_results.id", ondelete="CASCADE"), nullable=False
    )

    # keep the simple integer group_id for now (back-compat / fast filters)
    group_id = Column(Integer, default=0, nullable=False, index=True)

    # NEW: FK to the new group table
    results_group_id = Column(
        Integer,
        ForeignKey("results_group_ids.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )

    step_number = Column(Integer, nullable=False)
    reflection = Column(String, nullable=False)
    script = Column(String, nullable=False)
    execution_output = Column(String, nullable=False)
    step_type = Column(String, nullable=True)
    add_to_scratchpad = Column(String, nullable=True)
    created_at = Column(DateTime, default=current_date, nullable=False)

    pentest_result = relationship("PentestResultORM", back_populates="agent_steps")
    group = relationship("ResultsGroupId", back_populates="steps")

class RunORM(Base):
    __tablename__ = "runs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    created_at = Column(DateTime, default=current_date, nullable=False)
    comment = Column(String, nullable=True)
    parent_logdir = Column(String, nullable=False)
    is_eval = Column(Boolean, default=False, nullable=False)

    results = relationship(
        "PentestResultORM", back_populates="run", cascade="all, delete-orphan"
    )


# ---------------------------------------------------------------------
# Create/modify helpers
# ---------------------------------------------------------------------


def create_run(
    session: Session,
    *,
    comment: str | None,
    parent_logdir: str,
    is_eval: bool = False,
) -> int:
    """Insert a new ``Run`` record and return its primary-key ID.

    The caller is responsible for managing the surrounding SQLAlchemy
    transaction (i.e. committing/rolling back).  We therefore *only*
    ``flush`` here to guarantee that the autoincremented primary key is
    populated before returning.
    """
    run_rec = RunORM(
        comment=comment,
        parent_logdir=parent_logdir,
        is_eval=is_eval,
    )
    session.add(run_rec)
    session.flush()  # assign PK without committing
    session.refresh(run_rec)
    return run_rec.id


def create_pentest_result(
    session: Session,
    *,
    run_id: int,
    eval_name: str,
    success: bool,
    steps: int,
    max_steps: int,
    model_name: str,
    model_costs: float,
    log_filepath: str,
    opik_prompt_name: str,
    opik_prompt_commit: str,
) -> int:
    """Insert a ``PentestResult`` row and return its ID."""
    pentest_result = PentestResultORM(
        run_id=run_id,
        eval_name=eval_name,
        success=success,
        steps=steps,
        max_steps=max_steps,
        model_name=model_name,
        model_costs=model_costs,
        log_filepath=log_filepath,
        opik_prompt_name=opik_prompt_name,
        opik_prompt_commit=opik_prompt_commit,
    )
    session.add(pentest_result)
    session.flush()
    session.refresh(pentest_result)
    return pentest_result.id


def create_agent_steps(
    session: Session,
    agent_steps: List,
    step_types: Optional[List] | None,
    result_id: int,
    opik_prompt_name: str,
    opik_prompt_commit: str,
    *,
    group_id: int = 0,
) -> None:
    """
    Bulk-insert the individual AgentStep records for a result.
    Now stores Opik prompt info on ResultsGroupId instead of AgentStepORM.
    """
    if not step_types:
        step_types = [None] * len(agent_steps)

    # get or create the group row
    group_row = (
        session.query(ResultsGroupId)
        .filter(
            ResultsGroupId.pentest_result_id == result_id,
            ResultsGroupId.group_id == group_id,
        )
        .one_or_none()
    )
    if group_row is None:
        group_row = ResultsGroupId(
            pentest_result_id=result_id,
            group_id=group_id,
            opik_prompt_name=opik_prompt_name,
            opik_prompt_commit=opik_prompt_commit,
        )
        session.add(group_row)
        session.flush()
        session.refresh(group_row)
    else:
        # keep group-row metadata in sync if provided
        if (
            group_row.opik_prompt_name != opik_prompt_name
            or group_row.opik_prompt_commit != opik_prompt_commit
        ):
            group_row.opik_prompt_name = opik_prompt_name
            group_row.opik_prompt_commit = opik_prompt_commit

    for idx, (step, step_type) in enumerate(zip(agent_steps, step_types), start=1):
        session.add(
            AgentStepORM(
                pentest_result_id=result_id,
                results_group_id=group_row.id,
                step_number=idx,
                reflection=step.reflection,
                script=step.script,
                add_to_scratchpad=getattr(step, "add_to_scratchpad", None),
                step_type=getattr(step_type, "type", None).value if step_type else None,
                execution_output=step.execution_output,
                group_id=group_id,
            )
        )


def run_has_results(session: Session, run_id: int) -> bool:
    """Return ``True`` if the specified run already has any results."""
    return (
        session.query(PentestResultORM)
        .filter(PentestResultORM.run_id == run_id)
        .first()
        is not None
    )


# ---------------------------------------------------------------------
# Query helpers (all accept an active SQLAlchemy Session)
# ---------------------------------------------------------------------
def get_runs_summary(
    session,
    *,
    limit: int | None = None,
    eval_only: bool = True,
):
    """
    Return one row per Run with aggregate success / step counts.

    Each row is a SimpleNamespace with attributes:
        id, created_at, comment, parent_logdir,
        total_results, successes, total_steps
    """
    qry = (
        session.query(
            RunORM.id.label("id"),
            RunORM.created_at.label("created_at"),
            RunORM.comment.label("comment"),
            RunORM.parent_logdir.label("parent_logdir"),
            func.count(PentestResultORM.id).label("total_results"),
            func.sum(case((PentestResultORM.success.is_(True), 1), else_=0)).label(
                "successes"
            ),
            func.sum(PentestResultORM.steps).label("total_steps"),
        )
        .outerjoin(PentestResultORM)
        .group_by(RunORM.id)
        .order_by(RunORM.created_at.desc())
    )
    if eval_only:
        qry = qry.filter(RunORM.is_eval.is_(True))
    if limit is not None:
        qry = qry.limit(limit)
    return qry.all()


def get_run(session, run_id: int):
    """Return the Run ORM object (or None if not found)."""
    return session.query(RunORM).filter(RunORM.id == run_id).first()


def get_agent_ctxt(
    session: Session,
    result_id: int,
    *,
    group_id: int = 0,
) -> AgentContext | None:
    """
    Build an AgentContext from the agent steps that belong to a given group
    (defaults to group 0). Returns None if the result or the group is missing.
    """
    res = (
        session.query(PentestResultORM).filter(PentestResultORM.id == result_id).first()
    )
    if res is None:
        return None

    steps = [s for s in res.agent_steps if s.group_id == group_id]
    if not steps:
        return None

    steps.sort(key=lambda s: s.step_number)
    return AgentContext.from_db(steps)


def get_cost_summary(session):
    """
    Compute usage‑cost statistics.

    Returns:
        today_cost, week_cost, per_model_rows
    where per_model_rows is a list of
        (model_name, total_cost, total_steps, avg_per_step)
    """
    now = datetime.utcnow()
    today_start = datetime(now.year, now.month, now.day)
    tomorrow_start = today_start + timedelta(days=1)

    monday_start = today_start - timedelta(days=today_start.weekday())
    next_monday = monday_start + timedelta(days=7)

    today_cost = (
        session.query(func.coalesce(func.sum(PentestResultORM.model_costs), 0.0))
        .filter(
            PentestResultORM.created_at >= today_start,
            PentestResultORM.created_at < tomorrow_start,
        )
        .scalar()
    )

    week_cost = (
        session.query(func.coalesce(func.sum(PentestResultORM.model_costs), 0.0))
        .filter(
            PentestResultORM.created_at >= monday_start,
            PentestResultORM.created_at < next_monday,
        )
        .scalar()
    )

    per_model_raw = (
        session.query(
            PentestResultORM.model_name.label("model"),
            func.sum(PentestResultORM.model_costs).label("total_cost"),
            func.sum(PentestResultORM.steps).label("total_steps"),
        )
        .group_by(PentestResultORM.model_name)
        .all()
    )

    per_model_rows = []
    for row in per_model_raw:
        total_cost = float(row.total_cost or 0.0)
        total_steps = int(row.total_steps or 0)
        avg = total_cost / total_steps if total_steps else 0.0
        per_model_rows.append((row.model, total_cost, total_steps, avg))

    return today_cost, week_cost, per_model_rows


def delete_run(session, run_id: int):
    """Delete a Run and all associated PentestResults and AgentSteps.

    Returns:
        True if the run was found and deleted, False if not found.
    """
    run = session.query(RunORM).filter(RunORM.id == run_id).first()
    if run is None:
        return False

    session.delete(run)
    session.commit()
    return True
