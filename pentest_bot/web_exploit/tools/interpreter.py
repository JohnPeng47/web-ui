import os
import sys
import traceback
from contextlib import redirect_stdout, redirect_stderr
import builtins
from io import StringIO
from typing import Dict, Optional

from .proxy import RequestsModuleProxy, TruncatedPrint

class PythonInterpreter:
    """Minimal, state‑preserving Python execution sandbox."""

    def __init__(
            self, 
            shared_globals: Dict[str, object] = {},
            max_print_len: int = 10000
        ) -> None:
        self._max_print_len = max_print_len
        self._globals = {**shared_globals, **self.import_globals()}
        self._interp_prompt = ""

    def import_globals(self) -> Dict[str, object]:
        import bs4
        import textwrap
        import html
        import re

        return {
            "re": re, 
            "textwrap": textwrap, 
            "html": html, 
            "bs4": bs4,
            "print": TruncatedPrint(max_len=self._max_print_len)
        }

    def set_interp_modules_prompt(self, prompt: str) -> None:
        self._interp_prompt = prompt

    def get_interp_modules_prompt(self) -> str:
        return self._interp_prompt

    # ---------------------------------------------------------------------
    # Public helpers
    # ---------------------------------------------------------------------

    def run(self, code: str) -> str:
        """Execute *code* and return ``stdout`` + ``stderr``.

        Fatal exceptions (*not* derived from plain :class:`Exception`) are
        re-raised so they propagate to the caller – this lets Ctrl-C
        (:class:`KeyboardInterrupt`) or :pyfunc:`sys.exit` terminate the whole
        program promptly while still capturing any partial output for logging.
        """

        # Temporarily patch `sys.modules` to intercept `import requests`.
        # This is cleaner than pre-populating globals, which is easily
        # defeated by `import requests` inside the agent's script.
        old_module = sys.modules.get("requests")
        sys.modules["requests"] = RequestsModuleProxy()

        stdout_buf = StringIO()
        stderr_buf = StringIO()

        try:
            with redirect_stdout(stdout_buf), redirect_stderr(stderr_buf):
                # NOTE: not sure why global == locals, or else import errors
                exec(code, self._globals, self._globals)
        except KeyboardInterrupt:  # ⇢ Ctrl-C
            print("KeyboardInterrupt")
            raise
        except SystemExit:  # ⇢ sys.exit()
            print("SystemExit")
            pass
            # raise
        except Exception:  # normal runtime error – capture traceback, continue
            traceback.print_exc(file=stderr_buf)
        except BaseException:  # any other fatal (asyncio.CancelledError, etc.)
            traceback.print_exc(file=stderr_buf)
            raise   
        finally:
            # reset print count
            self._globals["print"].reset_count()

            # Restore the original `requests` module.
            if old_module is None:
                sys.modules.pop("requests", None)
            else:
                sys.modules["requests"] = old_module

        stdout_text = stdout_buf.getvalue()
        stderr_text = stderr_buf.getvalue()
        return f"{stdout_text}{os.linesep if stderr_text else ''}{stderr_text}"
