import os
import sys
import traceback
from contextlib import redirect_stdout, redirect_stderr
import json
from io import StringIO
from typing import Dict, Optional, Callable, Tuple

from .proxy import RequestsModuleProxy, TruncatedPrint

INTERPRETER_TOOLS_PROMPT = """Here are some tools that you can call in your script:
They are already imported into the namespace of your intepreter by their 'name', you do not need to import them again
\n\n{tools_list_json}"""

class PythonInterpreter:
    """Minimal, state‑preserving Python execution sandbox."""

    def __init__(
            self, 
            shared_globals: Dict[str, Dict] | None = None,
            max_print_len: int = 10000
        ) -> None:
        if shared_globals is None:
            shared_globals = {}
        tools, tools_prompt = self._parse_tools(shared_globals)
        self._max_print_len = max_print_len
        self._globals = {**tools, **self.import_globals()}
        self._interp_prompt = INTERPRETER_TOOLS_PROMPT.format(tools_list_json=tools_prompt)

    def _parse_tools(self, shared_globals: Dict[str, Dict]) -> Tuple[Dict[str, Dict[str, Callable]], str]:
        tools_dict = {}
        tools_list_prompt = ""
        for k, v in shared_globals.items():
            if type(v) == dict and v.get("tool") is not None:
                tools_dict[k] = v["tool"]
                tools_list_prompt += f"{k}: {json.dumps(v['description'], indent=2)}\n"
            else:
                raise ValueError("Unexpected tools format: {}".format(k, v))
        return tools_dict, tools_list_prompt

    def import_globals(self) -> Dict[str, object]:
        import bs4
        import textwrap
        import html
        import re

        return {
            "re": re, 
            "textwrap": textwrap, 
            "html": html, 
            "bs4": bs4,
            "print": TruncatedPrint(max_len=self._max_print_len)
        }

    def set_interp_modules_prompt(self, prompt: str) -> None:
        if not self._interp_prompt:
            self._interp_prompt = prompt
        else:
            self._interp_prompt += f"\n\n*IMPORTANT*:{prompt}"

    def get_interp_modules_prompt(self) -> str:
        return self._interp_prompt

    # ---------------------------------------------------------------------
    # Public helpers
    # ---------------------------------------------------------------------

    def run(self, code: str) -> str:
        """Execute *code* and return ``stdout`` + ``stderr``.

        Fatal exceptions (*not* derived from plain :class:`Exception`) are
        re-raised so they propagate to the caller – this lets Ctrl-C
        (:class:`KeyboardInterrupt`) or :pyfunc:`sys.exit` terminate the whole
        program promptly while still capturing any partial output for logging.
        """

        # Temporarily patch `sys.modules` to intercept `import requests`.
        # This is cleaner than pre-populating globals, which is easily
        # defeated by `import requests` inside the agent's script.
        old_module = sys.modules.get("requests")
        sys.modules["requests"] = RequestsModuleProxy()

        stdout_buf = StringIO()
        stderr_buf = StringIO()

        try:
            with redirect_stdout(stdout_buf), redirect_stderr(stderr_buf):
                # NOTE: not sure why global == locals, or else import errors
                exec(code, self._globals, self._globals)
        except KeyboardInterrupt:  # ⇢ Ctrl-C
            print("KeyboardInterrupt")
            raise
        except SystemExit:  # ⇢ sys.exit()
            print("SystemExit")
            pass
            # raise
        except Exception:  # normal runtime error – capture traceback, continue
            traceback.print_exc(file=stderr_buf)
        except BaseException:  # any other fatal (asyncio.CancelledError, etc.)
            traceback.print_exc(file=stderr_buf)
            raise   
        finally:
            # reset print count
            self._globals["print"].reset_count()

            # Restore the original `requests` module.
            if old_module is None:
                sys.modules.pop("requests", None)
            else:
                sys.modules["requests"] = old_module

        stdout_text = stdout_buf.getvalue()
        stderr_text = stderr_buf.getvalue()
        return f"{stdout_text}{os.linesep if stderr_text else ''}{stderr_text}"
