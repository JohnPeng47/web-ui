import os
import sys
import traceback
from contextlib import redirect_stdout, redirect_stderr
from io import StringIO
from typing import Dict, Optional

from .proxy import RequestsModuleProxy

class PythonInterpreter:
    """Minimal, state‑preserving Python execution sandbox."""

    def __init__(self, shared_globals: Optional[Dict[str, object]] = None) -> None:
        self._globals: Dict[str, object] = shared_globals or {}
        self._globals = {**self._globals, **self._import_globals()}

    def _import_globals(self) -> Dict[str, object]:
        import bs4
        import textwrap
        import html
        import re

        return {
            "re": re, 
            "textwrap": textwrap, 
            "html": html, 
            "bs4": bs4
        }

    # ---------------------------------------------------------------------
    # Public helpers
    # ---------------------------------------------------------------------

    def run(self, code: str) -> str:
        """Execute *code* and return ``stdout`` + ``stderr``.

        Fatal exceptions (*not* derived from plain :class:`Exception`) are
        re-raised so they propagate to the caller – this lets Ctrl-C
        (:class:`KeyboardInterrupt`) or :pyfunc:`sys.exit` terminate the whole
        program promptly while still capturing any partial output for logging.
        """

        # Temporarily patch `sys.modules` to intercept `import requests`.
        # This is cleaner than pre-populating globals, which is easily
        # defeated by `import requests` inside the agent's script.
        old_module = sys.modules.get("requests")
        sys.modules["requests"] = RequestsModuleProxy()

        stdout_buf = StringIO()
        stderr_buf = StringIO()

        try:
            with redirect_stdout(stdout_buf), redirect_stderr(stderr_buf):
                # NOTE: not sure why global == locals, or else import errors
                exec(code, self._globals, self._globals)
        except KeyboardInterrupt:  # ⇢ Ctrl-C
            print("KeyboardInterrupt")
            raise
        except SystemExit:  # ⇢ sys.exit()
            raise
        except Exception:  # normal runtime error – capture traceback, continue
            traceback.print_exc(file=stderr_buf)
        except BaseException:  # any other fatal (asyncio.CancelledError, etc.)
            traceback.print_exc(file=stderr_buf)
            raise
        finally:
            # Restore the original `requests` module.
            if old_module is None:
                sys.modules.pop("requests", None)
            else:
                sys.modules["requests"] = old_module

        stdout_text = stdout_buf.getvalue()
        stderr_text = stderr_buf.getvalue()
        return f"{stdout_text}{os.linesep if stderr_text else ''}{stderr_text}"
