# src/tools/browser.py
from playwright.sync_api import sync_playwright
from typing import Tuple, Dict, Any, Callable

# TODO:
# Add browser check alert implementation
# - dont need until we start looking websites ie. ones that might block network requests
# - good candidate for claude code 
TOOLS_TEMPLATE = {
    "browser_check_xss": {
        "description": {
            "name": "browser_check_xss",
            "description": """
Check if page is vulnerable to XSS by fetching the vulnerable URL
Note that this tool should only be used to confirm your XSS payload hypothesis.
You do not need to import this tool; it is already available in the namespace
You should be following regular testing methodologies to establish a high-confidence payload first before calling this tool
""",
            "parameters": {
                "url": {
                    "type": "string",
                    "description": "The URL to check"
                }
            },
            "examples": """
browser_check_xss(url="https://example.com/search?q=<img src=x onerror=alert(1)>")\n
browser_check_xss(url="https://example.com/comment?text=<svg%20onload=alert('xss')>")\n
browser_check_xss(url="https://example.com/view?param=%3Cscript%3Ealert('encoded')%3C%2Fscript%3E")\n
            """
        },
        "tool": None,
    }
}

BASE = "https://cowboy.rocks/xss"         # public URL fronted by Nginx

def register_xss_payload(timeout: int = 60):
    """Register a fresh XSS payload and return a tuple consisting of
    (callback_function, target_url).

    The *callback_function* performs a quick poll (non-blocking, <1s) against
    the /client/<id> endpoint and returns *True* if the payload has executed
    in the victim's browser.  This callback is intended to be passed as
    ``eval_fn`` to :class:`PentestSession` so the outer orchestration loop can
    terminate automatically once the exploit succeeds.
    """

    import httpx  # local import to keep the public namespace clean

    client = httpx.Client(timeout=timeout)

    # Step 1 – obtain a fresh payload identifier
    resp = client.post(f"{BASE}/register")
    resp.raise_for_status()
    data = resp.json()

    payload_id: str = data["id"]
    target_url: str = data["target_url"]
    client_url: str = data["client_url"]

    print(f"[+] New payload id  : {payload_id}")
    print(f"[+] Target callback : {target_url}")

    # Closure used by the orchestration layer to verify success
    def _client_callback() -> bool:  # noqa: D401 – imperative mood
        poll = client.get(client_url, params={"wait": 1})
        poll.raise_for_status()
        body = poll.json()
        return bool(body.get("executed", False))

    return _client_callback, target_url

def create_browser_check_xss() -> Tuple[Dict[str, Dict[str, Any]], Callable[[], bool], str]:
    r"""
    Returns: browser_template with browser_check_xss tool filled in, cb function to check payload executed and target_url
    """
    check_cb, target_url = register_xss_payload()
    def browser_check_xss(url: str, wait_until: str = "load", timeout: int = 10000) -> str:
        """
        Headless Chromium request through Playwright.

        Returns:
            (status_code, len(response_body))
        """
        with sync_playwright() as p:
            browser = p.chromium.launch(headless=True, args=["--no-sandbox"])
            context = browser.new_context()
            page = context.new_page()
            resp = page.goto(url, wait_until=wait_until, timeout=timeout)
            # `resp` is None if the navigation was served from cache
            status = resp.status if resp else 200
            body_len = len(page.content())
            browser.close()

            ret = f"XSS Payload {url} Successfully Executed!!" if check_cb() else f"XSS Payload {url} Not Executed"
            
            # print ret for agent to see
            print(ret)
            
            return ret
    
    TOOLS_TEMPLATE["browser_check_xss"]["tool"] = browser_check_xss
    return TOOLS_TEMPLATE, check_cb, target_url