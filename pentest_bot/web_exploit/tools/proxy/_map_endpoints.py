import re, urllib.parse, itertools, textwrap, requests
from collections import defaultdict, namedtuple

base = "https://app.aikido.dev"
req  = requests
Window = namedtuple("Window", "verb path body params file")

# ────────────────────────────────────────────────────────────────────
# Regex helpers
# ────────────────────────────────────────────────────────────────────
# (axios|z).<verb>("…",
CALL_RE = re.compile(
    r"""\b(?:axios|[A-Za-z_$][\w$]*)\.(get|post|put|patch|delete)\(\s*         # verb
        (?P<q>["'][/a-zA-Z0-9_.\-]+["'])                                        # "/api/…"
        \s*,?""",
    re.X,
)
VAR_INIT_RE = re.compile(r"""\b(const|let|var)\s+([A-Za-z_$][\w$]*)\s*=\s*{""")

def fetch_js(url: str) -> str | None:
    r = req.get(url, timeout=15)
    if r.status_code == 200 and "javascript" in r.headers.get("content-type", ""):
        return r.text
    return None

def match_parenthesis(code: str, pos_open: int) -> int:
    """Return position of the matching ')' given pos of '('."""
    depth = 0
    for i in range(pos_open, len(code)):
        if code[i] == "(":
            depth += 1
        elif code[i] == ")":
            depth -= 1
            if depth == 0:
                return i
    return -1

def extract_calls(js: str, fname: str) -> list[Window]:
    out: list[Window] = []
    for m in CALL_RE.finditer(js):
        verb, path_token = m.group(1).upper(), m.group("q")
        path = path_token.strip("'\"")
        # find full call string
        open_paren = js.find("(", m.end(1))         # first '(' after .verb
        close_paren = match_parenthesis(js, open_paren)
        call = js[open_paren + 1 : close_paren]     # inside (...)
        args = [a.strip() for a in split_top_level(call)]
        # heuristics: args[1] → body, args[-1] → maybe {params: …}
        body, params = None, None
        if len(args) > 1:
            body = args[1]
        if args and "params" in args[-1]:
            params = args[-1]
        out.append(Window(verb, path, body, params, fname))
    return out

def split_top_level(arg_str: str) -> list[str]:
    """Split comma-separated top-level arguments (ignores nested braces)."""
    out, buf, depth = [], "", 0
    for ch in arg_str:
        if ch == "," and depth == 0:
            out.append(buf)
            buf = ""
        else:
            if ch in "({[":
                depth += 1
            elif ch in ")}]":
                depth -= 1
            buf += ch
    if buf:
        out.append(buf)
    return out

def find_var_literal(js: str, varname: str, call_pos: int) -> str | None:
    """Search backwards for `const varname = { … }` and return the object."""
    snippet = js[:call_pos]
    for m in VAR_INIT_RE.finditer(snippet):
        if m.group(2) == varname:
            brace_open = snippet.find("{", m.end(0) - 1)
            brace_close = match_parenthesis(snippet, brace_open)
            if brace_close != -1:
                return snippet[brace_open : brace_close + 1]
    return None

# ────────────────────────────────────────────────────────────────────
# 1.  Get JS bundle URLs from root
# ────────────────────────────────────────────────────────────────────
root_html = req.get(f"{base}/").text
srcs = re.findall(r"<script[^>]+src=\"([^\"]+\.js)\"", root_html)[:15]
bundle_urls = [urllib.parse.urljoin(base, s) for s in srcs]

# ────────────────────────────────────────────────────────────────────
# 2.  Scan each bundle
# ────────────────────────────────────────────────────────────────────
calls: dict[str, Window] = {}          # keyed by path for deduping
for url in bundle_urls:
    js = fetch_js(url)
    if not js:
        continue
    for c in extract_calls(js, url):
        # If body is a bare identifier – try to resolve it.
        if c.body and re.fullmatch(r"[A-Za-z_$][\w$]*", c.body):
            lit = find_var_literal(js, c.body, js.find(c.body))
            if lit:
                c = c._replace(body=lit)
        calls[f"{c.verb} {c.path}"] = c

# ────────────────────────────────────────────────────────────────────
# 3.  Pretty-print
# ────────────────────────────────────────────────────────────────────
for key in sorted(calls):
    c = calls[key]
    print(f"[{c.verb:<4}] {c.path}")
    if c.body:
        body_preview = textwrap.shorten(" ".join(c.body.split()), width=120)
        print(f"      body : {body_preview}")
    if c.params:
        params_preview = textwrap.shorten(" ".join(c.params.split()), width=120)
        print(f"      query: {params_preview}")
    print(f"      src  : {c.file}\n")
