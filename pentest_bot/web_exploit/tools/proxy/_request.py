"""
Extends the previous RequestsModuleProxy so that *both*
`requests.get()` *and* `requests.Session().get()` return a
FilteredResponse with identical line-removal logic.
"""

from __future__ import annotations

import re
from typing import Any, Dict, List

import requests as _orig_requests

from .base import ModuleProxy            # your generic proxy


_PORTSWIGGER_PATTERNS = ["<title>", "<h2>", "class=link-back"]

class _FilteredResponse(_orig_requests.Response):
    def __init__(self, resp: _orig_requests.Response, remove: List[str]) -> None:
        super().__init__()
        remove.extend(_PORTSWIGGER_PATTERNS)
        self.__dict__.update(resp.__dict__)
        self._rx = [re.compile(p) for p in remove]

    @property  # type: ignore[override]
    def text(self) -> str:
        raw = super().text
        return "\n".join(
            line for line in raw.splitlines() if not any(rx.search(line) for rx in self._rx)
        )


def _filtered_request(
    method: str,
    url: str,
    *,
    remove_patterns: List[str] | None = None,
    session: "_orig_requests.Session | None" = None,
    **kw: Any,
) -> _FilteredResponse:
    """Internal helper used by both the top-level .get and Session().get.
    It explicitly routes the HTTP call through the ORIGINAL ``requests``
    machinery to avoid the recursion that would otherwise occur when
    ``_FilteredSession.request`` delegates back to this helper.
    """
    if session is None:
        # Plain function call: use top-level requests.request
        resp = _orig_requests.request(method, url, **kw)
    else:
        # Session object provided → invoke the *original* Session.request
        # explicitly, bypassing the overridden _FilteredSession.request
        resp = _orig_requests.Session.request(session, method, url, **kw)
    return _FilteredResponse(resp, remove_patterns or [])


def _filtered_get(url: str, *, remove_patterns: List[str] | None = None, **kw: Any) -> _FilteredResponse:
    return _filtered_request("GET", url, remove_patterns=remove_patterns, **kw)


class _FilteredSession(_orig_requests.Session):
    """Drop-in replacement for requests.Session with filtered responses."""

    def request(self, method: str, url: str, *args: Any, **kwargs: Any) -> _FilteredResponse:  # type: ignore[override]
        remove = kwargs.pop("remove_patterns", None)
        return _filtered_request(method, url, remove_patterns=remove, session=self, *args, **kwargs)


class RequestsModuleProxy(ModuleProxy):
    """
    Ready-made drop-in for `requests`.
    * requests.get → _filtered_get
    * requests.Session / requests.session() → _FilteredSession
    * FilteredResponse exposed for direct reference if needed.
    """

    def __init__(self) -> None:
        super().__init__(
            _orig_requests,
            overrides=self._overrides(),
        )

    @staticmethod
    def _overrides() -> Dict[str, Any]:
        return {
            "get": _filtered_get,
            "FilteredResponse": _FilteredResponse,
            "Session": _FilteredSession,
            "session": lambda *a, **k: _FilteredSession(*a, **k),
        }
