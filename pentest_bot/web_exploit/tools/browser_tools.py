from typing import Tuple, Dict, Any, Callable, Literal, List
import copy

from playwright.sync_api import BrowserContext

# ----------------------------- Browser Check XSS ---------------------------- #

from typing import Dict, Any, Tuple, Callable
from playwright.sync_api import BrowserContext

# ------------------------------------------------------------------ #
# Static template (examples updated: no context arg required)
# ------------------------------------------------------------------ #
BROWSER_CHECK_TEMPLATE: Dict[str, Dict[str, Any]] = {
    "browser_check_xss": {
        "description": {
            "name": "browser_check_xss",
            "description": (
                "Confirm an XSS hypothesis by loading the URL in a pre-supplied\n"
                "Playwright BrowserContext and polling a callback beacon.\n"
                "Use only after you have high confidence the payload should fire."
            ),
            "parameters": {
                "url": {"type": "string", "description": "The URL to check"},
            },
            "examples": (
                'browser_check_xss("https://example.com/?q=<svg onload=alert(1)>")'
            ),
        },
        "tool": None,  # filled in at factory time
    }
}

BASE = "https://cowboy.rocks/xss"


def register_xss_payload(timeout: int = 60):
    """Obtain (callback_fn, target_url) from XSS beacon service."""
    import httpx

    client = httpx.Client(timeout=timeout)
    data = client.post(f"{BASE}/register").json()

    payload_id: str = data["id"]
    target_url: str = data["target_url"]
    client_url: str = data["client_url"]

    print(f"[+] New payload id  : {payload_id}")
    print(f"[+] Target callback : {target_url}")

    def _client_callback() -> bool:
        body = client.get(client_url, params={"wait": 1}).json()
        return bool(body.get("executed", False))

    return _client_callback, target_url


# ------------------------------------------------------------------ #
# Factory – binds the given BrowserContext into the closure
# ------------------------------------------------------------------ #
def create_browser_check_xss_tool(
    context: BrowserContext,
    *,
    wait_until_default: Literal["commit", "domcontentloaded", "load", "networkidle"] = "load",
    timeout_default: int = 10_000,
) -> Tuple[Dict[str, Dict[str, Any]], Callable[[], bool], str]:
    """
    Return (tools_template, beacon_callback, target_url).

    Parameters
    ----------
    context : BrowserContext
        A running Playwright context the caller controls.
    wait_until_default : str, optional
        Default Playwright wait_until value.
    timeout_default : int, optional
        Default navigation timeout (ms).
    """
    check_cb, target_url = register_xss_payload()

    def browser_check_xss(
        url: str,
        *,
        wait_until: Literal["commit", "domcontentloaded", "load", "networkidle"] = wait_until_default,
        timeout: int = timeout_default,
    ) -> str:
        if not url.startswith(("http://", "https://")):
            raise ValueError("browser_check_xss: url must start with http:// or https://")

        page = context.new_page()
        page.goto(url, wait_until=wait_until, timeout=timeout)
        page.close()

        result = (
            f"XSS Payload {url} Successfully Executed!!"
            if check_cb()
            else f"XSS Payload {url} Not Executed"
        )
        print(result)
        return result

    # Create a thread-local copy of the template to avoid cross-thread mutation
    template = copy.deepcopy(BROWSER_CHECK_TEMPLATE)
    template["browser_check_xss"]["tool"] = browser_check_xss
    return template, check_cb, target_url

# ----------------------------- Browser Fetch ---------------------------- #
BROWSER_FETCH_TEMPLATE: Dict[str, Dict[str, Any]] = {
    "page_goto": {
        "description": {
            "name": "page_goto",
            "description": (
                "This method wraps the 'page.goto' method of Playwright.BrowserContext, and accepts/returns the same args/response"
                "You should always be using this tool to get the response of the page, since regular requests will not render Javascript properly"
                "Returns (Response|None).",
                """
class Response(SyncBase):
    @property
    def url(self) -> str:
    @property
    def ok(self) -> bool:
    @property
    def status(self) -> int:
    @property
    def status_text(self) -> str:
    @property
    def headers(self) -> typing.Dict[str, str]:
    @property
    def from_service_worker(self) -> bool:
    @property
    def request(self) -> "Request":
    @property
    def frame(self) -> "Frame":
    def all_headers(self) -> typing.Dict[str, str]:
    def headers_array(self) -> typing.List[NameValue]:
    def header_value(self, name: str) -> typing.Optional[str]:
    def header_values(self, name: str) -> typing.List[str]:
    def server_addr(self) -> typing.Optional[RemoteAddr]:
    def security_details(self) -> typing.Optional[SecurityDetails]:
    def finished(self) -> None:
    def body(self) -> bytes:
    def text(self) -> str:
    def json(self) -> typing.Any:
"""
            ),
            "parameters": {
                "url": {"type": "string", "description": "Target URL"},
                "wait_until": {"type": "string", "description": "['commit', 'domcontentloaded', 'load', 'networkidle']", "default": "load"},
                "timeout": {"type": "number", "description": "Timeout in milliseconds", "default": 10_000},
            },
            "examples": """
res = page_goto("https://example.com")
print(res.status_code)
print(res.text())
""",
        },
        "tool": None,  # filled in at factory time
    }
}

# ------------------------------------------------------------------ #
# Factory – *binds* the caller-provided context into the closure
# ------------------------------------------------------------------ #
def create_browser_fetch_tool(
    context: BrowserContext,
    *,
    wait_until_default: Literal["commit", "domcontentloaded", "load", "networkidle"] = "load",
    timeout_default: int = 10_000,
    cookies: List[Dict[str, Any]] = None,
) -> Dict[str, Dict[str, Any]]:
    """
    Factory that returns (tools_template, browser_fetch callable).

    Parameters
    ----------
    context : BrowserContext
        An already-running Playwright context you manage.
    wait_until_default : str, optional
        Default Playwright wait_until value.  ('load', 'domcontentloaded', 'networkidle')
    timeout_default : int, optional
        Default timeout in ms for navigation.

    Usage
    -----
    >>> with BrowserClient() as ctx:
    ...     template = create_browser_fetch_tool(ctx)
    ...     template["page_goto"]["tool"]("https://example.com")
    """
    def browser_fetch(
        url: str,
        *,
        wait_until: Literal["commit", "domcontentloaded", "load", "networkidle"] = wait_until_default,
        timeout: int = timeout_default,
    ) -> Any:
        if not url.startswith(("http://", "https://")):
            raise ValueError("page_goto: url must start with http:// or https://")

        if cookies:
            context.add_cookies(cookies)

        page = context.new_page()
        resp = page.goto(url, wait_until=wait_until, timeout=timeout)
        return resp

    # Create a thread-local copy of the template to avoid cross-thread mutation
    template = copy.deepcopy(BROWSER_FETCH_TEMPLATE)
    template["page_goto"]["tool"] = browser_fetch
    return template
