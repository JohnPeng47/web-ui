"""
Updated log-directory layout:

    <LOG_DIR>/pentest_bot/<YYYY-MM-DD>/<N>/…

The optional *subfolder* argument is still supported and, if supplied,
is placed **inside** the date directory:

    <LOG_DIR>/pentest_bot/<YYYY-MM-DD>/<subfolder>/<N>/…
"""

import itertools
import logging
import textwrap
import threading
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple

from logger import LOG_DIR, get_console_handler, get_file_handler

# --------------------------------------------------------------------------- #
#  constants
# --------------------------------------------------------------------------- #
LOG_PATH = Path(LOG_DIR)
INDENT_LEN = 100
INDENT_STR = ""
_run_lock = threading.Lock()               # <── thread-safety

# --------------------------------------------------------------------------- #
#  helpers
# --------------------------------------------------------------------------- #
class IndentFormatter(logging.Formatter):
    """
    Wraps long log messages and prepends an ever-increasing counter.

    Example output:
        [1]: custom_agent.py:277 - Starting browser …
        [2]: custom_agent.py:291 - Navigation succeeded
    """
    _counter = itertools.count(1)          # global monotonically-increasing index

    def __init__(self, fmt: str = "", datefmt: Optional[str] = None) -> None:
        super().__init__(fmt, datefmt)

    def format(self, record: logging.LogRecord) -> str:     # noqa: D401
        idx = next(self._counter)

        # Soft-wrap the original log message exactly as before.
        wrapped: list[str] = []
        for para in record.getMessage().splitlines() or [""]:
            wrapped.extend(
                textwrap.wrap(
                    para,
                    width=INDENT_LEN,
                    subsequent_indent=INDENT_STR,
                    break_long_words=False,
                    replace_whitespace=False,
                )
            )
        message = "\n".join(wrapped)

        # Final format: [IDX]: filename:lineno - message
        return f"[{idx}]: {record.filename}:{record.lineno} - {message}"


class _ThreadFilter(logging.Filter):
    """Accept records only from the thread that created this handler."""
    def __init__(self, thread_id: int):
        super().__init__()
        self._thread_id = thread_id

    def filter(self, record: logging.LogRecord) -> bool:    # noqa: D401
        return record.thread == self._thread_id             # ❶ key line


# --------------------------------------------------------------------------- #
#  public API
# --------------------------------------------------------------------------- #
def setup_agent_logger(
    eval_name: str,
    *,
    subfolder: str = "default",
    name: str = "agentlog",
    level: int = logging.INFO,
):
    """
    Initialise two loggers:

    1. *agentlog*         – main logger
    2. *full_requests*    – verbose HTTP-request logger

    Directory layout:

        <LOG_DIR>/pentest_bot/<YYYY-MM-DD>/<subfolder?>/<run_id>/
    """
    # ─────────── Primary (“agentlog”) logger ────────────
    logger = logging.getLogger(name)
    logger.setLevel(level)

    if not any(isinstance(h, logging.StreamHandler) for h in logger.handlers):
        logger.addHandler(get_console_handler())

    if not hasattr(logger, "_run_dir"):
        with _run_lock:
            if not hasattr(logger, "_run_dir"):
                # ----- NEW PATH LOGIC -----
                date_dir = datetime.now().strftime("%Y-%m-%d")
                base_dir = LOG_PATH / subfolder / date_dir

                base_dir.mkdir(parents=True, exist_ok=True)

                run_id = (
                    max(
                        (
                            int(p.name)
                            for p in base_dir.iterdir()
                            if p.is_dir() and p.name.isdigit()
                        ),
                        default=-1,
                    )
                    + 1
                )
                run_dir = base_dir / str(run_id)
                run_dir.mkdir()
                logger._run_dir = run_dir                # type: ignore[attr-defined]

    run_dir: Path = logger._run_dir                      # type: ignore[attr-defined]
    thread_id = threading.get_ident()

    if not any(
        isinstance(h, logging.FileHandler) and getattr(h, "_thread_id", None) == thread_id
        for h in logger.handlers
    ):
        log_file = run_dir / f"{eval_name}.log"
        fh = get_file_handler(log_file)
        fh._thread_id = thread_id                       # type: ignore[attr-defined]
        fh.addFilter(_ThreadFilter(thread_id))
        fh.setFormatter(
            IndentFormatter(
                "%(asctime)s - %(name)s:%(levelname)s: "
                "%(filename)s:%(lineno)d - %(wrapped_msg)s",
                datefmt="%Y-%m-%d %H:%M:%S",
            )
        )
        logger.addHandler(fh)

    # ─────────── Secondary (“full_requests”) logger ──────
    fr_logger = logging.getLogger("full_requests")
    fr_logger.setLevel(level)
    fr_logger.propagate = False  # prevent double printing to parent

    if not any(isinstance(h, logging.StreamHandler) for h in fr_logger.handlers):
        fr_logger.addHandler(get_console_handler())

    # ensure sub-directory …/full_requests/
    full_req_dir = run_dir / "full_requests"
    full_req_dir.mkdir(exist_ok=True)

    if not any(
        isinstance(h, logging.FileHandler) and getattr(h, "_thread_id", None) == thread_id
        for h in fr_logger.handlers
    ):
        fr_log_file = full_req_dir / f"{eval_name}_requests.log"
        fr_fh = get_file_handler(fr_log_file)
        fr_fh._thread_id = thread_id                    # type: ignore[attr-defined]
        fr_fh.addFilter(_ThreadFilter(thread_id))
        fr_fh.setFormatter(
            IndentFormatter(
                "%(asctime)s - %(name)s:%(levelname)s: "
                "%(filename)s:%(lineno)d - %(wrapped_msg)s",
                datefmt="%Y-%m-%d %H:%M:%S",
            )
        )
        fr_logger.addHandler(fr_fh)

    return logger, fr_logger

def get_agent_loggers() -> Tuple[logging.Logger, logging.Logger]:
    return logging.getLogger("agentlog"), logging.getLogger("full_requests")