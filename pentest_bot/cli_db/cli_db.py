#!/usr/bin/env python
"""PentestBot SQLite CLI

A light‑weight, zero‑dependency command‑line utility for exploring the
`pentest_bot.sqlite` database.  It provides a Windows‑friendly ASCII
interface that also works unmodified on Linux/OS X terminals.

Usage examples
--------------
List the most recent 10 runs (default)::

    python pentest_cli.py list-runs

List ALL runs::

    python pentest_cli.py list-runs --all

Display a specific run together with its child ``PentestResult`` rows::

    python pentest_cli.py show-run 42

Execute an ad‑hoc SQL query (wrap the query in quotes)::

    python pentest_cli.py q_db "SELECT id, comment FROM Run LIMIT 5"

Point to a custom database file::

    python pentest_cli.py list-runs --db path/to/alt.sqlite

This module assumes that the schema definitions (``Run``/``PentestResult``)
reside in a sibling module named ``pentest_db.py``.  Adjust
``DB_MODULE`` below if your file is named differently.
"""
from __future__ import annotations

from argparse import ArgumentParser, Namespace
from contextlib import contextmanager, redirect_stdout
from datetime import datetime, timedelta
from importlib import import_module
from pathlib import Path
from typing import Iterable, List, Sequence

from pentest_bot.db import (
    AgentStep,
    PentestResult,
    get_session,           # already existed
    get_runs_summary,
    get_run,
    get_steps_for_result,
    get_cost_summary,
)
from pentest_bot.web_exploit.utils import get_token_count

# ---------------------------------------------------------------------------
# Configuration – tweak these to match local layout
# ---------------------------------------------------------------------------
DB_MODULE = "pentest_bot.db"  # file that defines `engine`, `SessionLocal`, `Run`, …
DEFAULT_DB_FILE = Path(__file__).parent.parent / "pentest_bot.sqlite"
# ---------------------------------------------------------------------------
# Helper: lazy‑import the application DB module
# ---------------------------------------------------------------------------
_db_cache: dict[Path, tuple] = {}


def _load_db(db_path: Path):
    """Return (SessionLocal, Run, PentestResult, AgentStep) from the target database.

    The function monkey‑patches the underlying SQLAlchemy ``engine`` so that
    we can reuse the ORM models with **any** SQLite file chosen at runtime.
    """
    if db_path in _db_cache:
        return _db_cache[db_path]

    db_mod = import_module(DB_MODULE)

    # Monkey‑patch the engine used by the ORM.  This avoids having to fork the
    # schema definitions for each database file.
    from sqlalchemy import create_engine

    db_mod.engine.dispose()  # close previous connections, if any
    setattr(db_mod, "engine", create_engine(f"sqlite:///{db_path}", connect_args={"check_same_thread": False}))
    db_mod.SessionLocal.configure(bind=db_mod.engine)  # type: ignore[attr-defined]

    _db_cache[db_path] = (db_mod.SessionLocal, db_mod.Run, db_mod.PentestResult, db_mod.AgentStep)
    return _db_cache[db_path]


# ---------------------------------------------------------------------------
# Plain‑ASCII table formatter (Windows‑friendly, no fancy Unicode)
# ---------------------------------------------------------------------------

def _build_table(rows: Sequence[Sequence[str]], headers: Sequence[str] | None = None, max_col: int = 50) -> str:
    """Return an ASCII table as a single string.

    The function calculates column widths from the *longest* cell in each
    column and then draws the grid using ``+``/``-``/``|`` glyphs which render
    correctly even in the Windows 10/11 default console font.
    
    Args:
        rows: The data rows to display
        headers: Optional column headers
        max_col: Maximum width for any column; longer content is truncated with "..."
    """
    if not rows and not headers:
        return "<empty>"

    # Ensure we have at least one row to compute widths
    sample = rows[0] if rows else ["" for _ in headers]  # type: ignore[arg-type]
    col_count = len(headers or sample)

    widths: List[int] = [0] * col_count
    for col_idx in range(col_count):
        header_len = len(headers[col_idx]) if headers else 0  # type: ignore[index]
        max_cell = max((len(r[col_idx]) for r in rows), default=0)
        widths[col_idx] = min(max(header_len, max_cell), max_col)

    def _separator(char: str = "-") -> str:
        return "+" + "+".join(char * (w + 2) for w in widths) + "+"

    def _truncate_cell(cell: str, width: int) -> str:
        if len(cell) <= width:
            return cell
        return cell[:width-3] + "..."

    def _format_row(row: Sequence[str]) -> str:
        return "| " + " | ".join(_truncate_cell(cell, widths[i]).ljust(widths[i]) for i, cell in enumerate(row)) + " |"

    parts: List[str] = [
        _separator(),
    ]
    if headers:
        parts.append(_format_row(headers))
        parts.append(_separator("="))
    for r in rows:
        parts.append(_format_row(r))
        parts.append(_separator())
    return "\n".join(parts)


# ---------------------------------------------------------------------------
# CLI commands
# ---------------------------------------------------------------------------

from sqlalchemy import func, case


def _human_ts(ts: datetime | None) -> str:
    return ts.strftime("%Y-%m-%d %H:%M:%S") if ts else "—"


def list_runs_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    limit = None if args.all else args.limit

    with get_session() as session:
        # REFRACTOR ►  use query helper
        runs = get_runs_summary(session, limit=limit, eval_only=not args.all)

        header_field_mapping = [
            ("ID", "id"),
            ("Created", "created_at"),
            ("Comment", "comment"),
            ("LogDir", "parent_logdir"),
            ("#Results", "total_results"),
            ("#Success", "successes"),
            ("#Steps", "total_steps"),
        ]

        rows = [
            [
                str(r.id),
                _human_ts(r.created_at),
                r.comment or "",
                r.parent_logdir,
                str(int(r.total_results)),
                str(int(r.successes)),
                str(int(r.total_steps or 0)),
            ]
            for r in runs
        ]
        headers = [h for h, _ in header_field_mapping]
        print(_build_table(rows, headers))


# ------------------------------------------------------------------ #
# show-run
# ------------------------------------------------------------------ #
def show_run_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    run_id = args.run_id

    with get_session() as session:
        run = get_run(session, run_id)
        if run is None:
            print(f"[!] Run ID {run_id} not found in {db_path}")
            return

        # Calculate total cost for the run
        total_cost = sum(r.model_costs for r in run.results)

        run_rows = [
            ["ID", str(run.id)],
            ["Created", _human_ts(run.created_at)],  # type: ignore[arg-type]
            ["Comment", run.comment or ""],  # type: ignore[misc]
            ["Parent LogDir", run.parent_logdir],
            ["# Results", str(len(run.results))],
            ["# Success", str(sum(1 for r in run.results if r.success))],
            ["Total Cost ($)", f"{total_cost:.4f}"],
        ]
        print("RUN SUMMARY")
        print(_build_table(run_rows))
        print()

        res_rows = [
            [
                str(r.id),
                r.eval_name,
                "✔" if r.success else "✘",
                f"{r.steps}/{r.max_steps}",
                r.model_name,
                f"{r.model_costs:.4f}",
                r.log_filepath,
                _human_ts(r.created_at),
            ]
            for r in run.results
        ]
        if res_rows:
            headers = [
                "ID",
                "Eval Name",
                "Ok?",
                "Steps",
                "Model",
                "Cost ($)",
                "Log FilePath",
                "Created",
            ]
            print(_build_table(res_rows, headers))
        else:
            print("<no child PentestResult rows>")

        # Display steps for each result in a columnar format
        # if run.results:
        #     print()
        #     print("STEPS BY RESULT")
            
        #     # Collect all steps for each result
        #     all_result_steps = []
        #     for result in run.results:
        #         steps = get_steps_for_result(session, result.id)
        #         all_result_steps.append(steps or [])
            
        #     # Find the maximum number of steps across all results
        #     max_steps = max((len(steps) for steps in all_result_steps), default=0)
            
        #     if max_steps > 0:
        #         # Build headers: Step # + one column per result
        #         step_headers = ["Step #"] + [f"{r.eval_name}" for r in run.results]
                
        #         # Build rows: each row represents a step number
        #         step_rows = []
        #         for step_idx in range(max_steps):
        #             row = [str(step_idx + 1)]  # Step number (1-indexed)
        #             for result_steps in all_result_steps:
        #                 if step_idx < len(result_steps):
        #                     step = result_steps[step_idx]
        #                     # Truncate long reflections for table display
        #                     reflection = step.step_type or ""
        #                     if len(reflection) > 50:
        #                         reflection = reflection[:47] + "..."
        #                     row.append(reflection)
        #                 else:
        #                     row.append("")  # Empty cell if this result has fewer steps
        #             step_rows.append(row)
                
        #         print(_build_table(step_rows, step_headers))
        #     else:
        #         print("<no steps found for any results>")


# ------------------------------------------------------------------ #
# show-run-detailed
# ------------------------------------------------------------------ #
def show_run_detailed_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    run_id = args.run_id

    with get_session() as session:
        run = get_run(session, run_id)
        if run is None:
            print(f"[!] Run ID {run_id} not found in {db_path}")
            return
        
        print(f"DETAILED STEPS FOR RUN {run_id} ({run.comment or 'no comment'})") # type: ignore[misc]
        
        if not run.results:
            print("<no child PentestResult rows>")
            return

        for result in run.results:
            print("\n" + ("-"*80))
            print(f"PENTEST RESULT {result.id}: {result.eval_name} {'(Success)' if result.success else '(Failure)'}")
            print(f"Log: {result.log_filepath}")
            print(f"Model: {result.model_name}, Cost: ${result.model_costs:.4f}")
            print("-" * 80)
            
            steps = get_steps_for_result(session, result.id)
            if not steps:
                print("<no steps for this result>")
                continue

            headers = ["#", "Type", "Description"]
            rows = [
                [
                    str(step.step_number),
                    step.step_type or "",
                    step.step_descr or ""
                ]
                for step in steps
            ]
            print(_build_table(rows, headers, max_col=80))


# ------------------------------------------------------------------ #
# show-steps
# ------------------------------------------------------------------ #
def _parse_transition(expr: str) -> list[str]:
    """
    Parse '--transition "S1 -> S2 -> ... -> SN"' into a list of states.
    Whitespace is stripped and case is preserved exactly as written.
    """
    return [tok.strip() for tok in expr.split("->") if tok.strip()]


def _match_transition(steps: list[AgentStep], states: list[str]) -> list[list[AgentStep]]:
    """
    Return a list of *contiguous* AgentStep slices whose .step_type sequence
    equals the `states` pattern.

    Example:
        states == ["PROBING", "SUSPECT"]
        matches  = [[step3, step4], [step10, step11], ...]
    """
    k = len(states)
    matches: list[list[AgentStep]] = []
    for i in range(len(steps) - k + 1):
        window = steps[i : i + k]
        if all((s.step_type or "") == states[j] for j, s in enumerate(window)):
            matches.append(window)
    return matches


def search_steps_cmd(args: Namespace) -> None:
    """
    Search for step‑type transitions in AgentStep rows.

    Required:
        --run-id RUN_ID      search all PentestResults in that run
            *or*
        --result-id RESULT_ID  search only that PentestResult

    Optional:
        --transition "S1 -> ... -> SN"
        --reflection     print reflection text
        --script         print script text
        --output         print add_to_scratchpad text
    """
    db_path = Path(args.db or DEFAULT_DB_FILE)

    if not args.run_id and not args.result_id:
        print("[!] Either --run-id or --result-id is required")
        return

    states: list[str] = _parse_transition(args.transition) if args.transition else []

    # True if user asked for any selective content flags
    selective_fields = args.script or args.output or args.reflection

    with get_session() as session:
        # Collect PentestResult objects to inspect
        results: list[PentestResult] = []

        if args.run_id:
            run = get_run(session, args.run_id)
            if run is None:
                print(f"[!] Run ID {args.run_id} not found in {db_path}")
                return
            results.extend(run.results)

        if args.result_id:
            res = session.query(PentestResult).filter(PentestResult.id == args.result_id).first()
            if res is None:
                print(f"[!] PentestResult ID {args.result_id} not found in {db_path}")
                return
            results.append(res)

        if not results:
            print("<no PentestResult rows to search>")
            return

        # Collect all output into a single string
        output_parts: list[str] = []
        total_groups = 0

        for result in results:
            steps = get_steps_for_result(session, result.id) or []
            if not steps:
                continue

            # Either search for transitions or fall back to "all steps" when no pattern supplied
            step_groups: list[list[AgentStep]]
            if states:
                step_groups = _match_transition(steps, states)
            else:
                # Treat every individual step as its own "group"
                step_groups = [[s] for s in steps]

            if not step_groups:
                continue  # nothing matched in this result

            total_groups += len(step_groups)

            output_parts.append("\n" + ("=" * 80))
            output_parts.append(f"PENTEST RESULT {result.id}  |  {result.eval_name}")
            output_parts.append(f"Model: {result.model_name}  |  Cost: ${result.model_costs:.4f}")
            output_parts.append("=" * 80)

            for group in step_groups:
                first, last = group[0], group[-1]
                step_types = [str(s.step_type) if s.step_type else "" for s in group]
                header = f"Transition match: steps {first.step_number}‒{last.step_number}  ({' -> '.join(step_types)})"
                output_parts.append(header)
                output_parts.append("-" * len(header))

                for step in group:
                    if not selective_fields:
                        step_type = str(step.step_type) if step.step_type else ""
                        step_descr = str(step.step_descr) if step.step_descr else ""
                        output_parts.append(f"[{step.step_number}]  {step_type}  {step_descr}")
                        output_parts.append(f"Created: {_human_ts(step.created_at)}")
                        if step.add_to_scratchpad:
                            output_parts.append(f"Scratchpad: {step.add_to_scratchpad}")
                        output_parts.append("\nReflection:")
                        output_parts.append(str(step.reflection))
                        output_parts.append("\nScript:")
                        output_parts.append(str(step.script))
                        output_parts.append("-" * 40)
                    else:
                        parts: list[str] = []
                        if args.reflection and step.reflection:
                            parts.append(str(step.reflection))
                        if args.script and step.script:
                            parts.append(str(step.script))
                        if args.output and step.execution_output:
                            parts.append(str(step.execution_output))
                        output_parts.append("\n---\n".join(parts))
                        output_parts.append("-" * 40)

        # Join all output parts and print once
        final_output = "\n".join(output_parts)
        print(final_output)

        print(f"Total groups returned: {total_groups}")
        print(f"Total tokens: {get_token_count(final_output)}")

# ------------------------------------------------------------------ #
# cost
# ------------------------------------------------------------------ #
def cost_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)

    with get_session() as session:
        today_cost, week_cost, per_model = get_cost_summary(session)

    print("\nCOST SUMMARY (UTC)")
    print("------------------")
    print(f"Total cost TODAY       : $ {today_cost:.4f}")
    print(f"Total cost THIS WEEK   : $ {week_cost:.4f}\n")

    if per_model:
        headers = ["Model", "Total Cost ($)", "Total Steps", "Avg/Step ($)"]
        rows = [
            [model, f"{total:.4f}", str(steps), f"{avg:.6f}"]
            for model, total, steps, avg in per_model
        ]
        print("PER-MODEL AVERAGES")
        print(_build_table(rows, headers))
    else:
        print("<no PentestResult rows in database>")


# ------------------------------------------------------------------ #
# delete-runs
# ------------------------------------------------------------------ #
def delete_runs_cmd(args: Namespace) -> None:
    """Delete one or more runs by ID.
    
    Can delete a single run or a range of runs (inclusive).
    """
    from pentest_bot.db import delete_run
    
    db_path = Path(args.db or DEFAULT_DB_FILE)
    run_ids = args.run_ids
    
    if len(run_ids) == 1:
        # Single run deletion
        run_id = run_ids[0]
        with get_session() as session:
            if delete_run(session, run_id):
                print(f"[+] Deleted run {run_id}")
            else:
                print(f"[!] Run {run_id} not found")
    elif len(run_ids) == 2:
        # Range deletion
        start_id, end_id = run_ids
        if start_id > end_id:
            print(f"[!] Invalid range: {start_id} > {end_id}")
            return
        
        deleted_count = 0
        not_found_count = 0
        
        with get_session() as session:
            for run_id in range(start_id, end_id + 1):
                if delete_run(session, run_id):
                    deleted_count += 1
                    print(f"[+] Deleted run {run_id}")
                else:
                    not_found_count += 1
                    print(f"[!] Run {run_id} not found")
        
        print(f"\nSummary: {deleted_count} runs deleted, {not_found_count} not found")
    else:
        print("[!] Please provide either 1 run ID or 2 run IDs (start end)")


# ---------------------------------------------------------------------------
# NEW: ad‑hoc SQL execution command
# ---------------------------------------------------------------------------

def q_db_cmd(args: Namespace) -> None:
    """Execute a raw SQL query against the selected database.

    This command is primarily intended for read‑only `SELECT` statements but
    will also execute `INSERT`, `UPDATE`, or `DELETE` operations.  For write
    queries the transaction is committed automatically and the affected row
    count is reported.
    """
    from sqlalchemy import text

    db_path = Path(args.db or DEFAULT_DB_FILE)
    sql = " ".join(args.sql)

    with get_session() as session:
        result = session.execute(text(sql))

        if result.cursor is not None:  # type: ignore[attr-defined]
            rows_raw = result.fetchall()
            if not rows_raw:
                print("<empty result set>")
                return

            headers = list(result.keys())
            rows = [["" if cell is None else str(cell) for cell in row] for row in rows_raw]
            print(_build_table(rows, headers))
        else:  # Data‑modifying query
            session.commit()
            print(f"[+] Query OK, {result.rowcount} rows affected.") # type: ignore[attr-defined]




# ---------------------------------------------------------------------------
# Argument parsing & main entry‑point
# ---------------------------------------------------------------------------


def _build_parser() -> ArgumentParser:
    p = ArgumentParser(description="ASCII CLI for PentestBot SQLite database")
    p.add_argument("--db", help="Path to alternate pentest_bot.sqlite file")
    p.add_argument("--out", type=str, help="Optional filepath to redirect output to.")

    sub = p.add_subparsers(dest="cmd", required=True)

    # list‑runs ------------------------------------------------------------- #
    list_p = sub.add_parser("list-runs", help="List recent runs")
    list_p.set_defaults(func=list_runs_cmd)
    list_p.add_argument("--all", action="store_true", help="Show *all* runs including non-eval runs (ignore --limit)")
    list_p.add_argument("--limit", type=int, default=10, help="Max rows (default: 10)")

    # show‑run -------------------------------------------------------------- #
    show_p = sub.add_parser("show-run", help="Show a single run in detail")
    show_p.set_defaults(func=show_run_cmd)
    show_p.add_argument("run_id", type=int, help="ID of the Run to display")

    # show-run-detailed ----------------------------------------------------- #
    show_detailed_p = sub.add_parser("show-run-detailed", help="Show detailed steps for each result in a run")
    show_detailed_p.set_defaults(func=show_run_detailed_cmd)
    show_detailed_p.add_argument("run_id", type=int, help="ID of the Run to display")

    # show-steps ------------------------------------------------------------ #
    steps_p = sub.add_parser("search-steps", help="Search for step-type transitions in AgentStep rows")
    steps_p.set_defaults(func=search_steps_cmd)
    steps_p.add_argument("--run-id", type=int, help="Search all PentestResults in that run")
    steps_p.add_argument("--result-id", type=int, help="Search only that PentestResult")
    steps_p.add_argument("--transition", type=str, help="Transition pattern like 'S1 -> S2 -> ... -> SN'")
    steps_p.add_argument("--reflection", action="store_true", help="Print reflection text")
    steps_p.add_argument("--script", action="store_true", help="Print script text")
    steps_p.add_argument("--output", action="store_true", help="Print add_to_scratchpad text")

    # delete-runs ----------------------------------------------------------- #
    delete_p = sub.add_parser("delete-runs", help="Delete one or more runs by ID")
    delete_p.set_defaults(func=delete_runs_cmd)
    delete_p.add_argument("run_ids", type=int, nargs="+", help="Run ID(s) to delete. Single ID or start/end range (inclusive)")

    # q_db ------------------------------------------------------------------ #
    q_p = sub.add_parser("q_db", help="Execute raw SQL against the database")
    q_p.set_defaults(func=q_db_cmd)
    q_p.add_argument("sql", nargs="+", help="SQL query to execute (wrap in quotes if it contains spaces)")

    # cost ------------------------------------------------------------------ #
    cost_p = sub.add_parser("cost", help="Show usage costs and per-model averages")
    cost_p.set_defaults(func=cost_cmd)

    return p

@contextmanager
def _maybe_redirect_stdout(filepath: str | None):
    """A context manager that redirects stdout to a file if a path is provided."""
    if filepath:
        with open(filepath, "w", encoding="utf-8") as f:
            with redirect_stdout(f):
                yield
    else:
        yield

def main(argv: Sequence[str] | None = None) -> None:  # pragma: no‑cover
    parser = _build_parser()
    args = parser.parse_args(argv)
    with _maybe_redirect_stdout(args.out):
        args.func(args)  # type: ignore[attr-defined]


if __name__ == "__main__":
    main() 