#!/usr/bin/env python
"""PentestBot SQLite CLI

A light‑weight, zero‑dependency command‑line utility for exploring the
`pentest_bot.sqlite` database.  It provides a Windows‑friendly ASCII
interface that also works unmodified on Linux/OS X terminals.

Usage examples
--------------
List the most recent 10 runs (default)::

    python pentest_cli.py list-runs

List ALL runs::

    python pentest_cli.py list-runs --all

Display a specific run together with its child ``PentestResult`` rows::

    python pentest_cli.py show-run 42

Execute an ad‑hoc SQL query (wrap the query in quotes)::

    python pentest_cli.py q_db "SELECT id, comment FROM Run LIMIT 5"

Point to a custom database file::

    python pentest_cli.py list-runs --db path/to/alt.sqlite

This module assumes that the schema definitions (``Run``/``PentestResult``)
reside in a sibling module named ``pentest_db.py``.  Adjust
``DB_MODULE`` below if your file is named differently.
"""
from __future__ import annotations

from argparse import ArgumentParser, Namespace
from contextlib import contextmanager
from datetime import datetime, timedelta
from importlib import import_module
from pathlib import Path
from typing import Iterable, List, Sequence

# ---------------------------------------------------------------------------
# Configuration – tweak these to match local layout
# ---------------------------------------------------------------------------
DB_MODULE = "pentest_bot.db"  # file that defines `engine`, `SessionLocal`, `Run`, …
DEFAULT_DB_FILE = Path(__file__).parent.parent / "pentest_bot.sqlite"
# ---------------------------------------------------------------------------
# Helper: lazy‑import the application DB module
# ---------------------------------------------------------------------------
_db_cache: dict[Path, tuple] = {}


def _load_db(db_path: Path):
    """Return (SessionLocal, Run, PentestResult, AgentStep) from the target database.

    The function monkey‑patches the underlying SQLAlchemy ``engine`` so that
    we can reuse the ORM models with **any** SQLite file chosen at runtime.
    """
    if db_path in _db_cache:
        return _db_cache[db_path]

    db_mod = import_module(DB_MODULE)

    # Monkey‑patch the engine used by the ORM.  This avoids having to fork the
    # schema definitions for each database file.
    from sqlalchemy import create_engine

    db_mod.engine.dispose()  # close previous connections, if any
    db_mod.engine = create_engine(f"sqlite:///{db_path}", connect_args={"check_same_thread": False})
    db_mod.SessionLocal.configure(bind=db_mod.engine)  # type: ignore[attr-defined]

    _db_cache[db_path] = (db_mod.SessionLocal, db_mod.Run, db_mod.PentestResult, db_mod.AgentStep)
    return _db_cache[db_path]


@contextmanager
def _session_ctx(db_path: Path):
    SessionLocal, _, _, _ = _load_db(db_path)
    session = SessionLocal()
    try:
        yield session
    finally:
        session.close()


# ---------------------------------------------------------------------------
# Plain‑ASCII table formatter (Windows‑friendly, no fancy Unicode)
# ---------------------------------------------------------------------------

def _build_table(rows: Sequence[Sequence[str]], headers: Sequence[str] | None = None, max_col: int = 50) -> str:
    """Return an ASCII table as a single string.

    The function calculates column widths from the *longest* cell in each
    column and then draws the grid using ``+``/``-``/``|`` glyphs which render
    correctly even in the Windows 10/11 default console font.
    
    Args:
        rows: The data rows to display
        headers: Optional column headers
        max_col: Maximum width for any column; longer content is truncated with "..."
    """
    if not rows and not headers:
        return "<empty>"

    # Ensure we have at least one row to compute widths
    sample = rows[0] if rows else ["" for _ in headers]  # type: ignore[arg-type]
    col_count = len(headers or sample)

    widths: List[int] = [0] * col_count
    for col_idx in range(col_count):
        header_len = len(headers[col_idx]) if headers else 0  # type: ignore[index]
        max_cell = max((len(r[col_idx]) for r in rows), default=0)
        widths[col_idx] = min(max(header_len, max_cell), max_col)

    def _separator(char: str = "-") -> str:
        return "+" + "+".join(char * (w + 2) for w in widths) + "+"

    def _truncate_cell(cell: str, width: int) -> str:
        if len(cell) <= width:
            return cell
        return cell[:width-3] + "..."

    def _format_row(row: Sequence[str]) -> str:
        return "| " + " | ".join(_truncate_cell(cell, widths[i]).ljust(widths[i]) for i, cell in enumerate(row)) + " |"

    parts: List[str] = [
        _separator(),
    ]
    if headers:
        parts.append(_format_row(headers))
        parts.append(_separator("="))
    for r in rows:
        parts.append(_format_row(r))
        parts.append(_separator())
    return "\n".join(parts)


# ---------------------------------------------------------------------------
# CLI commands
# ---------------------------------------------------------------------------

from sqlalchemy import func, case


def _human_ts(ts: datetime | None) -> str:
    return ts.strftime("%Y-%m-%d %H:%M:%S") if ts else "—"


def list_runs_cmd(args: Namespace) -> None:
    """List recent (or all) runs with aggregate success counts."""
    db_path = Path(args.db or DEFAULT_DB_FILE)
    limit = None if args.all else args.limit

    with _session_ctx(db_path) as session:
        _, Run, PentestResult, _ = _load_db(db_path)  # noqa: N806  (PascalCase from ORM)

        # Build a single aggregate query: total results & successes per Run
        qry = (
            session.query(
                Run.id.label("id"),
                Run.created_at.label("created_at"),
                Run.comment.label("comment"),
                Run.parent_logdir.label("parent_logdir"),
                func.count(PentestResult.id).label("total_results"),
                func.sum(case((PentestResult.success.is_(True), 1), else_=0)).label("successes"),
                func.sum(PentestResult.steps).label("total_steps"),
            )
            .outerjoin(PentestResult)
            .group_by(Run.id)
            .order_by(Run.created_at.desc())
        )

        if limit is not None:
            qry = qry.limit(limit)

        # Define expected headers and corresponding field mappings
        header_field_mapping = [
            ("ID", "id"),
            ("Created", "created_at"),
            ("Comment", "comment"),
            ("LogDir", "parent_logdir"),
            ("#Results", "total_results"),
            ("#Success", "successes"),
            ("#Steps", "total_steps"),
        ]

        query_results = qry.all()
        if query_results:
            first_result = query_results[0]
            for header, field_name in header_field_mapping:
                if not hasattr(first_result, field_name):
                    raise AttributeError(
                        f"Query result missing expected field '{field_name}' for header '{header}'. "
                        "Database schema may have changed."
                    )

        rows = [
            [
                str(getattr(r, "id")),
                _human_ts(getattr(r, "created_at")),
                getattr(r, "comment") or "",
                getattr(r, "parent_logdir"),
                str(int(getattr(r, "total_results"))),
                str(int(getattr(r, "successes"))),
                str(int(getattr(r, "total_steps") or 0)),
            ]
            for r in query_results
        ]

    headers = [header for header, _ in header_field_mapping]
    print(_build_table(rows, headers))


def show_run_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    run_id = args.run_id

    with _session_ctx(db_path) as session:
        _, Run, PentestResult, _ = _load_db(db_path)  # noqa: N806
        run = session.query(Run).filter(Run.id == run_id).first()
        if run is None:
            print(f"[!] Run ID {run_id} not found in {db_path}")
            return

        # Render parent Run row as a key/value table
        run_rows = [
            ["ID", str(run.id)],
            ["Created", _human_ts(run.created_at)],
            ["Comment", run.comment or ""],
            ["Parent LogDir", run.parent_logdir],
            ["# Results", str(len(run.results))],
            ["# Success", str(sum(1 for r in run.results if r.success))],
        ]
        print("RUN SUMMARY")
        print(_build_table(run_rows))
        print()

        # Child PentestResults table
        res_rows = [
            [
                str(r.id),
                r.eval_name,
                "✔" if r.success else "✘",
                f"{r.steps}/{r.max_steps}",
                r.model_name,
                f"{r.model_costs:.4f}",
                r.log_filepath,
                _human_ts(r.created_at),
            ]
            for r in run.results
        ]
        if res_rows:
            headers = [
                "ID",
                "Eval Name",
                "Ok?",
                "Steps",
                "Model",
                "Cost ($)",
                "Log FilePath",
                "Created",
            ]
            print(_build_table(res_rows, headers))
        else:
            print("<no child PentestResult rows>")


def show_steps_cmd(args: Namespace) -> None:
    """Show agent steps for a single PentestResult."""
    db_path = Path(args.db or DEFAULT_DB_FILE)
    result_id = args.result_id

    with _session_ctx(db_path) as session:
        _, _, PentestResult, AgentStep = _load_db(db_path)  # noqa: N806
        result = session.query(PentestResult).filter(PentestResult.id == result_id).first()
        if result is None:
            print(f"[!] PentestResult ID {result_id} not found in {db_path}")
            return

        steps = sorted(result.agent_steps, key=lambda s: s.step_number)

        if not steps:
            print(f"<no AgentStep rows for PentestResult ID {result_id}>")
            return

        print(f"\nAGENT STEPS FOR PENTEST RESULT {result_id} (eval: {result.eval_name})")

        for step in steps:
            print("--------------------------------------------------------------------------------")
            print(f"Step: {step.step_number}  |  Created: {_human_ts(step.created_at)}")
            if step.add_to_scratchpad:
                print(f"Scratchpad: {step.add_to_scratchpad}")
            print("\nReflection:")
            print(step.reflection)
            print("\nScript:")
            print(step.script)
        print("--------------------------------------------------------------------------------")


# ---------------------------------------------------------------------------
# NEW: ad‑hoc SQL execution command
# ---------------------------------------------------------------------------

def q_db_cmd(args: Namespace) -> None:
    """Execute a raw SQL query against the selected database.

    This command is primarily intended for read‑only `SELECT` statements but
    will also execute `INSERT`, `UPDATE`, or `DELETE` operations.  For write
    queries the transaction is committed automatically and the affected row
    count is reported.
    """
    from sqlalchemy import text

    db_path = Path(args.db or DEFAULT_DB_FILE)
    sql = " ".join(args.sql)

    with _session_ctx(db_path) as session:
        result = session.execute(text(sql))

        if result.returns_rows:  # SELECT (or similar) query
            rows_raw = result.fetchall()
            if not rows_raw:
                print("<empty result set>")
                return

            headers = list(result.keys())
            rows = [["" if cell is None else str(cell) for cell in row] for row in rows_raw]
            print(_build_table(rows, headers))
        else:  # Data‑modifying query
            session.commit()
            print(f"[+] Query OK, {result.rowcount} rows affected.")


def cost_cmd(args: Namespace) -> None:
    """Print usage costs (today, this week, and per-model averages)."""
    from sqlalchemy import func, case

    db_path = Path(args.db or DEFAULT_DB_FILE)

    # Time windows in UTC
    now = datetime.utcnow()
    today_start = datetime(now.year, now.month, now.day)
    tomorrow_start = today_start + timedelta(days=1)

    # Monday 00:00 of current week → next Monday 00:00
    monday_start = today_start - timedelta(days=today_start.weekday())
    next_monday = monday_start + timedelta(days=7)

    with _session_ctx(db_path) as session:
        _, _, PentestResult, _ = _load_db(db_path)

        # Total cost today
        today_cost = session.query(
            func.coalesce(func.sum(PentestResult.model_costs), 0.0)
        ).filter(
            PentestResult.created_at >= today_start,
            PentestResult.created_at < tomorrow_start,
        ).scalar()  # type: ignore[assignment]

        # Total cost this week (Mon-Sun)
        week_cost = session.query(
            func.coalesce(func.sum(PentestResult.model_costs), 0.0)
        ).filter(
            PentestResult.created_at >= monday_start,
            PentestResult.created_at < next_monday,
        ).scalar()  # type: ignore[assignment]

        # Per-model averages  (total_cost / total_steps)
        per_model = (
            session.query(
                PentestResult.model_name.label("model"),
                func.sum(PentestResult.model_costs).label("total_cost"),
                func.sum(PentestResult.steps).label("total_steps"),
            )
            .group_by(PentestResult.model_name)
            .all()
        )

    print("\nCOST SUMMARY (UTC)")
    print("------------------")
    print(f"Total cost TODAY       : $ {today_cost:.4f}")
    print(f"Total cost THIS WEEK   : $ {week_cost:.4f}\n")

    if per_model:
        headers = ["Model", "Total Cost ($)", "Total Steps", "Avg/Step ($)"]
        rows = []
        for r in per_model:
            total_cost = float(r.total_cost or 0)
            total_steps = int(r.total_steps or 0)
            avg = total_cost / total_steps if total_steps else 0.0
            rows.append([
                r.model,
                f"{total_cost:.4f}",
                str(total_steps),
                f"{avg:.6f}",
            ])
        print("PER-MODEL AVERAGES")
        print(_build_table(rows, headers))
    else:
        print("<no PentestResult rows in database>")


# ---------------------------------------------------------------------------
# Argument parsing & main entry‑point
# ---------------------------------------------------------------------------


def _build_parser() -> ArgumentParser:
    p = ArgumentParser(description="ASCII CLI for PentestBot SQLite database")
    p.add_argument("--db", help="Path to alternate pentest_bot.sqlite file")

    sub = p.add_subparsers(dest="cmd", required=True)

    # list‑runs ------------------------------------------------------------- #
    list_p = sub.add_parser("list-runs", help="List recent runs")
    list_p.set_defaults(func=list_runs_cmd)
    list_p.add_argument("--all", action="store_true", help="Show *all* runs (ignore --limit)")
    list_p.add_argument("--limit", type=int, default=10, help="Max rows (default: 10)")

    # show‑run -------------------------------------------------------------- #
    show_p = sub.add_parser("show-run", help="Show a single run in detail")
    show_p.set_defaults(func=show_run_cmd)
    show_p.add_argument("run_id", type=int, help="ID of the Run to display")

    # show-steps ------------------------------------------------------------ #
    steps_p = sub.add_parser("show-steps", help="Show agent steps for a single pentest result")
    steps_p.set_defaults(func=show_steps_cmd)
    steps_p.add_argument("result_id", type=int, help="ID of the PentestResult to display steps for")

    # q_db ------------------------------------------------------------------ #
    q_p = sub.add_parser("q_db", help="Execute raw SQL against the database")
    q_p.set_defaults(func=q_db_cmd)
    q_p.add_argument("sql", nargs="+", help="SQL query to execute (wrap in quotes if it contains spaces)")

    # cost ------------------------------------------------------------------ #
    cost_p = sub.add_parser("cost", help="Show usage costs and per-model averages")
    cost_p.set_defaults(func=cost_cmd)

    return p


def main(argv: Sequence[str] | None = None) -> None:  # pragma: no‑cover
    parser = _build_parser()
    args = parser.parse_args(argv)
    args.func(args)  # type: ignore[attr-defined]


if __name__ == "__main__":
    main()
