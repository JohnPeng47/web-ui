#!/usr/bin/env python
"""PentestBot SQLite CLI

A light‑weight, zero‑dependency command‑line utility for exploring the
`pentest_bot.sqlite` database.  It provides a Windows‑friendly ASCII
interface that also works unmodified on Linux/OS X terminals.

Usage examples
--------------
List the most recent 10 runs (default)::

    python pentest_cli.py list-runs

List ALL runs::

    python pentest_cli.py list-runs --all

Display a specific run together with its child ``PentestResult`` rows::

    python pentest_cli.py show-run 42

Execute an ad‑hoc SQL query (wrap the query in quotes)::

    python pentest_cli.py q_db "SELECT id, comment FROM Run LIMIT 5"

Point to a custom database file::

    python pentest_cli.py list-runs --db path/to/alt.sqlite

This module assumes that the schema definitions (``Run``/``PentestResult``)
reside in a sibling module named ``pentest_db.py``.  Adjust
``DB_MODULE`` below if your file is named differently.
"""
from __future__ import annotations

from argparse import ArgumentParser, Namespace
from contextlib import contextmanager, redirect_stdout
from datetime import datetime, timedelta
from importlib import import_module
from pathlib import Path
from typing import Iterable, List, Sequence

from pentest_bot.db import get_session
from pentest_bot.db.tables.agent import (
    AgentStepORM,
    PentestResultORM,
    get_runs_summary,
    get_run,
    get_agent_ctxt,
    get_cost_summary,
)
from pentest_bot.web_exploit.utils import get_token_count
from pentest_bot.web_exploit.agent_step import StepStateAbbr

from .search_steps import search_steps

# ---------------------------------------------------------------------------
# Configuration – tweak these to match local layout
# ---------------------------------------------------------------------------
DB_MODULE = "pentest_bot.db"  # file that defines `engine`, `SessionLocal`, `Run`, …
DEFAULT_DB_FILE = Path(__file__).parent.parent / "pentest_bot.sqlite"
# ---------------------------------------------------------------------------
# Helper: lazy‑import the application DB module
# ---------------------------------------------------------------------------
_db_cache: dict[Path, tuple] = {}


def _load_db(db_path: Path):
    """Return (SessionLocal, Run, PentestResult, AgentStep) from the target database.

    The function monkey‑patches the underlying SQLAlchemy ``engine`` so that
    we can reuse the ORM models with **any** SQLite file chosen at runtime.
    """
    if db_path in _db_cache:
        return _db_cache[db_path]

    db_mod = import_module(DB_MODULE)

    # Monkey‑patch the engine used by the ORM.  This avoids having to fork the
    # schema definitions for each database file.
    from sqlalchemy import create_engine

    db_mod.engine.dispose()  # close previous connections, if any
    setattr(db_mod, "engine", create_engine(f"sqlite:///{db_path}", connect_args={"check_same_thread": False}))
    db_mod.SessionLocal.configure(bind=db_mod.engine)  # type: ignore[attr-defined]

    _db_cache[db_path] = (db_mod.SessionLocal, db_mod.Run, db_mod.PentestResult, db_mod.AgentStep)
    return _db_cache[db_path]


# ---------------------------------------------------------------------------
# Plain‑ASCII table formatter (Windows‑friendly, no fancy Unicode)
# ---------------------------------------------------------------------------

def _build_table(rows: Sequence[Sequence[str]], headers: Sequence[str] | None = None, max_col: int = 50) -> str:
    """Return an ASCII table as a single string.

    The function calculates column widths from the *longest* cell in each
    column and then draws the grid using ``+``/``-``/``|`` glyphs which render
    correctly even in the Windows 10/11 default console font.
    
    Args:
        rows: The data rows to display
        headers: Optional column headers
        max_col: Maximum width for any column; longer content is truncated with "..."
    """
    if not rows and not headers:
        return "<empty>"

    # Ensure we have at least one row to compute widths
    sample = rows[0] if rows else ["" for _ in headers]  # type: ignore[arg-type]
    col_count = len(headers or sample)

    widths: List[int] = [0] * col_count
    for col_idx in range(col_count):
        header_len = len(headers[col_idx]) if headers else 0  # type: ignore[index]
        max_cell = max((len(r[col_idx]) for r in rows), default=0)
        widths[col_idx] = min(max(header_len, max_cell), max_col)

    def _separator(char: str = "-") -> str:
        return "+" + "+".join(char * (w + 2) for w in widths) + "+"

    def _truncate_cell(cell: str, width: int) -> str:
        if len(cell) <= width:
            return cell
        return cell[:width-3] + "..."

    def _format_row(row: Sequence[str]) -> str:
        return "| " + " | ".join(_truncate_cell(cell, widths[i]).ljust(widths[i]) for i, cell in enumerate(row)) + " |"

    parts: List[str] = [
        _separator(),
    ]
    if headers:
        parts.append(_format_row(headers))
        parts.append(_separator("="))
    for r in rows:
        parts.append(_format_row(r))
        parts.append(_separator())
    return "\n".join(parts)


# ---------------------------------------------------------------------------
# CLI commands
# ---------------------------------------------------------------------------

from sqlalchemy import func, case


def _human_ts(ts: datetime | None) -> str:
    return ts.strftime("%Y-%m-%d %H:%M:%S") if ts else "—"


def list_runs_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    limit = None if args.all else args.limit

    with get_session() as session:
        # REFRACTOR ►  use query helper
        runs = get_runs_summary(session, limit=limit, eval_only=not args.all)

        header_field_mapping = [
            ("ID", "id"),
            ("Created", "created_at"),
            ("Comment", "comment"),
            ("LogDir", "parent_logdir"),
            ("#Results", "total_results"),
            ("#Success", "successes"),
            ("#Steps", "total_steps"),
        ]

        rows = [
            [
                str(r.id),
                _human_ts(r.created_at),
                r.comment or "",
                r.parent_logdir,
                str(int(r.total_results)),
                str(int(r.successes)),
                str(int(r.total_steps or 0)),
            ]
            for r in runs
        ]
        headers = [h for h, _ in header_field_mapping]
        print(_build_table(rows, headers))


# ------------------------------------------------------------------ #
# show-run
# ------------------------------------------------------------------ #
def show_run_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    run_id = args.run_id

    with get_session() as session:
        run = get_run(session, run_id)
        if run is None:
            print(f"[!] Run ID {run_id} not found in {db_path}")
            return

        # Calculate total cost for the run
        total_cost = sum(r.model_costs for r in run.results)

        run_rows = [
            ["ID", str(run.id)],
            ["Created", _human_ts(run.created_at)],  # type: ignore[arg-type]
            ["Comment", run.comment or ""],  # type: ignore[misc]
            ["Parent LogDir", run.parent_logdir],
            ["# Results", str(len(run.results))],
            ["# Success", str(sum(1 for r in run.results if r.success))],
            ["Total Cost ($)", f"{total_cost:.4f}"],
        ]
        print("RUN SUMMARY")
        print(_build_table(run_rows))
        print()

        res_rows = [
            [
                str(r.id),
                r.eval_name,
                "✔" if r.success else "✘",
                f"{r.steps}/{r.max_steps}",
                r.model_name,
                f"{r.model_costs:.4f}",
                r.log_filepath,
                _human_ts(r.created_at),
            ]
            for r in run.results
        ]
        if res_rows:
            headers = [
                "ID",
                "Eval Name",
                "Ok?",
                "Steps",
                "Model",
                "Cost ($)",
                "Log FilePath",
                "Created",
            ]
            print(_build_table(res_rows, headers))
        else:
            print("<no child PentestResult rows>")
            return

        # Print step state legend and traces
        from pentest_bot.web_exploit.agent_step import StepStateAbbr
        
        print()
        print("STEP STATE LEGEND")
        legend_items = [f"{abbr}={state.value}" for state, abbr in StepStateAbbr.items()]
        print(" | ".join(legend_items))
        print()

        print("STEP TRACES")
        for result in run.results:
            success = "✔" if result.success else "✘"
            ctxt = get_agent_ctxt(session, result.id)
            if ctxt and ctxt.steps():
                step_abbrs = []
                for step in ctxt.steps():
                    if step.step_type and step.step_type in StepStateAbbr:
                        step_abbrs.append(StepStateAbbr[step.step_type])
                    else:
                        step_abbrs.append("?")
                trace = " -> ".join(step_abbrs)
                print(f"Result {result.id} [{success}]: {trace}")
            else:
                print(f"Result {result.id} [{success}]: <no steps>")

            


# ------------------------------------------------------------------ #
# show-run-detailed
# ------------------------------------------------------------------ #
def show_run_detailed_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    run_id = args.run_id

    with get_session() as session:
        run = get_run(session, run_id)
        if run is None:
            print(f"[!] Run ID {run_id} not found in {db_path}")
            return
        
        print(f"DETAILED STEPS FOR RUN {run_id} ({run.comment or 'no comment'})") # type: ignore[misc]
        
        if not run.results:
            print("<no child PentestResult rows>")
            return

        for result in run.results:
            print("\n" + ("-"*80))
            print(f"PENTEST RESULT {result.id}: {result.eval_name} {'(Success)' if result.success else '(Failure)'}")
            print(f"Log: {result.log_filepath}")
            print(f"Model: {result.model_name}, Cost: ${result.model_costs:.4f}")
            print("-" * 80)
            
            ctxt = get_agent_ctxt(session, result.id)
            if not ctxt:
                print("<no steps for this result>")
                continue

            headers = ["#", "Type", "Description"]
            rows = [
                [
                    str(step.step_num),
                    step.step_type or "",
                ]
                for step in ctxt.steps()
            ]
            print(_build_table(rows, headers, max_col=80))

def search_steps_cmd(args: Namespace) -> None:
    """
    Search for step‑type transitions in AgentStep rows.

    Required:
        --run-id RUN_ID      search all PentestResults in that run
            *or*
        --result-id RESULT_ID  search only that PentestResult

    Optional:
        --transition "S1 -> ... -> SN"
        --reflection     print reflection text
        --script         print script text
        --output         print add_to_scratchpad text
    """
    db_path = Path(args.db or DEFAULT_DB_FILE)
    if not args.run_id and not args.result_id:
        print("[!] Either --run-id or --result-id is required")
        return

    with get_session() as session:
        # 1. Collect matching results -----------------------------------------
        results: list[PentestResultORM] = []
        if args.run_id:
            run = get_run(session, args.run_id)
            if run is None:
                print(f"[!] Run ID {args.run_id} not found in {db_path}")
                return
            results.extend(run.results)

        if args.result_id:
            res = (
                session.query(PentestResultORM)
                .filter(PentestResultORM.id == args.result_id)
                .first()
            )
            if res is None:
                print(f"[!] PentestResult ID {args.result_id} not found in {db_path}")
                return
            results.append(res)

        if not results:
            print("<no PentestResult rows to search>")
            return

        # 2. Render each result -----------------------------------------------
        parts: list[str] = []
        total_groups = 0

        for i, r in enumerate(results, start=1):
            steps = get_agent_ctxt(session, r.id) or []
            if not steps:
                continue

            body, n_groups = search_steps(steps, args)
            if not body:
                continue

            total_groups += n_groups
            header = "\n".join(
                [
                    "=" * 40 + f"MATCH {i} " + "=" * 40,
                    f"PENTEST RESULT {r.id}  |  {r.eval_name}",
                    f"Model: {r.model_name}  |  Cost: ${r.model_costs:.4f}",
                    "=" * 80,
                ]
            )
            parts.extend([header, body])

        # 3. Final output ------------------------------------------------------
        final_out = "\n".join(parts)
        print(final_out)
        print(f"Total groups returned: {total_groups}")
        print(f"Total tokens: {get_token_count(final_out)}")

# ------------------------------------------------------------------ #
# cost
# ------------------------------------------------------------------ #
def cost_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)

    with get_session() as session:
        today_cost, week_cost, per_model = get_cost_summary(session)

    print("\nCOST SUMMARY (UTC)")
    print("------------------")
    print(f"Total cost TODAY       : $ {today_cost:.4f}")
    print(f"Total cost THIS WEEK   : $ {week_cost:.4f}\n")

    if per_model:
        headers = ["Model", "Total Cost ($)", "Total Steps", "Avg/Step ($)"]
        rows = [
            [model, f"{total:.4f}", str(steps), f"{avg:.6f}"]
            for model, total, steps, avg in per_model
        ]
        print("PER-MODEL AVERAGES")
        print(_build_table(rows, headers))
    else:
        print("<no PentestResult rows in database>")


# ------------------------------------------------------------------ #
# delete-runs
# ------------------------------------------------------------------ #
def delete_runs_cmd(args: Namespace) -> None:
    """Delete one or more runs by ID.
    
    Can delete a single run or a range of runs (inclusive).
    """
    from pentest_bot.db.tables.agent import delete_run
    
    db_path = Path(args.db or DEFAULT_DB_FILE)
    run_ids = args.run_ids
    
    if len(run_ids) == 1:
        # Single run deletion
        run_id = run_ids[0]
        with get_session() as session:
            if delete_run(session, run_id):
                print(f"[+] Deleted run {run_id}")
            else:
                print(f"[!] Run {run_id} not found")
    elif len(run_ids) == 2:
        # Range deletion
        start_id, end_id = run_ids
        if start_id > end_id:
            print(f"[!] Invalid range: {start_id} > {end_id}")
            return
        
        deleted_count = 0
        not_found_count = 0
        
        with get_session() as session:
            for run_id in range(start_id, end_id + 1):
                if delete_run(session, run_id):
                    deleted_count += 1
                    print(f"[+] Deleted run {run_id}")
                else:
                    not_found_count += 1
                    print(f"[!] Run {run_id} not found")
        
        print(f"\nSummary: {deleted_count} runs deleted, {not_found_count} not found")
    else:
        print("[!] Please provide either 1 run ID or 2 run IDs (start end)")


# ---------------------------------------------------------------------------
# NEW: ad‑hoc SQL execution command
# ---------------------------------------------------------------------------

def q_db_cmd(args: Namespace) -> None:
    """Execute a raw SQL query against the selected database.

    This command is primarily intended for read‑only `SELECT` statements but
    will also execute `INSERT`, `UPDATE`, or `DELETE` operations.  For write
    queries the transaction is committed automatically and the affected row
    count is reported.
    """
    from sqlalchemy import text

    db_path = Path(args.db or DEFAULT_DB_FILE)
    sql = " ".join(args.sql)

    with get_session() as session:
        result = session.execute(text(sql))

        if result.cursor is not None:  # type: ignore[attr-defined]
            rows_raw = result.fetchall()
            if not rows_raw:
                print("<empty result set>")
                return

            headers = list(result.keys())
            rows = [["" if cell is None else str(cell) for cell in row] for row in rows_raw]
            print(_build_table(rows, headers))
        else:  # Data‑modifying query
            session.commit()
            print(f"[+] Query OK, {result.rowcount} rows affected.") # type: ignore[attr-defined]




# ---------------------------------------------------------------------------
# Argument parsing & main entry‑point
# ---------------------------------------------------------------------------


def _build_parser() -> ArgumentParser:
    p = ArgumentParser(description="ASCII CLI for PentestBot SQLite database")
    p.add_argument("--db", help="Path to alternate pentest_bot.sqlite file")
    p.add_argument("--out", type=str, help="Optional filepath to redirect output to.")

    sub = p.add_subparsers(dest="cmd", required=True)

    # list‑runs ------------------------------------------------------------- #
    list_p = sub.add_parser("list-runs", help="List recent runs")
    list_p.set_defaults(func=list_runs_cmd)
    list_p.add_argument("--all", action="store_true", help="Show *all* runs including non-eval runs (ignore --limit)")
    list_p.add_argument("--limit", type=int, default=10, help="Max rows (default: 10)")

    # show‑run -------------------------------------------------------------- #
    show_p = sub.add_parser("show-run", help="Show a single run in detail")
    show_p.set_defaults(func=show_run_cmd)
    show_p.add_argument("run_id", type=int, help="ID of the Run to display")

    # show-run-detailed ----------------------------------------------------- #
    show_detailed_p = sub.add_parser("show-run-detailed", help="Show detailed steps for each result in a run")
    show_detailed_p.set_defaults(func=show_run_detailed_cmd)
    show_detailed_p.add_argument("run_id", type=int, help="ID of the Run to display")

    # show-steps ------------------------------------------------------------ #
    steps_p = sub.add_parser("search-steps", help="Search for step-type transitions in AgentStep rows")
    steps_p.set_defaults(func=search_steps_cmd)
    steps_p.add_argument("--run-id", type=int, help="Search all PentestResults in that run")
    steps_p.add_argument("--result-id", type=int, help="Search only that PentestResult")
    steps_p.add_argument("--transition", type=str, help="Transition pattern like 'S1 -> S2 -> ... -> SN'")
    steps_p.add_argument("--reflection", action="store_true", help="Print reflection text")
    steps_p.add_argument("--script", action="store_true", help="Print script text")
    steps_p.add_argument("--output", action="store_true", help="Print add_to_scratchpad text")

    # delete-runs ----------------------------------------------------------- #
    delete_p = sub.add_parser("delete-runs", help="Delete one or more runs by ID")
    delete_p.set_defaults(func=delete_runs_cmd)
    delete_p.add_argument("run_ids", type=int, nargs="+", help="Run ID(s) to delete. Single ID or start/end range (inclusive)")

    # q_db ------------------------------------------------------------------ #
    q_p = sub.add_parser("q_db", help="Execute raw SQL against the database")
    q_p.set_defaults(func=q_db_cmd)
    q_p.add_argument("sql", nargs="+", help="SQL query to execute (wrap in quotes if it contains spaces)")

    # cost ------------------------------------------------------------------ #
    cost_p = sub.add_parser("cost", help="Show usage costs and per-model averages")
    cost_p.set_defaults(func=cost_cmd)

    return p

@contextmanager
def _maybe_redirect_stdout(filepath: str | None):
    """A context manager that redirects stdout to a file if a path is provided."""
    if filepath:
        with open(filepath, "w", encoding="utf-8") as f:
            with redirect_stdout(f):
                yield
    else:
        yield

def main(argv: Sequence[str] | None = None) -> None:  # pragma: no‑cover
    parser = _build_parser()
    args = parser.parse_args(argv)
    with _maybe_redirect_stdout(args.out):
        args.func(args)  # type: ignore[attr-defined]


if __name__ == "__main__":
    main() 