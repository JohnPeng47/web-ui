#!/usr/bin/env python
"""PentestBot SQLite CLI

A light‑weight, zero‑dependency command‑line utility for exploring the
`pentest_bot.sqlite` database.  It provides a Windows‑friendly ASCII
interface that also works unmodified on Linux/OS X terminals.

Usage examples
--------------
List the most recent 10 runs (default)::

    python pentest_cli.py list-runs

List ALL runs::

    python pentest_cli.py list-runs --all

Display a specific run together with its child ``PentestResult`` rows::

    python pentest_cli.py show-run 42

Execute an ad‑hoc SQL query (wrap the query in quotes)::

    python pentest_cli.py q_db "SELECT id, comment FROM Run LIMIT 5"

Point to a custom database file::

    python pentest_cli.py list-runs --db path/to/alt.sqlite

This module assumes that the schema definitions (``Run``/``PentestResult``)
reside in a sibling module named ``pentest_db.py``.  Adjust
``DB_MODULE`` below if your file is named differently.
"""
from __future__ import annotations

from argparse import ArgumentParser, Namespace
from contextlib import contextmanager
from datetime import datetime, timedelta
from importlib import import_module
from pathlib import Path
from typing import Iterable, List, Sequence

from pentest_bot.db import (
    get_session,           # already existed
    get_runs_summary,
    get_run,
    get_steps_for_result,
    get_cost_summary,
)

# ---------------------------------------------------------------------------
# Configuration – tweak these to match local layout
# ---------------------------------------------------------------------------
DB_MODULE = "pentest_bot.db"  # file that defines `engine`, `SessionLocal`, `Run`, …
DEFAULT_DB_FILE = Path(__file__).parent.parent / "pentest_bot.sqlite"
# ---------------------------------------------------------------------------
# Helper: lazy‑import the application DB module
# ---------------------------------------------------------------------------
_db_cache: dict[Path, tuple] = {}


def _load_db(db_path: Path):
    """Return (SessionLocal, Run, PentestResult, AgentStep) from the target database.

    The function monkey‑patches the underlying SQLAlchemy ``engine`` so that
    we can reuse the ORM models with **any** SQLite file chosen at runtime.
    """
    if db_path in _db_cache:
        return _db_cache[db_path]

    db_mod = import_module(DB_MODULE)

    # Monkey‑patch the engine used by the ORM.  This avoids having to fork the
    # schema definitions for each database file.
    from sqlalchemy import create_engine

    db_mod.engine.dispose()  # close previous connections, if any
    db_mod.engine = create_engine(f"sqlite:///{db_path}", connect_args={"check_same_thread": False})
    db_mod.SessionLocal.configure(bind=db_mod.engine)  # type: ignore[attr-defined]

    _db_cache[db_path] = (db_mod.SessionLocal, db_mod.Run, db_mod.PentestResult, db_mod.AgentStep)
    return _db_cache[db_path]


# ---------------------------------------------------------------------------
# Plain‑ASCII table formatter (Windows‑friendly, no fancy Unicode)
# ---------------------------------------------------------------------------

def _build_table(rows: Sequence[Sequence[str]], headers: Sequence[str] | None = None, max_col: int = 50) -> str:
    """Return an ASCII table as a single string.

    The function calculates column widths from the *longest* cell in each
    column and then draws the grid using ``+``/``-``/``|`` glyphs which render
    correctly even in the Windows 10/11 default console font.
    
    Args:
        rows: The data rows to display
        headers: Optional column headers
        max_col: Maximum width for any column; longer content is truncated with "..."
    """
    if not rows and not headers:
        return "<empty>"

    # Ensure we have at least one row to compute widths
    sample = rows[0] if rows else ["" for _ in headers]  # type: ignore[arg-type]
    col_count = len(headers or sample)

    widths: List[int] = [0] * col_count
    for col_idx in range(col_count):
        header_len = len(headers[col_idx]) if headers else 0  # type: ignore[index]
        max_cell = max((len(r[col_idx]) for r in rows), default=0)
        widths[col_idx] = min(max(header_len, max_cell), max_col)

    def _separator(char: str = "-") -> str:
        return "+" + "+".join(char * (w + 2) for w in widths) + "+"

    def _truncate_cell(cell: str, width: int) -> str:
        if len(cell) <= width:
            return cell
        return cell[:width-3] + "..."

    def _format_row(row: Sequence[str]) -> str:
        return "| " + " | ".join(_truncate_cell(cell, widths[i]).ljust(widths[i]) for i, cell in enumerate(row)) + " |"

    parts: List[str] = [
        _separator(),
    ]
    if headers:
        parts.append(_format_row(headers))
        parts.append(_separator("="))
    for r in rows:
        parts.append(_format_row(r))
        parts.append(_separator())
    return "\n".join(parts)


# ---------------------------------------------------------------------------
# CLI commands
# ---------------------------------------------------------------------------

from sqlalchemy import func, case


def _human_ts(ts: datetime | None) -> str:
    return ts.strftime("%Y-%m-%d %H:%M:%S") if ts else "—"


def list_runs_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    limit = None if args.all else args.limit

    with get_session() as session:
        # REFRACTOR ►  use query helper
        runs = get_runs_summary(session, limit=limit, eval_only=True)

        header_field_mapping = [
            ("ID", "id"),
            ("Created", "created_at"),
            ("Comment", "comment"),
            ("LogDir", "parent_logdir"),
            ("#Results", "total_results"),
            ("#Success", "successes"),
            ("#Steps", "total_steps"),
        ]

        rows = [
            [
                str(r.id),
                _human_ts(r.created_at),
                r.comment or "",
                r.parent_logdir,
                str(int(r.total_results)),
                str(int(r.successes)),
                str(int(r.total_steps or 0)),
            ]
            for r in runs
        ]
        headers = [h for h, _ in header_field_mapping]
        print(_build_table(rows, headers))


# ------------------------------------------------------------------ #
# show-run
# ------------------------------------------------------------------ #
def show_run_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    run_id = args.run_id

    with get_session() as session:
        run = get_run(session, run_id)
        if run is None:
            print(f"[!] Run ID {run_id} not found in {db_path}")
            return

        run_rows = [
            ["ID", str(run.id)],
            ["Created", _human_ts(run.created_at)],
            ["Comment", run.comment or ""],
            ["Parent LogDir", run.parent_logdir],
            ["# Results", str(len(run.results))],
            ["# Success", str(sum(1 for r in run.results if r.success))],
        ]
        print("RUN SUMMARY")
        print(_build_table(run_rows))
        print()

        res_rows = [
            [
                str(r.id),
                r.eval_name,
                "✔" if r.success else "✘",
                f"{r.steps}/{r.max_steps}",
                r.model_name,
                f"{r.model_costs:.4f}",
                r.log_filepath,
                _human_ts(r.created_at),
            ]
            for r in run.results
        ]
        if res_rows:
            headers = [
                "ID",
                "Eval Name",
                "Ok?",
                "Steps",
                "Model",
                "Cost ($)",
                "Log FilePath",
                "Created",
            ]
            print(_build_table(res_rows, headers))
        else:
            print("<no child PentestResult rows>")


# ------------------------------------------------------------------ #
# show-steps
# ------------------------------------------------------------------ #
def show_steps_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)
    result_id = args.result_id

    with get_session() as session:
        steps = get_steps_for_result(session, result_id)
        if steps is None:
            print(f"[!] PentestResult ID {result_id} not found in {db_path}")
            return
        if not steps:
            print(f"<no AgentStep rows for PentestResult ID {result_id}>")
            return

        print(f"\nAGENT STEPS FOR PENTEST RESULT {result_id}")
        for step in steps:
            print("--------------------------------------------------------------------------------")
            print(f"Step: {step.step_number}  |  Created: {_human_ts(step.created_at)}")
            if step.add_to_scratchpad:
                print(f"Scratchpad: {step.add_to_scratchpad}")
            print("\nReflection:")
            print(step.reflection)
            print("\nScript:")
            print(step.script)
        print("--------------------------------------------------------------------------------")


# ------------------------------------------------------------------ #
# cost
# ------------------------------------------------------------------ #
def cost_cmd(args: Namespace) -> None:
    db_path = Path(args.db or DEFAULT_DB_FILE)

    with get_session() as session:
        today_cost, week_cost, per_model = get_cost_summary(session)

    print("\nCOST SUMMARY (UTC)")
    print("------------------")
    print(f"Total cost TODAY       : $ {today_cost:.4f}")
    print(f"Total cost THIS WEEK   : $ {week_cost:.4f}\n")

    if per_model:
        headers = ["Model", "Total Cost ($)", "Total Steps", "Avg/Step ($)"]
        rows = [
            [model, f"{total:.4f}", str(steps), f"{avg:.6f}"]
            for model, total, steps, avg in per_model
        ]
        print("PER-MODEL AVERAGES")
        print(_build_table(rows, headers))
    else:
        print("<no PentestResult rows in database>")

# ---------------------------------------------------------------------------
# NEW: ad‑hoc SQL execution command
# ---------------------------------------------------------------------------

def q_db_cmd(args: Namespace) -> None:
    """Execute a raw SQL query against the selected database.

    This command is primarily intended for read‑only `SELECT` statements but
    will also execute `INSERT`, `UPDATE`, or `DELETE` operations.  For write
    queries the transaction is committed automatically and the affected row
    count is reported.
    """
    from sqlalchemy import text

    db_path = Path(args.db or DEFAULT_DB_FILE)
    sql = " ".join(args.sql)

    with get_session() as session:
        result = session.execute(text(sql))

        if result.returns_rows:  # SELECT (or similar) query
            rows_raw = result.fetchall()
            if not rows_raw:
                print("<empty result set>")
                return

            headers = list(result.keys())
            rows = [["" if cell is None else str(cell) for cell in row] for row in rows_raw]
            print(_build_table(rows, headers))
        else:  # Data‑modifying query
            session.commit()
            print(f"[+] Query OK, {result.rowcount} rows affected.")


# ---------------------------------------------------------------------------
# Argument parsing & main entry‑point
# ---------------------------------------------------------------------------


def _build_parser() -> ArgumentParser:
    p = ArgumentParser(description="ASCII CLI for PentestBot SQLite database")
    p.add_argument("--db", help="Path to alternate pentest_bot.sqlite file")

    sub = p.add_subparsers(dest="cmd", required=True)

    # list‑runs ------------------------------------------------------------- #
    list_p = sub.add_parser("list-runs", help="List recent runs")
    list_p.set_defaults(func=list_runs_cmd)
    list_p.add_argument("--all", action="store_true", help="Show *all* runs (ignore --limit)")
    list_p.add_argument("--limit", type=int, default=10, help="Max rows (default: 10)")

    # show‑run -------------------------------------------------------------- #
    show_p = sub.add_parser("show-run", help="Show a single run in detail")
    show_p.set_defaults(func=show_run_cmd)
    show_p.add_argument("run_id", type=int, help="ID of the Run to display")

    # show-steps ------------------------------------------------------------ #
    steps_p = sub.add_parser("show-steps", help="Show agent steps for a single pentest result")
    steps_p.set_defaults(func=show_steps_cmd)
    steps_p.add_argument("result_id", type=int, help="ID of the PentestResult to display steps for")

    # q_db ------------------------------------------------------------------ #
    q_p = sub.add_parser("q_db", help="Execute raw SQL against the database")
    q_p.set_defaults(func=q_db_cmd)
    q_p.add_argument("sql", nargs="+", help="SQL query to execute (wrap in quotes if it contains spaces)")

    # cost ------------------------------------------------------------------ #
    cost_p = sub.add_parser("cost", help="Show usage costs and per-model averages")
    cost_p.set_defaults(func=cost_cmd)

    return p


def main(argv: Sequence[str] | None = None) -> None:  # pragma: no‑cover
    parser = _build_parser()
    args = parser.parse_args(argv)
    args.func(args)  # type: ignore[attr-defined]


if __name__ == "__main__":
    main()
