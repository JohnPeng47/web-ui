"""Shared helper functions for CLI commands.

This module exists to avoid circular imports when individual command modules
live under ``pentest_bot.cli_db.cmds`` while ``cli_db`` remains the main entry
point that wires together the ``argparse`` sub-parser tree.
"""
from __future__ import annotations

from datetime import datetime
from typing import List, Sequence, Dict, Optional

from pentest_bot.models.steps import StepStateAbbr, AgentStep


def build_table(
    rows: Sequence[Sequence[str]],
    headers: Sequence[str] | None = None,
    max_col: int = 50,
) -> str:
    """Return an ASCII table as a single string.

    The function calculates column widths from the *longest* cell in each
    column and then draws the grid using ``+``/``-``/``|`` glyphs which render
    correctly even in the Windows 10/11 default console font.
    """
    if not rows and not headers:
        return "<empty>"

    # Ensure we have at least one row to compute widths
    sample = rows[0] if rows else ["" for _ in headers]  # type: ignore[arg-type]
    col_count = len(headers or sample)

    widths: List[int] = [0] * col_count
    for col_idx in range(col_count):
        header_len = len(headers[col_idx]) if headers else 0  # type: ignore[index]
        max_cell = max((len(r[col_idx]) for r in rows), default=0)
        widths[col_idx] = min(max(header_len, max_cell), max_col)

    def _separator(char: str = "-") -> str:
        return "+" + "+".join(char * (w + 2) for w in widths) + "+"

    def _truncate_cell(cell: str, width: int) -> str:
        if len(cell) <= width:
            return cell
        return cell[: width - 3] + "..."

    def _format_row(row: Sequence[str]) -> str:
        return "| " + " | ".join(_truncate_cell(cell, widths[i]).ljust(widths[i]) for i, cell in enumerate(row)) + " |"

    parts: List[str] = [_separator()]
    if headers:
        parts.append(_format_row(headers))
        parts.append(_separator("="))
    for r in rows:
        parts.append(_format_row(r))
        parts.append(_separator())
    return "\n".join(parts)


def human_ts(ts: datetime | None) -> str:
    """Format timestamps consistently across commands."""
    return ts.strftime("%Y-%m-%d %H:%M:%S") if ts else "—"


def display_step_traces(
    eval_map: Dict[str, List[List[AgentStep]]],
    max_steps: int,
    *,
    row_names_map: Optional[Dict[str, List[str]]] = None,
) -> None:
    """Pretty-print step abbreviations grouped by eval_name.

    Parameters
    ----------
    eval_map
        Mapping of ``eval_name`` → list of *results*, where each result is a
        **list of AgentStep objects** already ordered by ``step_number``.
    max_steps
        The *maximum* number of steps amongst *all* results.  Used only for the
        header row showing step numbers.
    """
    if not eval_map:
        print("<no step data>")
        return

    # compute abbreviation cell width (same as caller logic)
    max_abbr_width = max(len(abbr) for abbr in StepStateAbbr.values())
    max_cell_width = max_abbr_width + 2

    for eval_name, results in eval_map.items():
        print(f"\n{eval_name}:")

        labels = row_names_map.get(eval_name, []) if row_names_map else []
        def _label_for(index: int) -> str:
            return labels[index] if index < len(labels) else f"Result {index+1}"

        max_label_len = max([len(l) for l in labels] or [len(f"Result {len(results)}")])

        # header row
        if max_steps > 0:
            prefix_len = max_label_len + 4 - 1 # "  " + label + ": "; -1 needed
            header_parts = [" " * prefix_len]
            for step_num in range(1, max_steps + 1):
                header_parts.append(str(step_num).center(max_cell_width))
            header = "|".join(header_parts)
            print(header)
            print("-" * len(header))

        # results
        for idx, steps in enumerate(results):
            trace_cells: List[str] = []
            for step in steps:
                if step.step_type and step.step_type in StepStateAbbr:
                    abbr = StepStateAbbr[step.step_type]
                    trace_cells.append(f" {abbr} ".center(max_cell_width))
                else:
                    trace_cells.append(" ? ".center(max_cell_width))
            trace = "|".join(trace_cells)
            label = _label_for(idx)
            print(f"  {label.ljust(max_label_len)}: {trace}") 