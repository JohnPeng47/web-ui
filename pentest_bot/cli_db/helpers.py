"""Shared helper functions for CLI commands.

This module exists to avoid circular imports when individual command modules
live under ``pentest_bot.cli_db.cmds`` while ``cli_db`` remains the main entry
point that wires together the ``argparse`` sub-parser tree.
"""
from __future__ import annotations

from datetime import datetime
from typing import List, Sequence, Dict, Optional, cast
from argparse import Namespace

from sqlalchemy.orm import Session

from pentest_bot.models.steps import StepStateAbbr, AgentStep
from pentest_bot.db.tables.agent import (
    PentestResultORM,
    get_run,
    get_agent_results_by_evalname,
)

def get_results_from_args(session: Session, args: Namespace) -> List[PentestResultORM]:
    """
    Collect PentestResultORM rows based on common CLI arguments.

    Supported args:
    - args.run_id (int)
    - args.result_id (int)
    - args.result_ids (List[int])
    - args.eval_name (str)
    - args.n (int, for eval_name)
    """
    results: List[PentestResultORM] = []
    
    # Note: Using set to avoid duplicates if, e.g., a result_id is in a run_id
    collected_ids = set()

    # 1. By --run-id
    if getattr(args, "run_id", None):
        run = get_run(session, args.run_id)
        if run:
            for res in run.results:
                if res.id not in collected_ids:
                    results.append(res)
                    collected_ids.add(res.id)

    # 2. By --result-id or --result-ids
    result_ids_to_fetch = set()
    if getattr(args, "result_id", None):
        result_ids_to_fetch.add(args.result_id)
        
    if getattr(args, "result_ids", None):
        for rid in args.result_ids:
            result_ids_to_fetch.add(rid)

    for res_id in result_ids_to_fetch:
        if res_id in collected_ids:
            continue
        res = session.query(PentestResultORM).filter(PentestResultORM.id == res_id).first()
        if res:
            results.append(res)
            collected_ids.add(res.id)

    # 3. By --eval-name
    if getattr(args, "eval_name", None):
        n = getattr(args, "n", 5)
        eval_results = get_agent_results_by_evalname(session, args.eval_name, n=n)
        for res in eval_results:
            if res.id not in collected_ids:
                results.append(res)
                collected_ids.add(res.id)

    return results 

def display_step_traces(
    eval_map: Dict[str, List[List[AgentStep]]],
    max_steps: int,
    *,
    row_names_map: Optional[Dict[str, List[str]]] = None,
) -> None:
    """Pretty-print step abbreviations grouped by eval_name.

    Parameters
    ----------
    eval_map
        Mapping of ``eval_name`` → list of *results*, where each result is a
        **list of AgentStep objects** already ordered by ``step_number``.
    max_steps
        The *maximum* number of steps amongst *all* results.  Used only for the
        header row showing step numbers.
    """
    if not eval_map:
        print("<no step data>")
        return

    # compute abbreviation cell width (same as caller logic)
    max_abbr_width = max(len(abbr) for abbr in StepStateAbbr.values())
    max_cell_width = max_abbr_width + 2

    for eval_name, results in eval_map.items():
        print(f"\n{eval_name}:")

        labels = row_names_map.get(eval_name, []) if row_names_map else []
        def _label_for(index: int) -> str:
            return labels[index] if index < len(labels) else f"Result {index+1}"

        max_label_len = max([len(l) for l in labels] or [len(f"Result {len(results)}")])

        # header row
        if max_steps > 0:
            prefix_len = max_label_len + 4 - 1 # "  " + label + ": "; -1 needed
            header_parts = [" " * prefix_len]
            for step_num in range(1, max_steps + 1):
                header_parts.append(str(step_num).center(max_cell_width))
            header = "|".join(header_parts)
            print(header)
            print("-" * len(header))

        # results
        for idx, steps in enumerate(results):
            trace_cells: List[str] = []
            for step in steps:
                if step.step_type and step.step_type in StepStateAbbr:
                    abbr = StepStateAbbr[step.step_type]
                    trace_cells.append(f" {abbr} ".center(max_cell_width))
                else:
                    trace_cells.append(" ? ".center(max_cell_width))
            trace = "|".join(trace_cells)
            label = _label_for(idx)
            print(f"  {label.ljust(max_label_len)}: {trace}") 

def build_table(
    rows: Sequence[Sequence[str]],
    headers: Sequence[str] | None = None,
    max_col: int = 50,
) -> str:
    """Return an ASCII table as a single string.

    The function calculates column widths from the *longest* cell in each
    column and then draws the grid using ``+``/``-``/``|`` glyphs which render
    correctly even in the Windows 10/11 default console font.
    """
    if not rows and not headers:
        return "<empty>"

    # Ensure we have at least one row to compute widths
    sample = rows[0] if rows else ["" for _ in headers]  # type: ignore[arg-type]
    col_count = len(headers or sample)

    widths: List[int] = [0] * col_count
    for col_idx in range(col_count):
        header_len = len(headers[col_idx]) if headers else 0  # type: ignore[index]
        max_cell = max((len(r[col_idx]) for r in rows), default=0)
        widths[col_idx] = min(max(header_len, max_cell), max_col)

    def _separator(char: str = "-") -> str:
        return "+" + "+".join(char * (w + 2) for w in widths) + "+"

    def _truncate_cell(cell: str, width: int) -> str:
        if len(cell) <= width:
            return cell
        return cell[: width - 3] + "..."

    def _format_row(row: Sequence[str]) -> str:
        return "| " + " | ".join(_truncate_cell(cell, widths[i]).ljust(widths[i]) for i, cell in enumerate(row)) + " |"

    parts: List[str] = [_separator()]
    if headers:
        parts.append(_format_row(headers))
        parts.append(_separator("="))
    for r in rows:
        parts.append(_format_row(r))
        parts.append(_separator())
    return "\n".join(parts)


def human_ts(ts: datetime | None) -> str:
    """Format timestamps consistently across commands."""
    return ts.strftime("%Y-%m-%d %H:%M:%S") if ts else "—"