# search_steps.py  – all rendering + transition logic
from __future__ import annotations

from types import SimpleNamespace
from typing import List, Tuple

# AgentStepORM import removed (no longer needed after refactor)
from pentest_bot.web_exploit.agent_step import AgentContext, AgentStep


# mini-grammar powered searching utilities
# ────────────────────────────────────
# We parse the user-supplied ``--transition`` expression into an AST and run a
# back-tracking matcher that returns every contiguous slice of ``steps`` that
# satisfies the pattern.

from .pattern_parser import (
    parse as _parse_pattern,
    Atom as _Atom,
    Seq as _Seq,
    Alt as _Alt,
    AndUnordered as _AndUnordered,
    Node as _Node,
)

import itertools
from typing import Set


# ---------------------------------------------------------------------------
# Low-level matcher — returns *end positions* (exclusive) that can be reached
# when starting at ``pos``.
# ---------------------------------------------------------------------------


def _match_node(node: _Node, steps: List[AgentStep], pos: int) -> Set[int]:
    if pos > len(steps):
        return set()

    # ------------------------ Atom -----------------------------------------
    if isinstance(node, _Atom):
        lo, hi = node.rep
        # consume as many matching steps as allowed (up to hi)
        cnt = 0
        while pos + cnt < len(steps) and steps[pos + cnt].step_type == node.name and cnt < hi:
            cnt += 1

        # produce all end positions within [lo, cnt]
        if cnt < lo:
            return set()
        return {pos + k for k in range(lo, cnt + 1)}

    # ------------------------ Sequence -------------------------------------
    if isinstance(node, _Seq):
        positions: Set[int] = {pos}
        for child in node.parts:
            next_positions: Set[int] = set()
            for p in positions:
                next_positions.update(_match_node(child, steps, p))
            if not next_positions:
                return set()
            positions = next_positions
        return positions

    # ------------------------ Alternation ----------------------------------
    if isinstance(node, _Alt):
        out: Set[int] = set()
        for option in node.options:
            out.update(_match_node(option, steps, pos))
        return out

    # ------------------------ Unordered-AND --------------------------------
    if isinstance(node, _AndUnordered):
        # Evaluate all permutations (small N) and union the results.
        out: Set[int] = set()
        for perm in itertools.permutations(node.parts):
            out.update(_match_node(_Seq(list(perm)), steps, pos))
        return out

    # Fallback — should not happen.
    return set()


def _match_transition(steps: List[AgentStep], expr: str | None) -> List[List[AgentStep]]:
    """Return *all* contiguous slices matching *expr* according to the mini-grammar."""

    if not expr:
        # No pattern supplied → treat each step as its own group (old behaviour)
        return [[s] for s in steps]

    ast = _parse_pattern(expr)
    matches: List[List[AgentStep]] = []

    for start in range(len(steps)):
        ends = _match_node(ast, steps, start)
        for end in ends:
            if end > start:
                matches.append(steps[start:end])

    return matches


# ────────────────────────────────────
# public API
# ────────────────────────────────────
def search_steps(
    agent_ctxt: AgentContext,
    args: SimpleNamespace
) -> Tuple[str, int]:
    """
    Format *one* ``PentestResult`` step list according to the CLI flags.

    Parameters
    ----------
    steps
        ``AgentStepORM`` rows already ordered by ``step_number``.
    args
        Parsed ``argparse.Namespace`` with flags:
            transition, reflection, script, output

    Returns
    -------
    rendered_txt, group_count
    """
    steps         = agent_ctxt.steps()
    pattern_expr  = getattr(args, "transition", None)
    groups        = _match_transition(steps, pattern_expr)
    groups_out  = []
    selective   = args.script or args.output or args.reflection

    for g in groups:
        first, last = g[0], g[-1]
        step_types  = [s.step_type or "" for s in g]
        header      = (
            f"Transition match: steps {first.step_num}‒{last.step_num}  "
            f"({' -> '.join(step_types)})"
        )
        groups_out.append(header)
        groups_out.append("-" * len(header))

        for s in g:
            if not selective:
                # full, verbose dump
                groups_out.extend(_render_full_step(s))
            else:
                groups_out.extend(_render_selective_step(s, args))

    txt = "\n".join(groups_out)
    return txt, len(groups)


# ────────────────────────────────────
# rendering helpers (kept private)
# ────────────────────────────────────
def _render_full_step(step: AgentStep) -> List[str]:
    out: List[str] = []
    typ  = step.step_type or ""
    out.append(f"[{step.step_num}]  {typ}")

    if step.add_to_scratchpad:
        out.append(f"Scratchpad: {step.add_to_scratchpad}")

    out.append("\nReflection:")
    out.append(str(step.reflection or ""))

    out.append("\nScript:")
    out.append(str(step.script or ""))

    out.append("-" * 40)
    return out


def _render_selective_step(step: AgentStep, args: SimpleNamespace) -> List[str]:
    parts: List[str] = []
    parts.append(f"[{step.step_num}]  {step.step_type}")
    if args.reflection and step.reflection:
        parts.append(str(step.reflection))
    if args.script and step.script:
        parts.append(str(step.script))
    if args.output and step.execution_output:
        parts.append(str(step.execution_output))

    joined = "\n".join(parts) if parts else ""
    return [joined, "-" * 40]
