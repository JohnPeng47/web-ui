# search_steps.py  – all rendering + transition logic
from __future__ import annotations

from datetime import datetime
from pathlib import Path
from types import SimpleNamespace
from typing import Iterable, List, Tuple

from pentest_bot.db import AgentStepORM
from pentest_bot.web_exploit.utils import get_token_count
from pentest_bot.web_exploit.agent_step import AgentContext, AgentStep


# ────────────────────────────────────
# small internal helpers
# ────────────────────────────────────
def _human_ts(ts: datetime) -> str:
    return ts.strftime("%Y‑%m‑%d %H:%M")

def _parse_transition(expr: str | None) -> List[str]:
    """ "--transition 'A -> B -> C'"  →  ['A', 'B', 'C'] """
    if not expr:
        return []
    return [tok.strip() for tok in expr.split("->") if tok.strip()]

def _match_transition(
    steps: List[AgentStep],
    states: List[str]
) -> List[List[AgentStep]]:
    """
    Return contiguous slices whose .step_type sequence equals ``states``.
    """
    if not states:
        return [[s] for s in steps]      # no pattern → one‑step groups

    k = len(states)
    out: List[List[AgentStepORM]] = []
    for i in range(len(steps) - k + 1):
        window = steps[i : i + k]
        if all((s.step_type or "") == states[j] for j, s in enumerate(window)):
            out.append(window)
    return out


# ────────────────────────────────────
# public API
# ────────────────────────────────────
def search_steps(
    agent_ctxt: AgentContext,
    args: SimpleNamespace
) -> Tuple[str, int]:
    """
    Format *one* ``PentestResult`` step list according to the CLI flags.

    Parameters
    ----------
    steps
        ``AgentStepORM`` rows already ordered by ``step_number``.
    args
        Parsed ``argparse.Namespace`` with flags:
            transition, reflection, script, output

    Returns
    -------
    rendered_txt, group_count
    """
    steps       = agent_ctxt.steps()
    states      = _parse_transition(getattr(args, "transition", None))
    groups      = _match_transition(steps, states)
    groups_out  = []
    selective   = args.script or args.output or args.reflection

    for g in groups:
        first, last = g[0], g[-1]
        step_types  = [s.step_type or "" for s in g]
        header      = (
            f"Transition match: steps {first.step_num}‒{last.step_num}  "
            f"({' -> '.join(step_types)})"
        )
        groups_out.append(header)
        groups_out.append("-" * len(header))

        for s in g:
            if not selective:
                # full, verbose dump
                groups_out.extend(_render_full_step(s))
            else:
                groups_out.extend(_render_selective_step(s, args))

    txt = "\n".join(groups_out)
    return txt, len(groups)


# ────────────────────────────────────
# rendering helpers (kept private)
# ────────────────────────────────────
def _render_full_step(step: AgentStep) -> List[str]:
    out: List[str] = []
    typ  = step.step_type or ""
    out.append(f"[{step.step_num}]  {typ}")

    if step.add_to_scratchpad:
        out.append(f"Scratchpad: {step.add_to_scratchpad}")

    out.append("\nReflection:")
    out.append(str(step.reflection or ""))

    out.append("\nScript:")
    out.append(str(step.script or ""))

    out.append("-" * 40)
    return out


def _render_selective_step(step: AgentStep, args: SimpleNamespace) -> List[str]:
    parts: List[str] = []
    parts.append(f"[{step.step_num}]  {step.step_type}")
    if args.reflection and step.reflection:
        parts.append(str(step.reflection))
    if args.script and step.script:
        parts.append(str(step.script))
    if args.output and step.execution_output:
        parts.append(str(step.execution_output))

    joined = "\n".join(parts) if parts else ""
    return [joined, "-" * 40]
