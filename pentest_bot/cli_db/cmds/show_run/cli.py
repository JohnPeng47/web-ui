from __future__ import annotations

from argparse import Namespace
from collections import defaultdict

from pentest_bot.db import get_session
from pentest_bot.db.tables.agent import get_run, get_agent_ctxt

from pentest_bot.cli_db.helpers import _build_table, _human_ts
from pentest_bot.web_exploit.agent_step import StepStateAbbr


def show_run_cmd(args: Namespace) -> None:
    """Detailed summary for one Run ID (aggregate + per-result traces)."""

    run_id = args.run_id

    with get_session() as session:
        run = get_run(session, run_id)
        if run is None:
            print(f"[!] Run ID {run_id} not found")
            return

        if not run.results:
            print(f"[!] Run ID {run_id} has no results")
            return

        # Calculate total cost for the run
        total_cost = sum(r.model_costs for r in run.results)
        max_steps = run.results[0].max_steps

        run_rows = [
            ["ID", str(run.id)],
            ["Created", _human_ts(run.created_at)],  # type: ignore[arg-type]
            ["Comment", run.comment or ""],  # type: ignore[misc]
            ["Parent LogDir", run.parent_logdir],
            ["# Results", str(len(run.results))],
            ["# Success", str(sum(1 for r in run.results if r.success))],
            ["Total Cost ($)", f"{total_cost:.4f}"],
        ]
        print("RUN SUMMARY")
        print(_build_table(run_rows))
        print()

        res_rows = [
            [
                str(r.id),
                r.eval_name,
                "✔" if r.success else "✘",
                f"{r.steps}/{r.max_steps}",
                r.model_name,
                f"{r.model_costs:.4f}",
                r.log_filepath,
                _human_ts(r.created_at),
            ]
            for r in run.results
        ]
        if res_rows:
            headers = [
                "ID",
                "Eval Name",
                "Ok?",
                "Steps",
                "Model",
                "Cost ($)",
                "Log FilePath",
                "Created",
            ]
            print(_build_table(res_rows, headers))
        else:
            print("<no child PentestResult rows>")
            return

        # Print step state legend and traces
        print()
        print("STEP STATE LEGEND")
        legend_items = [f"{abbr}={state.value}" for state, abbr in StepStateAbbr.items()]
        print(" | ".join(legend_items))
        print()

        # Find the maximum width of abbreviations for padding
        max_abbr_width = max(len(abbr) for abbr in StepStateAbbr.values())

        print("STEP TRACES")

        # Group results by eval_name
        results_by_eval = defaultdict(list)
        for result in run.results:
            results_by_eval[result.eval_name].append(result)

        # Print results grouped by eval name
        for eval_name, results in results_by_eval.items():
            print(f"\n{eval_name}:")

            # Header row with step numbers
            if max_steps > 0:
                max_cell_width = max_abbr_width + 2
                max_result_id = max(result.id for result in results)
                prefix = f"  Result {max_result_id} [T]: "
                prefix_len = len(prefix) - 1
                header_parts = [" " * prefix_len]
                for step_num in range(1, max_steps + 1):
                    step_header = str(step_num).center(max_cell_width)
                    header_parts.append(step_header)
                header = "|".join(header_parts)
                print(header)
                print("-" * len(header))

            for result in results:
                success_ch = "T" if result.success else "F"
                ctxt = get_agent_ctxt(session, result.id)
                if ctxt and ctxt.steps():
                    step_abbrs = []
                    for step in ctxt.steps():
                        if step.step_type and step.step_type in StepStateAbbr:
                            abbr = StepStateAbbr[step.step_type]
                            step_abbrs.append(f" {abbr} ".center(max_cell_width))
                        else:
                            step_abbrs.append(" ? ".center(max_cell_width))
                    trace = "|".join(step_abbrs)
                    print(f"  Result {result.id} [{success_ch}]: {trace}")
                else:
                    print(f"  Result {result.id} [{success_ch}]: <no steps>") 