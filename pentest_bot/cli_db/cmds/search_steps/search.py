 # search_steps.py – three-stage pipeline
from __future__ import annotations

from dataclasses import dataclass
from types import SimpleNamespace
from typing import List, Set, Tuple, Optional

import itertools
import json
from typing import List, Tuple

from rich import print

from pentest_bot.models.steps import AgentContext, AgentStep
from pentest_bot.db.tables.exploit_agent import (
    PentestResultORM,
    get_run,
    get_agent_ctxt,
    get_agent_results_by_evalname,
)

from .parser import (
    parse as _parse_pattern,
    Atom as _Atom,
    Seq as _Seq,
    Alt as _Alt,
    AndUnordered as _AndUnordered,
    Node as _Node,
)


# ────────────────────────────────────
# Small transport structs
# ────────────────────────────────────

@dataclass
class Collected:
    """Output of Stage 1 (Collect)."""
    result: PentestResultORM
    steps: List[AgentStep]


@dataclass
class Filtered:
    """Output of Stage 2 (Filter Steps)."""
    result: PentestResultORM
    groups: List[List[AgentStep]]  # each inner list is a contiguous slice


# ────────────────────────────────────
# Stage 1 — COLLECT
# ────────────────────────────────────
def collect_results(session, args) -> List[Collected]:
    """
    Collect the *results* we want to work on and materialize their AgentSteps.

    Accepted selectors:
      • --result-ids RESULT_ID
      • --run-id RUN_ID
      • --eval-name NAME [--n 5]

    Returns
    -------
    List[Collected]
        Each element contains the PentestResultORM and its list[AgentStep].
    """
    out: List[Collected] = []

    # 1) --result-id
    result_ids = getattr(args, "result_ids", None)
    if result_ids:
        if not isinstance(result_ids, list):
            result_ids = [result_ids]
        
        for result_id in result_ids:
            res = (
                session.query(PentestResultORM)
                .filter(PentestResultORM.id == result_id)
                .first()
            )
            if res:
                ctxt = get_agent_ctxt(session, res.id)
                if ctxt:
                    out.append(Collected(result=res, steps=list(ctxt.steps())))

    # 2) --run-id
    if getattr(args, "run_id", None):
        run = get_run(session, args.run_id)
        if run:
            for res in run.results:
                ctxt = get_agent_ctxt(session, res.id)
                if ctxt:
                    out.append(Collected(result=res, steps=list(ctxt.steps())))

    # 3) --eval-name (+ optional --n)
    if getattr(args, "eval_name", None):
        n = getattr(args, "n", 5)
        eval_results = get_agent_results_by_evalname(session, args.eval_name, n=n, eager=True)
        for res in eval_results:
            ctxt = get_agent_ctxt(session, res.id)
            if ctxt:
                out.append(Collected(result=res, steps=list(ctxt.steps())))

    return out


# ────────────────────────────────────
# Stage 2 — FILTER STEPS
# ────────────────────────────────────

def filter(collected: List[Collected], args) -> List[Filtered]:
    """
    Apply:
      • pattern grouping via --transition
      • optionally slice steps via --steps a b

    Returns one Filtered object per *result*.
    """
    pattern_expr = getattr(args, "transition", None)
    step_slice: Optional[Tuple[int, int]] = _parse_steps_slice(getattr(args, "steps", None))

    filtered: List[Filtered] = []
    for c in collected:
        steps = c.steps

        # optional [a, b] inclusive slice
        if step_slice is not None:
            a, b = step_slice
            # convert to 0-based and inclusive
            a_idx = max(a - 1, 0)
            b_idx = min(b, len(steps))
            steps = steps[a_idx:b_idx]

        # partition by transition pattern
        groups = _match_transition(steps, pattern_expr)
        filtered.append(Filtered(result=c.result, groups=groups))

    return filtered


def _parse_steps_slice(steps_arg) -> Optional[Tuple[int, int]]:
    """
    Parse --steps a b → (a, b). If None or invalid → None.
    """
    if not steps_arg:
        return None
    if len(steps_arg) == 1:
        # treat as [a, a]
        return steps_arg[0], steps_arg[0]
    if len(steps_arg) >= 2:
        a, b = steps_arg[0], steps_arg[1]
        if a > b:
            a, b = b, a
        return a, b
    return None


# ---------------------------------------------------------------------------
# Low-level matcher — returns *end positions* (exclusive) that can be reached
# when starting at ``pos``.
# ---------------------------------------------------------------------------

def _match_transition(steps: List[AgentStep], expr: str | None) -> List[List[AgentStep]]:
    """Return *all* contiguous slices matching *expr* according to the mini-grammar."""
    if not expr:
        return [[s] for s in steps]

    ast = _parse_pattern(expr)
    matches: List[List[AgentStep]] = []

    for start in range(len(steps)):
        ends = _match_node(ast, steps, start)
        for end in ends:
            if end > start:
                matches.append(steps[start:end])

    return matches


def _match_node(node: _Node, steps: List[AgentStep], pos: int) -> Set[int]:
    if pos > len(steps):
        return set()

    if isinstance(node, _Atom):
        lo, hi = node.rep
        cnt = 0
        while pos + cnt < len(steps) and steps[pos + cnt].step_type == node.name and cnt < hi:
            cnt += 1
        if cnt < lo:
            return set()
        return {pos + k for k in range(lo, cnt + 1)}

    if isinstance(node, _Seq):
        positions: Set[int] = {pos}
        for child in node.parts:
            next_positions: Set[int] = set()
            for p in positions:
                next_positions.update(_match_node(child, steps, p))
            if not next_positions:
                return set()
            positions = next_positions
        return positions

    if isinstance(node, _Alt):
        out: Set[int] = set()
        for option in node.options:
            out.update(_match_node(option, steps, pos))
        return out

    if isinstance(node, _AndUnordered):
        out: Set[int] = set()
        for perm in itertools.permutations(node.parts):
            out.update(_match_node(_Seq(list(perm)), steps, pos))
        return out

    return set()


# ────────────────────────────────────
# Stage 3 — DISPLAY
# ────────────────────────────────────

def display(filtered: List[Filtered], args) -> Tuple[str, int]:
    """
    Produce the final text and total group count.
    """
    selective = args.script or args.output or args.reflection

    parts: List[str] = []
    total_groups = 0

    for i, fr in enumerate(filtered, start=1):
        r = fr.result
        if not fr.groups:
            continue

        total_groups += len(fr.groups)

        # Header per result
        header = "\n".join(
            [
                "=" * 40 + f"MATCH {i} " + "=" * 40,
                f"PENTEST RESULT {r.id}  |  {r.eval_name}",
                f"Model: {r.model_name}  |  Cost: ${r.model_costs:.4f}",
                f"Success: {r.success}",
                "=" * 80,
            ]
        )
        parts.append(header)

        # Render each group
        for g in fr.groups:
            if not g:
                continue
            first, last = g[0], g[-1]
            step_types = [s.step_type or "" for s in g]
            hdr = (
                f"Transition match: steps {first.step_num}‒{last.step_num}  "
                f"({' -> '.join(step_types)})"
            )
            parts.append(hdr)
            parts.append("-" * len(hdr))

            for s in g:
                if selective:
                    parts.extend(_render_selective_step(s, args))
                else:
                    parts.extend(_render_full_step(s))

    return "\n".join(parts), total_groups


def display_json(filtered: List[Filtered]) -> str:
    """
    Produce the final JSON output.
    """
    output_data = []

    for fr in filtered:
        if not fr.groups:
            continue

        result_data = {
            "result_id": fr.result.id,
            "eval_name": fr.result.eval_name,
            "model_name": fr.result.model_name,
            "model_costs": f"{fr.result.model_costs:.4f}",
            "success": fr.result.success,
            "groups": []
        }

        for g in fr.groups:
            if not g:
                continue

            group_data = {
                "steps": [s.step_num for s in g],
                "step_types": [s.step_type or "" for s in g],
                "details": []
            }

            for s in g:
                step_details = {
                    "step_num": s.step_num,
                    "reflection": s.reflection,
                    "script": s.script,
                    "output": s.execution_output,
                }
                group_data["details"].append(step_details)
            
            result_data["groups"].append(group_data)
        
        output_data.append(result_data)

    return json.dumps(output_data, indent=2)


# ────────────────────────────────────
# rendering helpers (unchanged in spirit)
# ────────────────────────────────────

def _render_full_step(step: AgentStep) -> List[str]:
    out: List[str] = []
    typ = step.step_type or ""
    out.append(f"[{step.step_num}]  {typ}")

    out.append("\nReflection:")
    out.append(str(step.reflection or ""))

    out.append("\nScript:")
    out.append(str(step.script or ""))

    out.append("\nExecution Output:")
    out.append(str(step.execution_output or ""))

    out.append("-" * 40)
    return out


def _render_selective_step(step: AgentStep, args) -> List[str]:
    parts: List[str] = []
    parts.append(f"[{step.step_num}]  {step.step_type}")
    if args.reflection and step.reflection:
        parts.append(str(step.reflection))
    if args.script and step.script:
        parts.append(str(step.script))
    if args.output and step.execution_output:
        parts.append(str(step.execution_output))

    joined = "\n".join(parts) if parts else ""
    return [joined, "-" * 40]
