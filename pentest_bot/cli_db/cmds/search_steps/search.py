 # search_steps.py – three-stage pipeline
from __future__ import annotations

from dataclasses import dataclass
from types import SimpleNamespace
from typing import List, Set, Tuple, Optional

import itertools

from pentest_bot.models.steps import AgentContext, AgentStep
from pentest_bot.db.tables.agent import (
    PentestResultORM,
    get_run,
    get_agent_ctxt,
    get_agent_results_by_evalname,
)

from .parser import (
    parse as _parse_pattern,
    Atom as _Atom,
    Seq as _Seq,
    Alt as _Alt,
    AndUnordered as _AndUnordered,
    Node as _Node,
)


# ────────────────────────────────────
# Small transport structs
# ────────────────────────────────────

@dataclass
class Collected:
    """Output of Stage 1 (Collect)."""
    result: PentestResultORM
    steps: List[AgentStep]


@dataclass
class Filtered:
    """Output of Stage 2 (Filter Steps)."""
    result: PentestResultORM
    groups: List[List[AgentStep]]  # each inner list is a contiguous slice


# ────────────────────────────────────
# Stage 1 — COLLECT
# ────────────────────────────────────
def collect_results(session, args) -> List[Collected]:
    """
    Collect the *results* we want to work on and materialize their AgentSteps.

    Accepted selectors:
      • --result-id RESULT_ID
      • --run-id RUN_ID
      • --eval-name NAME [--n 5]

    Returns
    -------
    List[Collected]
        Each element contains the PentestResultORM and its list[AgentStep].
    """
    out: List[Collected] = []

    # 1) --result-id
    if getattr(args, "result_id", None):
        res = (
            session.query(PentestResultORM)
            .filter(PentestResultORM.id == args.result_id)
            .first()
        )
        if res:
            ctxt = get_agent_ctxt(session, res.id)
            if ctxt:
                out.append(Collected(result=res, steps=list(ctxt.steps())))

    # 2) --run-id
    if getattr(args, "run_id", None):
        run = get_run(session, args.run_id)
        if run:
            for res in run.results:
                ctxt = get_agent_ctxt(session, res.id)
                if ctxt:
                    out.append(Collected(result=res, steps=list(ctxt.steps())))

    # 3) --eval-name (+ optional --n)
    if getattr(args, "eval_name", None):
        n = getattr(args, "n", 5)
        eval_results = get_agent_results_by_evalname(session, args.eval_name, n=n, eager=True)
        for res in eval_results:
            ctxt = get_agent_ctxt(session, res.id)
            if ctxt:
                out.append(Collected(result=res, steps=list(ctxt.steps())))

    return out


# ────────────────────────────────────
# Stage 2 — FILTER STEPS
# ────────────────────────────────────

def filter(collected: List[Collected], args) -> List[Filtered]:
    """
    Apply:
      • pattern grouping via --transition
      • optionally slice steps via --steps a b

    Returns one Filtered object per *result*.
    """
    pattern_expr = getattr(args, "transition", None)
    step_slice: Optional[Tuple[int, int]] = _parse_steps_slice(getattr(args, "steps", None))

    filtered: List[Filtered] = []
    for c in collected:
        steps = c.steps

        # optional [a, b] inclusive slice
        if step_slice is not None:
            a, b = step_slice
            # convert to 0-based and inclusive
            a_idx = max(a - 1, 0)
            b_idx = min(b, len(steps))
            steps = steps[a_idx:b_idx]

        # partition by transition pattern
        groups = _match_transition(steps, pattern_expr)
        filtered.append(Filtered(result=c.result, groups=groups))

    return filtered


def _parse_steps_slice(steps_arg) -> Optional[Tuple[int, int]]:
    """
    Parse --steps a b → (a, b). If None or invalid → None.
    """
    if not steps_arg:
        return None
    if len(steps_arg) == 1:
        # treat as [a, a]
        return steps_arg[0], steps_arg[0]
    if len(steps_arg) >= 2:
        a, b = steps_arg[0], steps_arg[1]
        if a > b:
            a, b = b, a
        return a, b
    return None


# ---------------------------------------------------------------------------
# Low-level matcher — returns *end positions* (exclusive) that can be reached
# when starting at ``pos``.
# ---------------------------------------------------------------------------

def _match_transition(steps: List[AgentStep], expr: str | None) -> List[List[AgentStep]]:
    """Return *all* contiguous slices matching *expr* according to the mini-grammar."""
    if not expr:
        return [[s] for s in steps]

    ast = _parse_pattern(expr)
    matches: List[List[AgentStep]] = []

    for start in range(len(steps)):
        ends = _match_node(ast, steps, start)
        for end in ends:
            if end > start:
                matches.append(steps[start:end])

    return matches


def _match_node(node: _Node, steps: List[AgentStep], pos: int) -> Set[int]:
    if pos > len(steps):
        return set()

    if isinstance(node, _Atom):
        lo, hi = node.rep
        cnt = 0
        while pos + cnt < len(steps) and steps[pos + cnt].step_type == node.name and cnt < hi:
            cnt += 1
        if cnt < lo:
            return set()
        return {pos + k for k in range(lo, cnt + 1)}

    if isinstance(node, _Seq):
        positions: Set[int] = {pos}
        for child in node.parts:
            next_positions: Set[int] = set()
            for p in positions:
                next_positions.update(_match_node(child, steps, p))
            if not next_positions:
                return set()
            positions = next_positions
        return positions

    if isinstance(node, _Alt):
        out: Set[int] = set()
        for option in node.options:
            out.update(_match_node(option, steps, pos))
        return out

    if isinstance(node, _AndUnordered):
        out: Set[int] = set()
        for perm in itertools.permutations(node.parts):
            out.update(_match_node(_Seq(list(perm)), steps, pos))
        return out

    return set()


# ────────────────────────────────────
# Stage 3 — DISPLAY
# ────────────────────────────────────

def display(filtered: List[Filtered], args) -> Tuple[str, int]:
    """
    Produce the final text and total group count.
    """
    selective = args.script or args.output or args.reflection

    parts: List[str] = []
    total_groups = 0

    for i, fr in enumerate(filtered, start=1):
        r = fr.result
        if not fr.groups:
            continue

        total_groups += len(fr.groups)

        # Header per result
        header = "\n".join(
            [
                "=" * 40 + f"MATCH {i} " + "=" * 40,
                f"PENTEST RESULT {r.id}  |  {r.eval_name}",
                f"Model: {r.model_name}  |  Cost: ${r.model_costs:.4f}",
                "=" * 80,
            ]
        )
        parts.append(header)

        # Render each group
        for g in fr.groups:
            if not g:
                continue
            first, last = g[0], g[-1]
            step_types = [s.step_type or "" for s in g]
            hdr = (
                f"Transition match: steps {first.step_num}‒{last.step_num}  "
                f"({' -> '.join(step_types)})"
            )
            parts.append(hdr)
            parts.append("-" * len(hdr))

            for s in g:
                if selective:
                    parts.extend(_render_selective_step(s, args))
                else:
                    parts.extend(_render_full_step(s))

    return "\n".join(parts), total_groups


# ────────────────────────────────────
# rendering helpers (unchanged in spirit)
# ────────────────────────────────────

def _render_full_step(step: AgentStep) -> List[str]:
    out: List[str] = []
    typ = step.step_type or ""
    out.append(f"[{step.step_num}]  {typ}")

    out.append("\nReflection:")
    out.append(str(step.reflection or ""))

    out.append("\nScript:")
    out.append(str(step.script or ""))

    out.append("\nExecution Output:")
    out.append(str(step.execution_output or ""))

    out.append("-" * 40)
    return out


def _render_selective_step(step: AgentStep, args) -> List[str]:
    parts: List[str] = []
    parts.append(f"[{step.step_num}]  {step.step_type}")
    if args.reflection and step.reflection:
        parts.append(str(step.reflection))
    if args.script and step.script:
        parts.append(str(step.script))
    if args.output and step.execution_output:
        parts.append(str(step.execution_output))

    joined = "\n".join(parts) if parts else ""
    return [joined, "-" * 40]
