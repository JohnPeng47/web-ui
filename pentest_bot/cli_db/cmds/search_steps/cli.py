from __future__ import annotations

from argparse import Namespace
from typing import Dict, List, Tuple
from collections import defaultdict

from pentest_bot.db import get_session
from pentest_bot.web_exploit.utils import get_token_count
from pentest_bot.db.tables.agent import (
    PentestResultORM,
    get_agent_steps,   # ← import this
)
from pentest_bot.cli_db.helpers import display_step_traces  # ← adjust to your real path

from .search import (
    collect_results,
    filter,
    display,
)


def search_steps_cmd(args: Namespace) -> None:
    """
    Search for step‑type transitions in AgentStep rows.

    Selectors (choose at least one):
        --run-id RUN_ID
        --result-id RESULT_ID
        --eval-name NAME [--n 5]

    Filters:
        --transition "S1 -> ... -> SN"
        --steps A B    (slice [A, B], inclusive, 1-based)

    Output fields:
        --reflection
        --script
        --output
    """
    need_selector = not (
        getattr(args, "run_id", None)
        or getattr(args, "result_id", None)
        or getattr(args, "eval_name", None)
    )
    if need_selector:
        print("[!] One of --run-id, --result-id or --eval-name is required")
        return

    with get_session() as session:
        collected = collect_results(session, args)
        if not collected:
            print("<no rows to search>")
            return

        # ------------------------------------------------------------------
        # DEFAULT DISPLAY PATH: step traces
        # Triggered only if *no* explicit display or filter knobs were given.
        # (reflection/script/output are display knobs; transition/steps are filters)
        # ------------------------------------------------------------------
        has_display_flags = bool(args.reflection or args.script or args.output)
        has_filter_flags = bool(getattr(args, "transition", None) or getattr(args, "steps", None))

        if not has_display_flags and not has_filter_flags:
            txt = _display_default_step_traces(session, [c.result for c in collected])
            print(txt)
            print(f"Total tokens: {get_token_count(txt)}")
            return

        # Otherwise, use the 3-stage pipeline you already have
        filtered = filter(collected, args)
        body, total_groups = display(filtered, args)
        print(body)
        print(f"Total groups returned: {total_groups}")
        print(f"Total tokens: {get_token_count(body)}")


def _display_default_step_traces(session, results: List[PentestResultORM]) -> str:
    """
    Build the eval_map / row_names_map / max_steps the same way you showed,
    then delegate to display_step_traces().
    """
    eval_map: Dict[str, List[List]] = defaultdict(list)
    row_names_map: Dict[str, List[str]] = defaultdict(list)
    max_steps = 0

    lines: List[str] = []

    for res in results:
        lines.append("\n" + "=" * 80)
        status_str = "Success" if bool(res.success) else "Failure"
        lines.append(f"PENTEST RESULT {res.id}: {res.eval_name} ({status_str})")
        lines.append(f"Model: {res.model_name}, Cost: ${res.model_costs:.4f}")
        lines.append("-" * 80)

        groups_data = get_agent_steps(session, res.id)
        if not groups_data:
            lines.append("<no agent steps found>")
            continue

        if res.eval_name not in eval_map:
            eval_map[res.eval_name] = []
            row_names_map[res.eval_name] = []

        for grp, steps in groups_data:
            status_str = "Pass" if bool(res.success) else "Fail"
            group_label = f"Result {res.id} Group {grp.group_id} ({status_str})"

            eval_map[res.eval_name].append(steps)
            row_names_map[res.eval_name].append(group_label)
            max_steps = max(max_steps, len(steps))

    if eval_map:
        lines.append("\nSTEP TRACES")
        # Assume display_step_traces returns a string. If it prints instead,
        # change this to capture or just call it and return "\n".join(lines).
        traces_txt = display_step_traces(eval_map, max_steps, row_names_map=row_names_map)
        if traces_txt:
            lines.append(traces_txt)

    return "\n".join(lines)
