from __future__ import annotations

from argparse import Namespace
from pentest_bot.db import get_session
from pentest_bot.db.tables.agent import (
    PentestResultORM,
    get_run,
    get_agent_ctxt,
)
from pentest_bot.web_exploit.utils import get_token_count

from .search import search_steps

def search_steps_cmd(args: Namespace) -> None:
    """
    Search for stepâ€‘type transitions in AgentStep rows.

    Required:
        --run-id RUN_ID      search all PentestResults in that run
            *or*
        --result-id RESULT_ID  search only that PentestResult

    Optional:
        --transition "S1 -> ... -> SN"
        --reflection     print reflection text
        --script         print script text
        --output         print execution_output text
        --steps A        return only step A
        --steps A B      return steps A through B (slice A:B)
    """
    if not args.run_id and not args.result_id:
        print("[!] Either --run-id or --result-id is required")
        return

    with get_session() as session:
        # 1. Collect matching results -----------------------------------------
        results: list[PentestResultORM] = []
        if args.run_id:
            run = get_run(session, args.run_id)
            if run is None:
                print(f"[!] Run ID {args.run_id} not found")
                return
            results.extend(run.results)

        if args.result_id:
            res = (
                session.query(PentestResultORM)
                .filter(PentestResultORM.id == args.result_id)
                .first()
            )
            if res is None:
                print(f"[!] PentestResult ID {args.result_id} not found")
                return
            results.append(res)

        if not results:
            print("<no PentestResult rows to search>")
            return

        # 2. Render each result -----------------------------------------------
        parts: list[str] = []
        total_groups = 0

        for i, r in enumerate(results, start=1):
            steps = get_agent_ctxt(session, r.id) or []
            if not steps:
                continue

            # Apply step filtering if --steps argument provided
            if hasattr(args, "steps") and args.steps:
                if len(args.steps) == 1:
                    # Single step index
                    step_idx = args.steps[0] - 1
                    if 0 <= step_idx < len(steps.steps()):
                        filtered_steps = [steps.steps()[step_idx]]
                    else:
                        continue  # Skip if index out of range
                elif len(args.steps) == 2:
                    # Step range slice
                    start_idx, end_idx = args.steps[0] - 1, args.steps[1] + 1
                    filtered_steps = steps.steps()[start_idx:end_idx]
                else:
                    filtered_steps = steps.steps()
                
                # Create a new AgentContext-like object with filtered steps
                from types import SimpleNamespace
                filtered_context = SimpleNamespace()
                filtered_context.steps = lambda: filtered_steps
                steps = filtered_context

            body, n_groups = search_steps(steps, args)
            if not body:
                continue

            total_groups += n_groups
            header = "\n".join(
                [
                    "=" * 40 + f"MATCH {i} " + "=" * 40,
                    f"PENTEST RESULT {r.id}  |  {r.eval_name}",
                    f"Model: {r.model_name}  |  Cost: ${r.model_costs:.4f}",
                    "=" * 80,
                ]
            )
            parts.extend([header, body])

        # 3. Final output ------------------------------------------------------
        final_out = "\n".join(parts)
        print(final_out)
        print(f"Total groups returned: {total_groups}")
        print(f"Total tokens: {get_token_count(final_out)}")

