from __future__ import annotations

from argparse import Namespace

from pentest_bot.db import get_session
from pentest_bot.db.tables.agent import (
    PentestResultORM,
    get_run,
    get_agent_steps,
)

from pentest_bot.cli_db.helpers import build_table, display_step_traces


def compare_steps_cmd(args: Namespace) -> None:
    """Display all AgentStep groups for a PentestResult (or each result in a run)."""

    if not getattr(args, "run_id", None) and not getattr(args, "result_id", None):
        print("[!] Either --run-id or --result-id is required")
        return

    with get_session() as session:
        results: list[PentestResultORM] = []

        if getattr(args, "run_id", None):
            run = get_run(session, args.run_id)
            if run is None:
                print(f"[!] Run ID {args.run_id} not found")
                return
            results.extend(run.results)

        if getattr(args, "result_id", None):
            res = (
                session.query(PentestResultORM)
                .filter(PentestResultORM.id == args.result_id)
                .first()
            )
            if res is None:
                print(f"[!] PentestResult ID {args.result_id} not found")
                return
            results.append(res)

        if not results:
            print("<no PentestResult rows found>")
            return

        # Build mapping eval_name -> List[List[AgentStep]]
        eval_map = {}
        row_names_map = {}
        max_steps = 0

        for res in results:
            # Print result summary
            print("\n" + "=" * 80)
            status_str = "Success" if bool(res.success) else "Failure"
            print(f"PENTEST RESULT {res.id}: {res.eval_name} ({status_str})")
            print(f"Model: {res.model_name}, Cost: ${res.model_costs:.4f}")
            print("-" * 80)

            groups_data = get_agent_steps(session, res.id)
            if not groups_data:
                print("<no agent steps found>")
                continue

            # Initialize lists for this eval_name if not present
            if res.eval_name not in eval_map:
                eval_map[res.eval_name] = []
                row_names_map[res.eval_name] = []

            # Process each group as a separate "result" for display
            for grp, steps in groups_data:
                prompt_label = (
                    f"{grp.opik_prompt_name or ''} @ {grp.opik_prompt_commit or '—'}"
                ).strip()
                group_label = f"Result {res.id} Group {grp.group_id} • {prompt_label}"
                
                eval_map[res.eval_name].append(steps)
                row_names_map[res.eval_name].append(group_label)
                
                # Update max_steps
                max_steps = max(max_steps, len(steps))

        # Display step traces using the helper function
        if eval_map:
            print("\nSTEP TRACES")
            display_step_traces(eval_map, max_steps, row_names_map=row_names_map)