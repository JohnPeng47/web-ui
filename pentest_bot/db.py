from __future__ import annotations

"""Light-weight SQLite helper used by PentestBot.

This module centralises database connectivity so that other parts of the
package (e.g. the web-exploit driver) can simply import
``SessionLocal``/``PentestResult`` without worrying about engines or
schemas.
"""

from contextlib import contextmanager
from datetime import datetime, timedelta
from pathlib import Path
from typing import Generator, Iterator

from sqlalchemy import func, case, Boolean, Column, DateTime, Float, Integer, String, ForeignKey, create_engine
from sqlalchemy.engine import Engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import Session, sessionmaker, relationship

# ---------------------------------------------------------------------------
# Engine & Session factory
# ---------------------------------------------------------------------------
_DB_FILE = Path(__file__).with_name("pentest_bot.sqlite")
# SQLite is included with CPython so we do not need an external runtime
_SQLITE_URL = f"sqlite:///{_DB_FILE}"

engine: Engine = create_engine(_SQLITE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)

# ---------------------------------------------------------------------------
# Declarative base & models
# ---------------------------------------------------------------------------
Base = declarative_base()


class PentestResult(Base):
    """ORM model that stores the outcome of a single PentestBot run."""

    __tablename__ = "pentest_results"

    id = Column(Integer, primary_key=True, autoincrement=True)
    run_id = Column(Integer, ForeignKey("runs.id", ondelete="CASCADE"), nullable=False)
    eval_name = Column(String, index=True, nullable=False)
    success = Column(Boolean, default=False, nullable=False)
    steps = Column(Integer, nullable=False)
    max_steps = Column(Integer, nullable=False)
    model_name = Column(String, nullable=False)
    model_costs = Column(Float, nullable=False)
    log_filepath = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

    # relationship back-reference
    run = relationship("Run", back_populates="results")
    # relationship to agent steps
    agent_steps = relationship("AgentStep", back_populates="pentest_result", cascade="all, delete-orphan")


# ---------------------------------------------------------------------------
# AgentStep model (many-to-one with PentestResult)
# ---------------------------------------------------------------------------


class AgentStep(Base):
    """ORM model that stores individual agent steps within a PentestResult."""

    __tablename__ = "agent_steps"

    id = Column(Integer, primary_key=True, autoincrement=True)
    pentest_result_id = Column(Integer, ForeignKey("pentest_results.id", ondelete="CASCADE"), nullable=False)
    step_number = Column(Integer, nullable=False)
    reflection = Column(String, nullable=False)
    script = Column(String, nullable=False)
    execution_output = Column(String, nullable=False)
    step_type = Column(String, nullable=True)
    step_descr = Column(String, nullable=True)
    add_to_scratchpad = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

    # relationship back-reference
    pentest_result = relationship("PentestResult", back_populates="agent_steps")


# ---------------------------------------------------------------------------
# Parent Run model (one-to-many with PentestResult)
# ---------------------------------------------------------------------------


class Run(Base):
    """Represents a logical run containing 1-N `PentestResult`."""

    __tablename__ = "runs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    comment = Column(String, nullable=True)
    parent_logdir = Column(String, nullable=False)
    is_eval = Column(Boolean, default=False, nullable=False)

    # collection of associated results
    results = relationship("PentestResult", back_populates="run", cascade="all, delete-orphan")



# ---------------------------------------------------------------------
# Query helpers (all accept an active SQLAlchemy Session)
# ---------------------------------------------------------------------
def get_runs_summary(
    session,
    *,
    limit: int | None = None,
    eval_only: bool = True,
):
    """
    Return one row per Run with aggregate success / step counts.

    Each row is a SimpleNamespace with attributes:
        id, created_at, comment, parent_logdir,
        total_results, successes, total_steps
    """
    qry = (
        session.query(
            Run.id.label("id"),
            Run.created_at.label("created_at"),
            Run.comment.label("comment"),
            Run.parent_logdir.label("parent_logdir"),
            func.count(PentestResult.id).label("total_results"),
            func.sum(
                case((PentestResult.success.is_(True), 1), else_=0)
            ).label("successes"),
            func.sum(PentestResult.steps).label("total_steps"),
        )
        .outerjoin(PentestResult)
        .group_by(Run.id)
        .order_by(Run.created_at.desc())
    )
    if eval_only:
        qry = qry.filter(Run.is_eval.is_(True))
    if limit is not None:
        qry = qry.limit(limit)
    return qry.all()


def get_run(session, run_id: int):
    """Return the Run ORM object (or None if not found)."""
    return session.query(Run).filter(Run.id == run_id).first()


def get_steps_for_result(session, result_id: int):
    """Return a list of AgentStep objects (sorted) or None if missing."""
    res = session.query(PentestResult).filter(
        PentestResult.id == result_id
    ).first()
    if res is None:
        return None
    return sorted(res.agent_steps, key=lambda s: s.step_number)


def get_cost_summary(session):
    """
    Compute usageâ€‘cost statistics.

    Returns:
        today_cost, week_cost, per_model_rows
    where per_model_rows is a list of
        (model_name, total_cost, total_steps, avg_per_step)
    """
    now = datetime.utcnow()
    today_start = datetime(now.year, now.month, now.day)
    tomorrow_start = today_start + timedelta(days=1)

    monday_start = today_start - timedelta(days=today_start.weekday())
    next_monday = monday_start + timedelta(days=7)

    today_cost = session.query(
        func.coalesce(func.sum(PentestResult.model_costs), 0.0)
    ).filter(
        PentestResult.created_at >= today_start,
        PentestResult.created_at < tomorrow_start,
    ).scalar()

    week_cost = session.query(
        func.coalesce(func.sum(PentestResult.model_costs), 0.0)
    ).filter(
        PentestResult.created_at >= monday_start,
        PentestResult.created_at < next_monday,
    ).scalar()

    per_model_raw = (
        session.query(
            PentestResult.model_name.label("model"),
            func.sum(PentestResult.model_costs).label("total_cost"),
            func.sum(PentestResult.steps).label("total_steps"),
        )
        .group_by(PentestResult.model_name)
        .all()
    )

    per_model_rows = []
    for row in per_model_raw:
        total_cost = float(row.total_cost or 0.0)
        total_steps = int(row.total_steps or 0)
        avg = total_cost / total_steps if total_steps else 0.0
        per_model_rows.append((row.model, total_cost, total_steps, avg))

    return today_cost, week_cost, per_model_rows


def delete_run(session, run_id: int):
    """Delete a Run and all associated PentestResults and AgentSteps.
    
    Returns:
        True if the run was found and deleted, False if not found.
    """
    run = session.query(Run).filter(Run.id == run_id).first()
    if run is None:
        return False
    
    session.delete(run)
    session.commit()
    return True


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def init_db() -> None:
    """Create all tables **if they do not yet exist**."""

    Base.metadata.create_all(bind=engine)


@contextmanager
def get_session() -> Iterator[Session]:
    """Context-manager friendly helper yielding a new DB session."""

    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()