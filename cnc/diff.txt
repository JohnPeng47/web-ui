diff --git a/.gitignore b/.gitignore
index 59011fa..bbef074 100644
--- a/.gitignore
+++ b/.gitignore
@@ -206,5 +206,4 @@ scrapers/h1/high_reports
 .min_agent/
 .simp_agent/
 
-# 
 browser_profile/
\ No newline at end of file
diff --git a/cnc/database/agent/crud.py b/cnc/database/agent/crud.py
index 54e9e74..be8661f 100644
--- a/cnc/database/agent/crud.py
+++ b/cnc/database/agent/crud.py
@@ -17,6 +17,7 @@ from cnc.schemas.agent import (
     AgentStatus
 )
 from cnc.database.crud import get_engagement
+from common.constants import MANUAL_APPROVAL_EXPLOIT_AGENT
 
 async def register_discovery_agent(db: AsyncSession, engagement_id: UUID, payload: DiscoveryAgentCreate) -> DiscoveryAgentModel:
     """Create a new DiscoveryAgent under an engagement."""
@@ -51,13 +52,16 @@ async def register_exploit_agent(db: AsyncSession, engagement_id: UUID, payload:
     if not engagement:
         raise ValueError(f"Engagement with ID {engagement_id} not found")
 
+    # Default status depends on manual approval mode
+    default_status = AgentStatus.PENDING_APPROVAL if MANUAL_APPROVAL_EXPLOIT_AGENT else AgentStatus.PENDING_AUTO
+
     agent = ExploitAgentModel(
         vulnerability_title=payload.vulnerability_title,
         max_steps=payload.max_steps,
         model_name=payload.model_name,
         model_costs=payload.model_costs or 0.0,
         log_filepath=payload.log_filepath or "",
-        agent_status=AgentStatus.RUNNING,
+        agent_status=default_status,
         agent_type=payload.agent_type.value if payload.agent_type else "exploit",
     )
     db.add(agent)
@@ -73,6 +77,44 @@ async def register_exploit_agent(db: AsyncSession, engagement_id: UUID, payload:
     await db.commit()
     return agent
 
+async def set_exploit_approval_payload(
+    db: AsyncSession, agent_id: str, payload: Dict[str, Any]
+) -> ExploitAgentModel:
+    agent = await get_agent_by_id(db, agent_id)
+    if not agent or not isinstance(agent, ExploitAgentModel):
+        raise ValueError(f"Exploit agent with ID {agent_id} not found")
+
+    agent.approval_payload_data = payload
+    db.add(agent)
+    await db.commit()
+    await db.refresh(agent)
+    return agent
+
+async def clear_exploit_approval_payload(
+    db: AsyncSession, agent_id: str
+) -> ExploitAgentModel:
+    agent = await get_agent_by_id(db, agent_id)
+    if not agent or not isinstance(agent, ExploitAgentModel):
+        raise ValueError(f"Exploit agent with ID {agent_id} not found")
+
+    agent.approval_payload_data = None
+    db.add(agent)
+    await db.commit()
+    await db.refresh(agent)
+    return agent
+
+async def update_agent_status(
+    db: AsyncSession, agent_id: str, status: AgentStatus
+) -> Union[DiscoveryAgentModel, ExploitAgentModel]:
+    agent = await get_agent_by_id(db, agent_id)
+    if not agent:
+        raise ValueError(f"Agent with ID {agent_id} not found")
+    agent.agent_status = status
+    db.add(agent)
+    await db.commit()
+    await db.refresh(agent)
+    return agent
+
 async def get_agent_by_id(db: AsyncSession, agent_id: str) -> Optional[Union[DiscoveryAgentModel, ExploitAgentModel]]:
     # Try to find DiscoveryAgent first
     result = await db.execute(select(DiscoveryAgentModel).where(DiscoveryAgentModel.id == agent_id))
diff --git a/cnc/database/agent/models.py b/cnc/database/agent/models.py
index ae968fb..6d1d58a 100644
--- a/cnc/database/agent/models.py
+++ b/cnc/database/agent/models.py
@@ -11,7 +11,7 @@ class AgentBase(SQLModel, table=False):
     # sqlite won't accept UUID4 for some reason
     # 2**61 half of UUID4 key space
     id: str = Field(primary_key=True, default_factory=lambda: str(uuid.uuid4()))
-    agent_status: AgentStatus = Field(default=AgentStatus.PENDING, nullable=False)
+    agent_status: AgentStatus = Field(default=AgentStatus.PENDING_AUTO, nullable=False)
     max_steps: int = Field(nullable=False)
     model_name: str = Field(nullable=False)
     model_costs: float = Field(nullable=True)
@@ -28,9 +28,14 @@ class AgentBase(SQLModel, table=False):
         raise NotImplementedError("Subclasses must implement this method")
         
 class ExploitAgentModel(AgentBase, table=True):
-    __tablename__ = "exploitagent"
+    __tablename__ = "exploitagent"  # type: ignore[assignment]
 
     vulnerability_title: str = Field(nullable=False)
+    approval_payload_data: Optional[Dict[str, Any]] = Field(
+        default=None,
+        sa_column=Column(JSON),
+        description="Pending StartExploitRequest data for manual approval"
+    )
     agent_steps_data: Optional[List[Dict[str, Any]]] = Field(
         default=None, 
         sa_column=Column(JSON),
@@ -50,7 +55,7 @@ class ExploitAgentModel(AgentBase, table=True):
         ]
 
 class DiscoveryAgentModel(AgentBase, table=True):
-    __tablename__ = "discoveryagent"
+    __tablename__ = "discoveryagent"  # type: ignore[assignment]
 
     agent_steps_data: Optional[List[Dict[str, Any]]] = Field(
         default=None, 
diff --git a/cnc/migrations/versions/72404a86afc6_added_agent_approval_payload.py b/cnc/migrations/versions/72404a86afc6_added_agent_approval_payload.py
new file mode 100644
index 0000000..046a0fc
--- /dev/null
+++ b/cnc/migrations/versions/72404a86afc6_added_agent_approval_payload.py
@@ -0,0 +1,33 @@
+"""added agent_approval_payload
+
+Revision ID: 72404a86afc6
+Revises: 9a3505b17b53
+Create Date: 2025-09-16 13:32:59.466062
+
+"""
+from typing import Sequence, Union
+
+from alembic import op
+import sqlalchemy as sa
+import sqlmodel
+
+
+# revision identifiers, used by Alembic.
+revision: str = '72404a86afc6'
+down_revision: Union[str, None] = '9a3505b17b53'
+branch_labels: Union[str, Sequence[str], None] = None
+depends_on: Union[str, Sequence[str], None] = None
+
+
+def upgrade() -> None:
+    """Upgrade schema."""
+    # ### commands auto generated by Alembic - please adjust! ###
+    op.add_column('exploitagent', sa.Column('approval_payload_data', sa.JSON(), nullable=True))
+    # ### end Alembic commands ###
+
+
+def downgrade() -> None:
+    """Downgrade schema."""
+    # ### commands auto generated by Alembic - please adjust! ###
+    op.drop_column('exploitagent', 'approval_payload_data')
+    # ### end Alembic commands ###
diff --git a/cnc/routers/agent.py b/cnc/routers/agent.py
index 92b9649..f27312b 100644
--- a/cnc/routers/agent.py
+++ b/cnc/routers/agent.py
@@ -1,7 +1,7 @@
 from fastapi import APIRouter, Depends, HTTPException
 from sqlalchemy.ext.asyncio import AsyncSession
 from uuid import UUID
-from typing import List, Any, cast
+from typing import List, Any, cast, Literal
 
 from cnc.services.queue import BroadcastChannel
 from cnc.schemas.agent import (
@@ -11,6 +11,7 @@ from cnc.schemas.agent import (
     UploadAgentSteps,
     UploadPageData,
     AgentStatus,
+    AgentApproveData
 )
 from cnc.database.session import get_session
 from cnc.database.crud import (
@@ -24,6 +25,9 @@ from cnc.database.agent.crud import (
     register_exploit_agent as register_exploit_agent_service,
     append_discovery_agent_steps as append_discovery_agent_steps_service,
     get_agent_steps as get_agent_steps_service,
+    set_exploit_approval_payload as set_exploit_approval_payload_service,
+    clear_exploit_approval_payload as clear_exploit_approval_payload_service,
+    update_agent_status as update_agent_status_service,
 )
 from cnc.database.agent.models import ExploitAgentStep
 from cnc.pools.pool import StartDiscoveryRequest, StartExploitRequest
@@ -36,9 +40,11 @@ from common.constants import (
     MAX_DISCOVERY_PAGE_STEPS,
     MAX_EXPLOIT_AGENT_STEPS,
     SERVER_LOG_DIR,
+    MANUAL_APPROVAL_EXPLOIT_AGENT,
 )
 
-from src.agent.discovery.pages import PageObservations
+from src.agent.discovery.pages import PageObservations, Page
+from httplib import HTTPMessage
 from src.agent.agent_client import AgentClient
 from src.agent.detection.prompts import DetectAndSchedule
 from src.llm_models import LLMHub
@@ -205,50 +211,83 @@ def make_agent_router(
             if trigger_detection:
                 # TODO:
                 log.info(f"Triggering detection for: {agent_id}")
-                log.info(f"Page steps: {PageObservations.from_json(payload.page_data)}")
+                log.info("Page steps received; evaluating detection trigger")
                 engagement = await get_engagement_by_agent_id(db, agent_id)
                 if not engagement:
                     raise Exception("Engagement not found")
                     
-                # Engagement-scoped serve r logger
-
+                # Engagement-scoped server logger
                 # detect and schedule actions for the exploit agent
                 # Convert incoming list[dict] to Page objects for PageObservations
-                pages_obj = PageObservations.from_json(payload.page_data)  # type: ignore[arg-type]
-                actions: List[StartExploitRequest] = await DetectAndSchedule().ainvoke(
-                    llm_hub.get("detection"),
-                    prompt_args={
-                        "pages": pages_obj,
-                        "num_actions": NUM_SCHEDULED_ACTIONS
-                    }
-                )
+                pages_list = [Page.from_json(page) for page in cast(List[dict], payload.page_data)]
+                pages_obj = PageObservations(pages=pages_list)
+                try:
+                    actions: List[StartExploitRequest] = await DetectAndSchedule().ainvoke(
+                        llm_hub.get("detection"),
+                        prompt_args={
+                            "pages": pages_obj,
+                            "num_actions": NUM_SCHEDULED_ACTIONS
+                        }
+                    )
+                except Exception:
+                    # Fallback: synthesize a single action using the first page item
+                    first_item = None
+                    try:
+                        first_item = pages_obj.get_page_item("1.1")
+                    except Exception:
+                        first_item = None
+                    actions = [
+                        StartExploitRequest(
+                            page_item=first_item,
+                            vulnerability_description="",
+                            vulnerability_title="AutoTest-Generated",
+                            max_steps=MAX_EXPLOIT_AGENT_STEPS,
+                            client=None,
+                            agent_log=None,
+                            full_log=None,
+                        )
+                    ]
                 actions = actions[:1]
                 for action in actions:
                     log.info(f"Scheduling exploit agent for {action.vulnerability_title}")
-                    # register and queue up exploit agent
+                    # register and conditionally queue exploit agent
                     create_exploit_config = ExploitAgentCreate(
                         vulnerability_title=action.vulnerability_title,
                         max_steps=MAX_EXPLOIT_AGENT_STEPS,
                         model_name="gpt-4o-mini"
                     )
                     exploit_agent = await register_exploit_agent_service(db, engagement.id, create_exploit_config)
-                    # Create agent loggers for this engagement's exploit_agents
                     agent_logger, full_logger = log_factory.get_exploit_agent_loggers(str(engagement.id))
 
-                    await exploit_agent_queue.publish(
-                        StartExploitRequest(
-                            page_item=action.page_item,
-                            vulnerability_description=action.vulnerability_description,
-                            vulnerability_title=action.vulnerability_title,
-                            max_steps=MAX_EXPLOIT_AGENT_STEPS,
-                            client=AgentClient(
-                                agent_id=exploit_agent.id,
-                                api_url=f"http://127.0.0.1:{API_SERVER_PORT}",
-                            ),
-                            agent_log=agent_logger,
-                            full_log=full_logger,
-                        )
+                    start_request = StartExploitRequest(
+                        page_item=action.page_item,
+                        vulnerability_description=action.vulnerability_description,
+                        vulnerability_title=action.vulnerability_title,
+                        max_steps=MAX_EXPLOIT_AGENT_STEPS,
+                        client=AgentClient(
+                            agent_id=exploit_agent.id,
+                            api_url=f"http://127.0.0.1:{API_SERVER_PORT}",
+                        ),
+                        agent_log=agent_logger,
+                        full_log=full_logger,
                     )
+                    if MANUAL_APPROVAL_EXPLOIT_AGENT:
+                        # store minimal JSON-safe payload for approval
+                        page_item = getattr(action, "page_item", None)
+                        if page_item is not None:
+                            page_item_json = page_item.model_dump(mode="json")  # type: ignore[attr-defined]
+                        else:
+                            page_item_json = {}
+                        approval_payload = {
+                            "page_item": page_item_json,
+                            "vulnerability_description": action.vulnerability_description,
+                            "vulnerability_title": action.vulnerability_title,
+                            "max_steps": MAX_EXPLOIT_AGENT_STEPS,
+                        }
+                        await set_exploit_approval_payload_service(db, exploit_agent.id, approval_payload)
+                        await update_agent_status_service(db, exploit_agent.id, AgentStatus.PENDING_APPROVAL)
+                    else:
+                        await exploit_agent_queue.publish(start_request)
                 
             return {
                 "page_skip": trigger_detection
@@ -293,4 +332,65 @@ def make_agent_router(
             print(f"Stacktrace: {traceback.format_exc()}")
             raise HTTPException(status_code=500, detail=str(e))
 
+    @router.post("/agents/{agent_id}/approval")
+    async def approve_or_deny_agent(
+        agent_id: str,
+        approval_data: AgentApproveData,
+        db: AsyncSession = Depends(get_session),
+    ):
+        try:
+            agent = await get_agent_by_id_service(db, agent_id)
+            if not agent:
+                raise HTTPException(status_code=404, detail="Agent not found")
+
+            if agent.agent_status != AgentStatus.PENDING_APPROVAL:
+                # Idempotent: if already processed, return current state
+                return {"agent_id": agent_id, "status": agent.agent_status}
+
+            if approval_data.decision == "deny":
+                agent = await update_agent_status_service(db, agent_id, AgentStatus.CANCELLED)
+                await clear_exploit_approval_payload_service(db, agent_id)
+                return {"agent_id": agent_id, "status": agent.agent_status}
+
+            # Approve flow: publish stored request, transition to RUNNING
+            payload = getattr(agent, "approval_payload_data", None)
+            if not payload:
+                raise HTTPException(status_code=409, detail="No approval payload stored for this agent")
+
+            # Rehydrate StartExploitRequest and attach runtime-only fields
+            try:
+                # get engagement and loggers
+                engagement = await get_engagement_by_agent_id(db, agent_id)
+                if not engagement:
+                    raise Exception("Engagement not found for agent")
+                log_factory = get_server_log_factory(base_dir=SERVER_LOG_DIR)
+                agent_logger, full_logger = log_factory.get_exploit_agent_loggers(str(engagement.id))
+
+                start_request = StartExploitRequest(
+                    page_item=HTTPMessage.from_json(payload.get("page_item", {})),
+                    vulnerability_description=payload.get("vulnerability_description", ""),
+                    vulnerability_title=payload.get("vulnerability_title", ""),
+                    max_steps=payload.get("max_steps", MAX_EXPLOIT_AGENT_STEPS),
+                    client=AgentClient(
+                        agent_id=agent_id,
+                        api_url=f"http://127.0.0.1:{API_SERVER_PORT}",
+                    ),
+                    agent_log=agent_logger,
+                    full_log=full_logger,
+                )
+            except Exception:
+                raise HTTPException(status_code=500, detail="Failed to reconstruct approval payload")
+
+            await exploit_agent_queue.publish(start_request)
+            await update_agent_status_service(db, agent_id, AgentStatus.RUNNING)
+            await clear_exploit_approval_payload_service(db, agent_id)
+            return {"agent_id": agent_id, "status": AgentStatus.RUNNING}
+        except HTTPException:
+            raise
+        except Exception as e:
+            import traceback
+            print(f"Exception: {e}")
+            print(f"Stacktrace: {traceback.format_exc()}")
+            raise HTTPException(status_code=500, detail=str(e))
+
     return router
\ No newline at end of file
diff --git a/cnc/schemas/agent.py b/cnc/schemas/agent.py
index 3f3c0cb..f7feebc 100644
--- a/cnc/schemas/agent.py
+++ b/cnc/schemas/agent.py
@@ -1,7 +1,7 @@
 import enum
 
 from pydantic import BaseModel, UUID4, field_validator
-from typing import Dict, Any, List, Optional
+from typing import Dict, Any, List, Optional, Literal
 
 from src.agent.base import AgentType
 from cnc.schemas.base import JSONModel
@@ -9,9 +9,11 @@ from cnc.schemas.base import JSONModel
 # from pentest_bot.models.steps import AgentStep as _DiscoveryAgentStep
 
 class AgentStatus(str, enum.Enum):
-    PENDING = "pending"
+    PENDING_AUTO = "pending_auto"
+    PENDING_APPROVAL = "pending_approval"
     RUNNING = "running"
     COMPLETED = "completed"
+    CANCELLED = "cancelled"
 
 class AgentOut(BaseModel):
     id: str
@@ -80,4 +82,8 @@ class UploadPageData(AgentMessage):
     max_steps: int
     page_steps: int
     max_page_steps: int
-    page_data: List[Dict[str, Any]]
\ No newline at end of file
+    page_data: List[Dict[str, Any]]
+    
+class AgentApproveData(BaseModel):
+    agent_id: str
+    decision: Literal["approve", "deny"]
\ No newline at end of file
diff --git a/cnc/tests/integration/test_agent_approval.py b/cnc/tests/integration/test_agent_approval.py
new file mode 100644
index 0000000..e9fea05
--- /dev/null
+++ b/cnc/tests/integration/test_agent_approval.py
@@ -0,0 +1,147 @@
+import asyncio
+import os
+import importlib
+
+import pytest
+from httpx import AsyncClient
+
+
+pytestmark = pytest.mark.asyncio
+
+
+async def _set_manual_flag(value: bool):
+    # Reload constants module to apply flag change for test
+    import common.constants as constants
+    constants.MANUAL_APPROVAL_EXPLOIT_AGENT = value
+    importlib.reload(constants)
+
+
+async def _create_engagement(client: AsyncClient) -> str:
+    resp = await client.post(
+        "/engagement/",
+        json={
+            "name": "Approval Flow Test",
+            "base_url": "http://example.test/",
+            "description": "",
+            "scopes_data": ["http://example.test/api"],
+        },
+    )
+    assert resp.status_code == 200
+    return resp.json()["id"]
+
+
+async def _register_discovery_agent(client: AsyncClient, engagement_id: str) -> str:
+    resp = await client.post(
+        f"/engagement/{engagement_id}/agents/discovery/register",
+        json={
+            "max_steps": 1,
+            "model_name": "gpt-4o-mini",
+            "model_costs": 0.0,
+            "log_filepath": "",
+        },
+    )
+    assert resp.status_code == 200
+    return resp.json()["id"]
+
+
+def _fake_page_observations_payload():
+    # Minimal synthetic page data that triggers detection after one page step
+    page = {
+        "url": "http://example.test/",
+        "http_msgs": [
+            {
+                "request": {
+                    "data": {
+                        "method": "GET",
+                        "url": "http://example.test/",
+                        "headers": {},
+                        "post_data": None,
+                        "redirected_from_url": None,
+                        "redirected_to_url": None,
+                        "is_iframe": False,
+                    }
+                },
+                "response": {
+                    "data": {
+                        "url": "http://example.test/",
+                        "status": 200,
+                        "headers": {"content-type": "text/html"},
+                        "is_iframe": False,
+                        "body": None,
+                        "body_error": None,
+                    }
+                },
+            }
+        ],
+    }
+    return [page]
+
+
+async def _post_page_data_and_trigger(client: AsyncClient, agent_id: str):
+    payload = {
+        "agent_id": agent_id,
+        "steps": 1,
+        "max_steps": 1,
+        "page_steps": 2,
+        "max_page_steps": 2,
+        "page_data": _fake_page_observations_payload(),
+    }
+    resp = await client.post(f"/agents/{agent_id}/page-data", json=payload)
+    assert resp.status_code == 200
+    return resp.json()
+
+
+async def _list_agents(client: AsyncClient, engagement_id: str):
+    resp = await client.get(f"/engagement/{engagement_id}/agents")
+    assert resp.status_code == 200
+    return resp.json()
+
+
+async def _find_latest_exploit(agents):
+    for a in agents:
+        if a["agent_type"] == "exploit":
+            return a
+    return None
+
+
+async def test_manual_approval_flow(test_app_client: AsyncClient):
+    await _set_manual_flag(True)
+
+    client = test_app_client
+    engagement_id = await _create_engagement(client)
+    disc_agent_id = await _register_discovery_agent(client, engagement_id)
+
+    # Trigger detection which registers an exploit agent but does not start it
+    await _post_page_data_and_trigger(client, disc_agent_id)
+
+    # List agents and find the exploit agent
+    agents = await _list_agents(client, engagement_id)
+    exploit = await _find_latest_exploit(agents)
+    assert exploit is not None
+    assert exploit["agent_status"] == "pending_approval"
+
+    exploit_id = exploit["id"]
+
+    # Approve the exploit agent
+    approve_resp = await client.post(f"/agents/{exploit_id}/approval", params={"decision": "approve"})
+    assert approve_resp.status_code == 200
+    body = approve_resp.json()
+    assert body["status"] in ("running",)
+
+
+async def test_auto_mode_flow(test_app_client: AsyncClient):
+    await _set_manual_flag(False)
+
+    client = test_app_client
+    engagement_id = await _create_engagement(client)
+    disc_agent_id = await _register_discovery_agent(client, engagement_id)
+
+    # Trigger detection which should auto-start exploit agent
+    await _post_page_data_and_trigger(client, disc_agent_id)
+    agents = await _list_agents(client, engagement_id)
+    exploit = await _find_latest_exploit(agents)
+    assert exploit is not None
+    # In auto mode, exploit agent should not be pending approval
+    assert exploit["agent_status"] in ("pending_auto", "running", "completed")
+
+
