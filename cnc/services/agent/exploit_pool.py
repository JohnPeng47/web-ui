import asyncio
import signal

from pydantic import BaseModel
from typing import Optional, Callable, Type

from pentest_bot.web_exploit.agent import PentestSession
from pentest_bot.web_exploit.tools import PythonInterpreter
from pentest_bot.web_exploit.prompts.exploit_agent import AGENT_PROMPT_ORIGINAL
from common.prompt import PromptConfig, PromptStrategy
from common.eval_pool import EvalAgentPool
from eval.harness.exploit.queue import PersistedQueue
from eval.datasets.detection import VULN_QUEUE_JSON, SINGLE_ITEM_QUEUE_JSON
from src.detection.prompts import StartExploitRequest

from logger import setup_agent_logger, get_agent_loggers

from common.constants import MAX_EXPLOIT_AGENT_STEPS

agent_log, full_log = get_agent_loggers()

MAX_WORKERS = 3 # 1 for testing
MAX_STEPS = 3
LLM_CONFIG = {
    "model_config": {
        "classify-steps": "o4-mini",
        "agent": "gpt-4o"
    }
}

class AgentStartConfig(BaseModel):
    problem_statement: str
    eval_fn: Optional[Callable[[], bool]]
    max_steps: int

    def __str__(self):
        output = ""
        output += f"Problem Statement: {self.problem_statement}\n"
        output += f"Max Steps: {self.max_steps}\n"
        return output

class EvalExploitAgentPool(EvalAgentPool[StartExploitRequest]):
    """
    AgentPool that consumes work from a BroadCastChannel constructed from Serialized Data
    Subscribes to the channel, pops each item, converts it to AgentStartConfig,
    then enqueues an agent run with start_agent(request).

    You must implement convert_req(self, item: Q) -> AgentStartConfig.
    """
    def __init__(
        self,
        *,
        channel: PersistedQueue[StartExploitRequest],
        item_cls: Type[StartExploitRequest],
        queue_fp: str,
        llm_config: dict,
        max_workers: Optional[int] = None,
        log_subfolder: str = "pentest_bot",
        interp_cls: type[PythonInterpreter] = PythonInterpreter,
        label_steps: bool = False,
    ):
        super().__init__(
            channel=channel,
            item_cls=item_cls,
            queue_fp=queue_fp,
            llm_config=llm_config,
            max_workers=max_workers,
            log_subfolder=log_subfolder,
            label_steps=label_steps,
        )
        self.interp_cls = interp_cls

    async def start_agent_session(self, queue_item: StartExploitRequest) -> PentestSession:
        """
        Build and run a PentestSession for a single lab/request.
        """
        # TODO: only tool we need is the xss_check_tool
        # with BrowserClient() as ctx:
        #     fetch_tool_template = create_browser_fetch_tool(ctx)
        #     xss_check_tool_template, check_cb, target_url = create_browser_check_xss_tool(ctx)
        #     tools = {**xss_check_tool_template, **fetch_tool_template}

        problem_statement = f"""
Here is a description of the vulnerability:
{queue_item.vulnerability_description}

Here is the HTTP message that is related to the vulnerability:
{await queue_item.page_item.to_str()}
""" 
        print("Starting pentest session")
        tools: dict = {}
        interpreter = self.interp_cls(shared_globals=tools)

        session = PentestSession(
            model_config=self.llm_config["model_config"],
            prompt_config=PromptConfig(
                strategy=PromptStrategy.MANUAL,
                prompt=AGENT_PROMPT_ORIGINAL
            ),
            problem_stmt=problem_statement,
            max_steps=MAX_EXPLOIT_AGENT_STEPS,
            eval_fn=None,
            interpreter=interpreter,
        )
        session.run()
        return session

async def run_asyncio_loop_with_sigint_handling(agent_pool: EvalAgentPool):
    loop = asyncio.get_running_loop()
    await agent_pool.start_channel_consumer()

    print("Started channel consumer")

    try:
        # https://chatgpt.com/c/68b8db0e-0910-832e-b8d7-972204f79797
        # Does not explain why signal.signal handler does not fire though
        signal.signal(signal.SIGINT, agent_pool._sigint)
        signal.signal(signal.SIGTERM, agent_pool._sigint)
        loop.add_signal_handler(signal.SIGINT, agent_pool._sigint)
        loop.add_signal_handler(signal.SIGTERM, agent_pool._sigint)
    except NotImplementedError:
        # Windows fallback: use sync handler + thread-safe callback
        def _sync_handler(signum, frame):
            loop.call_soon_threadsafe(agent_pool._sigint)

        signal.signal(signal.SIGINT, _sync_handler)
        if hasattr(signal, "SIGTERM"):
            signal.signal(signal.SIGTERM, _sync_handler)

    # - first the signal handlers registered on the event loop will not trigger since loop returned
    # - second, after asyncio.run() finishes, the main thread enters shutdown process
    # > while it waits for non-daemon threads to join (ThreadPoolExecutor threads)
    # > during this process no signal handlers are active to catch the signals
    while True:
        await asyncio.sleep(1)

if __name__ == "__main__":
    import asyncio

    setup_agent_logger(log_dir=".min_agent/logs")

    vuln_queue = PersistedQueue()
    agent_pool = EvalExploitAgentPool(
        channel=vuln_queue,
        queue_fp=VULN_QUEUE_JSON,
        llm_config=LLM_CONFIG,
        max_workers=MAX_WORKERS,
        item_cls=StartExploitRequest
    )

    asyncio.run(run_asyncio_loop_with_sigint_handling(agent_pool))